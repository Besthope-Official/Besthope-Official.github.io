<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2022年终总结</title>
    <url>/2022/12/31/2022%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>你会用什么关键字概括2022年呢...... 各种意义上的Twist. 人生的转折,
政策的转折, 世界的转折. 年初的时候还祝福今年诸事皆顺,
不过心意到了抽签抽到凶也没办法.</p>
<span id="more"></span>
<h2 id="人生的转折">人生的转折</h2>
<h3 id="上半年">上半年</h3>
<p>年初还在高三上的课堂, 年末大一上快结束了. 弹指一瞬所谓如此.</p>
<p>不过高中到底干了啥? 很难用量化的指标记录下我的成长.
可能每天多做了几张卷子, 但现在全然已经忘光了.
或许仅存的笔记本还余留着少许记忆,
但我想我也不会再度翻开当时的笔记了.</p>
<p>今年的个人大事, 要说还是高考.</p>
<p>忍受了高中三年那非人的安排就为了一张文凭,
可有人还要把这个过程拉长到研究生阶段.
不过也没必要过分批判中学的应试教育. 虽然阴郁得让人抬不起头, 但回忆高中,
除了黑历史, 剩下快乐的也不少. 除此之外,
高中接受的通识教育是我受益最大的. 当我阳了以后,
那些学习的生物知识很庆幸还能用 (bushi</p>
<p>其实高考成绩不能算太糟, 至少比我一模二模都高.
但也没有所谓的超常发挥啥的, 和真的佬差太多. 最终去向是某财经211的CS专业.
一开始还在思考怎么自救. 现在想想, 自己的赛道还算广阔.
至少学历坎越过双非, 择业方向可金融可CS, 但最重要的是, 专业是自己喜欢的.
一想到自己下一个志愿的专业是机械电子我就魂打颤.</p>
<p>虽然说成都有点远是了. 但现代社会距离已经不是一个问题了,
去外边见见世面总是好的. (除了车票好贵QAQ)</p>
<h3 id="下半年">下半年</h3>
<p>总结一下自己大一学的知识:</p>
<ul>
<li>更深入地学习了C语言</li>
<li>学习了CMU CS15-213 CSAPP前3章+第五章 完成了data/bomb/attack lab
<ul>
<li>学习了数据的机器级表示</li>
<li>用 wsl 作为 Linux 的开发环境</li>
<li>比较全面地学习了x86-64的汇编 同时有逆向工程的一定能力</li>
</ul></li>
<li>学习了MIT Missing Semester
<ul>
<li>学习到了很多实用工具 Git GDB Docker</li>
</ul></li>
<li>加入了学校里一个组织的后端部
<ul>
<li>其实没干啥 (小声bb</li>
</ul></li>
<li>搭建了自己的博客 Hexo+NexT</li>
<li>初步学习了算法/数据结构</li>
<li>数学微积分上册</li>
<li>啃了本古典经济学的著作</li>
</ul>
<p>挺内疚的, 来大学的第一个月, 非常勤勉, 天天跑图书馆, Github每天更新,
然后越到后面越咸鱼. 11月12月好像就没去过图书馆(
大部分精力投入到了CSAPP上, 不过收获也是巨大的.</p>
<p>剩下的学习时间大部分浪费在了那些通识基础课上. 没错, 说的就是你,
大学物理( 其实我的大一上还是比较悠闲的. 虽然每天早八,
但基本上下午没啥课. 下学期就不是这样了.</p>
<p>感觉学了挺多编程相关的内容. 不过, 自己的编程能力仍然有待提高.
依然处于不STFW就寸步难行的阶段.</p>
<h3 id="新年期许">新年期许</h3>
<p>给自己的学习计划. 看看下学期能实现多少: 大一寒假: ACWing 算法基础课 +
每日一题 顺便打游戏+过了科二 主要提高自己的算法基础+编程能力</p>
<p>大一下的学习计划: 这学期数学基础课比较多 多元微积分 离散数学
高等代数等 大概率学习时间会很压缩 程序课我选的 Python(另一个选项是JAVA)
对应 CS61A (Python) + SICP 狠狠地学 下学期顺便把 Berkeley 的 CS70
(Discrete Math) 刷完</p>
<p>1.31 Update 寒假每日一题基本上做完了 算法基础课才是大头 汗
拿了驾照了hh</p>
<h2 id="政策的转折">政策的转折</h2>
<p>今年政策风向的变动大家有目共睹. 如果可以, 不妨回顾这一年新闻的<a
href="https://www.bilibili.com/video/BV1QM411C7kd/">合订本</a>.</p>
<p>我们每个人都是疫情的亲历者.
武汉疫情爆发初期的寒假(2020年初)我待在温州,
没料想当时温州市区属于重灾区. 封在老家大概持续了3个月. 2021年的暑期,
常熟疫情, 线上网课. 2022年4月苏州疫情, 常熟的高中开始封校.
在学校隔绝学习了一个月, 第一次感到自己的压抑.
还记得五一还有各种节日自己窝在寝室里画画. 真的非常无聊的日子.
第一次学会玩象棋. 2022年8月, 四川高温限电, 我是月底到的成都,
此时限电基本结束. 9月, 成都疫情. 又封校了一个月. 2022年12月, 国家放开.
12月28日, 我感染了新冠, 近年来最难受的几天.</p>
<p>本来以为能这辈子不感染, 结果下一秒打脸 :(</p>
<p>剩下一年的大事件, 估计就是俄乌战争吧. 对此no comment.</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>AI时代的学习指南</title>
    <url>/2023/02/25/AI%E6%97%B6%E4%BB%A3%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>日常刷知乎, 然后看到了这样一个问题: <a
href="https://www.zhihu.com/question/585554274/">沃顿商学院教授要求学生必须用
ChatGPT 写作业，应该如何正确看待 AI 带来的利弊？</a></p>
<p>之前我也看到一些态度截然相反的高校. 说实在话, 反对历史必然的行为,
无异于杯水车薪, 想想 Luddite movement 也不会真正让我们重回原始社会,
闭关锁国的历史也不必再度经历; 至于使用工具是否会反噬自身,
只要在不侵害他人的利益下, 我想这个自由最好让步于个人,
想想你是怎么注册上了ChatGPT的账号. 最后,
这句话送给AI时代下学习一切的你和我:</p>
<blockquote>
<p>拥抱变化要比拒绝变化简单的多.</p>
</blockquote>
<span id="more"></span>
<h2 id="前言">前言</h2>
<p>ChatGPT 对每个人来说不是同等的. 你要有使用能力. 所谓能力是提问的能力.
提问也是门学问, 但我们没有一个问问题的课程, 也没有那个分数.</p>
<p>本文介绍一些ChatGPT帮助辅助学习的Tips.</p>
<p>我也在摸索AI的使用方式, 有好的想法大家一起交流学习! :)</p>
<h2 id="把-ai-当成你的-ta">把 AI 当成你的 TA</h2>
<p>对于自学的同学来说, 能有一个随叫即到,
同时能有效答疑的助教是多么的幸福.</p>
<p>AI 不会嫌你愚蠢, 就算多么 trivial 它也能给你一个详尽的解答.
对于很多社恐的同学, 害怕 ask stupid questions
可能这会是一个很好的选择.</p>
<p>比方说, 题解的代码看不懂, 那么可以让 AI 帮助你生成注释,
或者解释代码的核心内容, 分析算法的时间复杂度等.</p>
<p>假设 model 给不出什么建设性的答复, 那么还是好好利用大学里的office
hour, 或者去找课程专门的 TA 解决问题吧.</p>
<h2 id="prompt-的艺术">Prompt 的艺术</h2>
<h3 id="prompt-公式">Prompt 公式</h3>
<p>prompt 其实有 formula. 如果想要得到一个比较高质量的回答,
可以抓住以下几点:</p>
<ul>
<li>task 明确, 精准的陈述</li>
<li>instructions 指令, model 遵循的要求</li>
<li>role: 让 model 角色扮演</li>
</ul>
<p>prompt = task + instructions + role</p>
<p>例如以下几种应用场景:</p>
<ul>
<li><em>作为</em>一名计算机科学与技术专业的大一<em>学生</em>,
<strong>生成</strong>一篇关于人工智能技术发展的课程论文,
<strong>内容包括</strong>[...] <strong>要求</strong>字数不少于 [...]
字.</li>
</ul>
<p>CET 作文的 Direction 就可以作为 prompt 的标准,
事实上给出的答案也是相当高质量的:</p>
<ul>
<li><strong>Suppose</strong> your university is selecting some students
to teach kids in remote rural areas during the coming vacation.
<strong>You</strong> are now to write <strong>an application
letter</strong> to the university to explain <em>why you want to take
part</em> and <em>what you can do for the kids</em>. You should write
<strong>at least 120 words but no more than 180 words</strong>.</li>
</ul>
<h3 id="为-prompt-提供例子">为 prompt 提供例子</h3>
<p>例如你可以自动生成一个函数的doctest.</p>
<ul>
<li>Generate a product comparison of this new smartphone <strong>with
one example</strong> (latest iPhone)"</li>
<li>生成一段关于DFS算法的解释（<strong>用一个例子</strong>说明：走迷宫）</li>
<li>[code] 解释这段代码, 并模拟一个样例.</li>
<li>[code] 为函数添加注释, 并提供 3 个 doctest.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">summation</span>(<span class="params">n: <span class="built_in">int</span>, term: <span class="built_in">callable</span></span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Compute the summation of the given term from 1 to n.</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        n: An integer representing the upper bound of the summation.</span></span><br><span class="line"><span class="string">        term: A callable that takes one argument and returns a float.</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        A float representing the summation of the given term from 1 to n.</span></span><br><span class="line"><span class="string">    Examples:</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; summation(5, lambda x: x**2)</span></span><br><span class="line"><span class="string">        55.0</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; summation(10, lambda x: x)</span></span><br><span class="line"><span class="string">        55.0</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; summation(3, lambda x: 2**x)</span></span><br><span class="line"><span class="string">        7.0</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    total, k = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> k &lt;= n:</span><br><span class="line">        total, k =  total + term(k), k + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> total</span><br></pre></td></tr></table></figure>
<h3 id="self-consistency-prompt">Self-Consistency Prompt</h3>
<p>添加一条 "Please ensure the following text is self-consistent",
对于检查文章前后内容一致性, 数据核查或者应付英语作业有奇效.</p>
<ul>
<li><strong>检查下面这段文字是前后一致的</strong>.
它先声明了城市人口有500万, 随后又说人口有700万: [text]</li>
<li>Complete the following sentence in a way that is consistent with the
context provided: [sentence]</li>
</ul>
<h3 id="lets-think-about-this-topic">Let’s think about this:
[topic]</h3>
<p>当你brainstorm不出来东西的时候可以考虑这么提问.
这个在应对传统课堂上的group discussion有奇效:</p>
<ul>
<li>Let's discuss the current state of artificial intelligence</li>
<li>Let's talk about the benefits and drawbacks of remote work</li>
</ul>
<p>AI 通常会给出一些很发散的答案. 可以顺着给出的几点进行延伸.</p>
<h3 id="数据分析信息整合">数据分析/信息整合</h3>
<ul>
<li><strong>Integrate</strong> the following information with the
existing knowledge about [specific topic]: [insert new information]</li>
<li><strong>Connect</strong> the following pieces of information in a
way that is relevant and logical: [insert information 1] [insert
information 2]</li>
<li>Please generate new and original information about customer behavior
from this <strong>dataset</strong></li>
</ul>
<h3 id="multiple-choice-prompts">Multiple Choice prompts</h3>
<p>让 AI 做选择题/填空题.</p>
<ul>
<li>Complete the following sentence by selecting one of the following
options: [insert sentence] [insert option 1] [insert option 2] [insert
option 3]</li>
</ul>
<h3 id="可解释型控制型-prompts">可解释型/控制型 Prompts</h3>
<p>给 model 一点灵活性(发挥). 打个比方你是作文命题人, 那么这里的 prompt
就更加开放, 回答最好能够出乎你意外的:</p>
<ul>
<li>以鲁迅的风格补写下面的句子: 人是会死的,</li>
</ul>
<p>人之所以为人，不仅有生之谓人，更有死之谓人。生，有生的欢喜与苦痛，死，亦有死的悲哀与解脱。</p>
<ul>
<li>以莎士比亚的口吻补写下面的句子: people shall die</li>
</ul>
<p>Mortal beings are we, frail creatures of dust, destined one day to
return to the earth from whence we came. The wheel of life turns, and
birth and death are its spokes.</p>
<p>控制型 prompt 要求 model 不能有多余的发挥,
要在已有的模板里完成任务.</p>
<ul>
<li>Generate a story <strong>based on the following template</strong>:
[insert template]</li>
</ul>
<h3 id="特殊-prompts">特殊 Prompts</h3>
<ul>
<li>"Use reinforcement learning to generate text that is consistent with
the following style [insert style]"</li>
<li>"Use curriculum learning to generate text that is consistent with
the following styles [insert styles] in the following order [insert
order]"</li>
<li>Perform sentiment analysis on the following customer reviews [insert
reviews] and classify them as positive, negative, or neutral.</li>
<li>Perform named entity recognition on the following news article
[insert article] and identify and classify people, organizations,
locations, and dates.</li>
<li>Perform text classification on the following customer reviews
[insert reviews] and classify them into different categories such as
electronics, clothing and furniture based on their content.</li>
</ul>
<h2 id="参考资料">参考资料</h2>
<p>[1]. Ibrahim John, The Art of Asking ChatGPT for High-Quality
Answers, A Complete Guide to Prompt Engineering Techniques, ISBN-13:
9781234567890</p>
<p>[2]. <a href="https://github.com/f/awesome-chatgpt-prompts">Awesome
ChatGPT Prompts</a>: 里面有许多有意思的 Prompts</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
        <tag>算法</tag>
        <tag>学习经验</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective-GDB!</title>
    <url>/2023/06/27/Effective-GDB/</url>
    <content><![CDATA[<p>真的有人会用 GDB 调试吗? 是旧朝遗老显摆, 还是没事找事? IDE 的
Debugger 不好用吗...</p>
<p>估计做完CSAPP的Lab就把GDB丢掉了, 或者在OS作业里耍耍, 又或者去打CTF了,
别的想不到 GDB 能干什么了, 吗?</p>
<p>可能你没有了解完全 GDB 可以做的一切. 你可能觉得 GDB 一点也不直观,
那为什么不试试 TUI; 你可能觉得反复键入指令太麻烦, 为什么不用 Python
写脚本...</p>
<p>不过话又说回来, 学习 GDB, 其实学习更主要, 学会调试的技巧,
总会在未来的某一天帮助到你.</p>
<span id="more"></span>
<h2 id="pwndbg">Pwndbg</h2>
<p>试试 GDB 的插件: <a
href="https://github.com/pwndbg/pwndbg">pwndbg</a></p>
<p>反汇编更加直观</p>
<h2 id="tui-mode">TUI mode</h2>
<p>怎么在 GDB 里面打断点? 要是不切屏, 你是获取不到代码信息的.
这时候你可能会想到 <code>list</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; <span class="built_in">list</span> main</span><br><span class="line"><span class="number">25</span>              &#125;</span><br><span class="line"><span class="number">26</span>          &#125; <span class="keyword">while</span> (!sorted);</span><br><span class="line"><span class="number">27</span>      &#125;</span><br><span class="line"><span class="number">28</span></span><br><span class="line"><span class="number">29</span>      <span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">30      &#123;</span><br><span class="line"><span class="number">31</span>          <span class="type">long</span> arr[<span class="number">32</span>];</span><br><span class="line"><span class="number">32</span>          <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="number">33</span>          srand(time(<span class="literal">NULL</span>));</span><br><span class="line"><span class="number">34</span>          <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; rand() % <span class="keyword">sizeof</span> arr; i++)</span><br></pre></td></tr></table></figure>
<p>但实际上 TUI 模式会给出一个更加人性化的用户界面.
<code>tui enable</code> 或者 <code>ctrl+x+a</code></p>
]]></content>
      <categories>
        <category>调试</category>
      </categories>
      <tags>
        <tag>GDB</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask从入门到入土</title>
    <url>/2023/04/25/Flask%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/</url>
    <content><![CDATA[<p>所谓人生苦短, 我用 Python. 经常戏称别的语言 Python 化, 不就是说明了
Python 作为现代语言的优越性. 当然, 不吹不贬地说, 其实关键在于项目需求,
所以用什么其实并不重要.</p>
<p>在 Python Web 开发这块, Django 和 Flask 平分天下, 而 Flask
框架的优点就在于它"轻量", "微", 简直就是 vscode 的翻版, 靠社区 extension
高效驱动.</p>
<p>当然, Flask 的使用不局限于 Web 应用的开发, 甚至说,
<strong>作为后端提供接口</strong>才是发挥它功用的最好做法.
这正是本文要完成的事情!</p>
<span id="more"></span>
<p>先把框架搭好. 其它的之后再说.</p>
<h2 id="后端-交互数据库">后端: 交互数据库</h2>
<p>前后端: 简单来说就是前端负责页面和交互,
后端负责提供数据以及实现与数据库的交互</p>
<p>后端干的事情一点也不酷</p>
<h2 id="工欲善其事-必先利其器">工欲善其事, 必先利其器</h2>
<h3 id="当然-你要安装-flask">当然, 你要安装 Flask</h3>
<p>配好 Python 开发环境. 我这里用的是WSL,
推荐大家尽可能的去熟悉Linux的开发环境.</p>
<p>白嫖<a
href="https://www.jetbrains.com/zh-cn/community/education/">学生优惠</a>
JetBrains 全家桶: 推荐 PyCharm, 专属 IDE, 你值得拥有. <del>说得好, 我用
VSCode</del></p>
<p>推荐在虚拟环境 venv 中开发.</p>
<p>建议在 <code>.bashrc</code> 里写 alias, 方便配置:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alias</span> pylab=<span class="string">&#x27;python3 -m venv .venv&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> activate=<span class="string">&#x27;source .venv/bin/activate&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="git-是你的基本功">Git 是你的基本功</h3>
<p>平时 Github 解决一切. 但也记得上手 Gitlab, 因为企业一般用的它.
<del>Gitee 是什么真不熟</del></p>
<p><a href="https://learngitbranching.js.org/?locale=zh_CN">学习 Git
分支</a></p>
<ul>
<li><code>git clone</code>: 克隆项目副本
<del>2023年了不要还在问为什么SSH connection refused</del></li>
<li><code>git checkout [-b] [feature-name]</code>: 切换分支
(<code>-b</code> 顺带创建分支)</li>
<li><code>git add .</code>: 把当前路径下的文件放到暂存区</li>
<li><code>git commit -m "Message"</code>: 提交暂存的更改
<del>不要问在IDE里怎么退出VIM :wq</del></li>
<li><code>git pull [--rebase] origin main</code>: 避免落后主分支,
顺带处理冲突</li>
<li><code>git push origin main</code>: 推送到主分支</li>
</ul>
<p>以上操作 IDE 其实都有GUI. 不需要你手敲.</p>
<h3 id="文档编写测试工具">文档编写/测试工具</h3>
<p>这一部分因人而异. 这里只给出我使用的工具:</p>
<p>Show Doc: 文档编写工具(项目组用的)</p>
<p>Postman: 接口测试工具 <del>其实命令行工具 <code>curl</code>
对于后端测试简单的接口来说就够了</del></p>
<h3 id="数据库系统">数据库系统</h3>
<p>我们使用关系型数据库系统: MySQL</p>
<p>实验室的老师贴心地为你在外网搭建了一个 MySQL 的数据连接.
<del>没有被MySQL安装折磨过的人生是不完整的</del></p>
<p>我的平台: WSL 安装参考这篇微软的<a
href="https://learn.microsoft.com/zh-cn/windows/wsl/tutorials/wsl-database">文章</a></p>
<p>解决第三方插件连接 <code>Access Denied</code>: 原因是 MySQL 把
Windows 下的程序视作远程 MYSQL 请求, 如果没有远程权限就会出错.</p>
<p>解决方案:</p>
<p><code>sudo mysql</code> 进入 <code>mysql</code>:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">USE mysql;</span><br><span class="line"><span class="comment">-- 创建一个账号, 不带密码</span></span><br><span class="line"><span class="comment">-- 注: IDENTIFIED BY password with GRANT 语句在 MySQL ver 5.7.6 不再适用</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;besthope&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;besthope&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>
<p>我使用的 VScode 插件: <a
href="https://marketplace.visualstudio.com/items?itemName=cweijan.vscode-mysql-client2">My
SQL</a>(个人认为最方便的一个) <del>或者Pycharm里连接MySQL</del></p>
<h2 id="先别急着-coding-你还有文档没写">先别急着 coding,
你还有文档没写</h2>
<h3 id="产品原型先解构">产品原型——先解构</h3>
<p>对产品原型的解构. 大致的实现需求. 好了, 这就是你的 TODO-LIST.</p>
<p>看起来比较复杂的项目, 分模块分时期去实现, 一个页面一个页面慢慢来.</p>
<h3 id="restful-api">RESTful API</h3>
<h4 id="简单介绍-rest-架构和-web-基础">简单介绍 REST 架构和 Web
基础</h4>
<p>RESTful 架构是个什么东西? <strong>Representational State
Transfer</strong>是 REST 的全称, "表现层状态发生转移".</p>
<p>REST <em>对信息的核心抽象</em>就是 <strong>资源</strong>(Resources),
通常以 <strong><a
href="https://en.wikipedia.org/wiki/Uniform_Resource_Identifier">URI</a>(统一资源定位符)</strong>
的形式表现. 这里的资源可以是文本, 图片, 或者<em>任何能被命名的信息</em>.
换句话说, 如果某一信息能被超链接导航到, 那它就符合资源的定义.
要访问某一"资源", 访问它的 URI 即可. URI
就是这个"资源"独一无二的<strong>标识符</strong>!</p>
<p>不过要注意的是, "资源"是对信息的<em>抽象</em>:
它代表的是<strong>一组</strong>相关的实体, 而非一个单独的实体.
具体的实体会发生变化, 但"资源"表示实体的结构和行为是不变的.</p>
<p>"资源"具体表现的形式,
就称作它的"<strong>表现层</strong>"(Representation).</p>
<p>例如, 文本可以用 txt 格式表现, 也可以用 JSON, xml 格式,
甚至二进制格式表现; 图片可以用 jpg 格式表现, 也可以用 png 格式表现.</p>
<p>访问一个网站, 就代表了<strong>客户端和服务器的一个互动过程</strong>.
在这个过程中, 必然涉及数据和状态的改变. 互联网通信协议<a
href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview#http_%E6%98%AF%E6%97%A0%E7%8A%B6%E6%80%81%EF%BC%8C%E6%9C%89%E4%BC%9A%E8%AF%9D%E7%9A%84">HTTP
协议</a>, 是一个<em>无状态协议</em>. 所有的状态都保存在服务器端,
如果客户端想要操作服务器, <strong>必须通过某种途径</strong>,
使得服务器端发生"<strong>状态转移</strong>"(State Transfer).
而这种状态转移是建立在表现层之上的. 所以, 你现在就能明白 REST
到底指的是个啥.</p>
<p>至于客户端用到的手段, 只能是<a
href="https://developer.mozilla.org/zh-CN/docs/web/http/methods">HTTP
的请求方法</a>. 下面这五种方法对应的 <strong>CRUD(增删改查)</strong>
操作:</p>
<table>
<thead>
<tr class="header">
<th>请求方法</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>GET</td>
<td>读取（Read）</td>
</tr>
<tr class="even">
<td>POST</td>
<td>新建（Create）</td>
</tr>
<tr class="odd">
<td>PUT</td>
<td>更新（Update）</td>
</tr>
<tr class="even">
<td>PATCH</td>
<td>更新（Update），通常是部分更新</td>
</tr>
<tr class="odd">
<td>DELETE</td>
<td>删除（Delete）</td>
</tr>
</tbody>
</table>
<p>根据HTTP协议, 请求方法(Request)由客户端提出,
由服务器决定是否执行或拒绝. 例如, 你发起了一个 <code>GET</code> 请求,
想获取 <code>/clients</code> 下的资源. 但这个文件获取需要有权限,
服务器就可以有如下的执行方式:</p>
<ul>
<li><code>404 Not found</code>: 这个状态码表示文件不存在.
当然是服务器装的.</li>
<li><code>403 Forbidden</code>: 这个文件拒绝访问.</li>
<li><code>405 Method Not Allowed</code>: 然后用 <code>Allow</code>
头告诉你可以用 <code>HEAD</code> 方法获取文件的元信息.</li>
</ul>
<h4 id="restful-的设计细节">RESTful 的设计细节</h4>
<p>主要内容:</p>
<ul>
<li>URI 设计:
<ul>
<li>任何请求都是<strong>动宾结构</strong>. 例如 <code>GET /images</code>
<del><code>/create-order</code></del></li>
<li>使用<strong>集合资源</strong>: 为了避免单数出现的歧义.
<code>images/2</code> <del><code>image/2</code></del></li>
<li>避免多级 URI: 尽量避免三级以上.
<code>/authors/12?categories=2</code>(字符串查询)
<del><code>/authors/12/categories/2</code></del></li>
<li>用<strong>字符串查询</strong>: Filtering, Sorting, and Pagination
<code>GET: /articles/?published=true&amp;page=2&amp;page_size=20</code></li>
</ul></li>
<li>状态码设计:
<ul>
<li>参考 <a
href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes">HTTP
Status Code</a>
<ul>
<li><code>1xx</code>: 相关信息</li>
<li><code>2xx:</code> 操作成功</li>
<li>...</li>
</ul></li>
</ul></li>
<li>服务器回应:
<ul>
<li>不要返回纯文本: HTTP 头的 Content-Type 属性要设为
<code>application/json</code>, 接受 JSON 结构化数据</li>
<li>考虑 <a
href="https://learn.microsoft.com/en-us/azure/architecture/best-practices/api-design#use-hateoas-to-enable-navigation-to-related-resources">HATEOAS</a>
将关联资源联系起来(提供超链接).</li>
</ul></li>
</ul>
<p>具体参考官方或者他人总结的教程.(见参考资料)</p>
<h3 id="和前端配合">和前端配合</h3>
<p>交流很重要.</p>
<p>确定哪些业务逻辑在放前端实现, 哪些业务逻辑放在后端实现.</p>
<p>看看 API 设计是否合理. 俩人得出共识就可以各干各的了.</p>
<h2 id="我还没学过数据库">我还没学过数据库</h2>
<p>推荐介绍MySQL基础的一本书: <a
href="https://pan.baidu.com/s/1Wgo5nhr42Jsrc36FW_FJxA?pwd=bvax">MySQL应知应会</a></p>
<p>入门了解基础语法即可. 要用到的时候check cheatsheet 就好.</p>
<p>学有余力了再去学习DBMS的底层原理. 理解底层实现, 就和学习算法优化一样.
实际上, 这才是计算机系学生应当去学习的东西! <del>CMU15-445
等你完成</del></p>
<h3 id="创表-你是个设计师-老弟">创表: 你是个设计师, 老弟</h3>
<p><code>CREATE TABLE</code>: 一切的开始</p>
<p>创建表至少要包含名字, 还有一个列.
<em>最好</em>为表设置主键(不会重复的列).</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建表: 一个简单的示例</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customers</span><br><span class="line">(</span><br><span class="line">    cust_id     <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    cust_name   <span class="type">char</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    cust_city   <span class="type">char</span>(<span class="number">50</span>) <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (cust_id)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure>
<p>不需要你手写 SQL 语句(当然你乐意也可以).
在插件里创建表之后就可以在GUI里设计表(<code>ALTER</code>)了.</p>
<p>can can need: <a href="https://open.yesapi.cn/list.html">开源的 MySQL
数据库表设计</a></p>
<p>可以参考 <a href="https://www.sqlstyle.guide/zh/">SQL Style
Guide</a>.</p>
<p>一些比较重要的原则:</p>
<ul>
<li><del>驼峰命名</del>不适合扫读.</li>
<li><del>面向对象编程的原则(OOP)</del>不该应用到 SQL
或数据库结构上.</li>
<li>保证名字<strong>独一无二</strong>且不是保留字.</li>
<li>尽量避免连接两个表的名字作为<strong>关系表</strong>的名字.
<code>cars_mechanics</code> 不如用
<code>services</code>(别名的时候要注意)</li>
<li>列名总是使用<strong>单数</strong>形式.</li>
<li>SQL关键字用<strong>大写</strong>,
数据库字段应当都是<strong>小写</strong>. 命名风格统一些.
<del><code>video_URL</code></del> <code>video_url</code></li>
<li>等...</li>
</ul>
<p>怎么实现<strong>关联表</strong>? 例如, 课程底下有视频,
怎么把视频表和课程表发生关联? 在设计表的时候就要考虑这一点.
实际上这并不复杂:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> course_title, video_title</span><br><span class="line"><span class="keyword">FROM</span> videos, courses</span><br><span class="line"><span class="keyword">WHERE</span> videos.course_id <span class="operator">=</span> courses.id</span><br></pre></td></tr></table></figure>
<p>也就是说, 我们在视频表里添加一个 <code>course_id</code> 的列,
作为<strong>外键</strong>, 它对应的是 <code>courses</code>
表下的<strong>主键</strong> <code>id</code>. 这样
<code>videos.course_id = courses.id</code>
作为查询语句就可以将两个表进行关联了.</p>
<h3 id="query-我只会增删改查">Query: 我只会增删改查</h3>
<p><a href="https://zhuanlan.zhihu.com/p/170046187">MySQL
的增删改查语句总结</a></p>
<p><del>学会 <code>insert</code>, <code>update</code>,
<code>delete</code>,</del> <code>select</code></p>
<p>前三个 GUI 解决一切. 又快又好. 真要写 SQL 语句, 其实学起来也很快.
剩下一个查询语句是你尤其需要关注的. 简单来说, 你要掌握这些:</p>
<ul>
<li>通配符 和 <code>REGEXG</code></li>
<li>聚集函数例如 <code>COUNT()</code></li>
<li>分组数据 <code>GROUP BY</code> 和 <code>HAVING</code></li>
<li>子查询(subquery)</li>
<li>多表联合查询 例如 <code>LEFT OUTER JOIN</code></li>
<li>...</li>
</ul>
<p>对于复杂的业务逻辑, 掌握上面的基本操作是一种必须. 同时,
追求性能则必然要求SQL语句的优化. 对于后端接口来说, <code>GET</code>
方法反而是最多的. 可以说, 真正要用SQL去写的需求其实只有查询(?)</p>
<p>怎么高效地从一个大型的数据库中提取数据, 这是一个很关键的问题!
学问很深, 待你慢慢研究.</p>
<h2 id="好了-现在开始进入-flask">好了, 现在开始进入 Flask</h2>
<p>网上有很多优秀的 Flask 项目值得学习: <a
href="https://github.com/humiaozuzu/awesome-flask">Awesome Flask</a></p>
<h3 id="迅速启动项目">迅速启动项目</h3>
<p>Flask 比其它框架(例如 Spring Boot)好的一点在于它很干净.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello_world</span>():  <span class="comment"># put application&#x27;s code here</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="配置文件">配置文件</h4>
<p><code>config.py</code> 配置环境</p>
<h4 id="工厂函数和蓝图">工厂函数和蓝图</h4>
<h3 id="啊这-真的要再写一遍-model-吗">啊这, 真的要再写一遍 Model 吗</h3>
<h4 id="sqlacodegen">sqlacodegen</h4>
<p>血的教训: <strong>配好你的环境</strong></p>
<h3 id="只返回json而已-很简单">只返回JSON而已, 很简单</h3>
<p><code>jsonify</code></p>
<h3 id="最喜欢的一集-写测试">最喜欢的一集: 写测试</h3>
<p><code>unitest</code></p>
<p>其实不用太在意写测试</p>
<h2 id="参考资料">参考资料</h2>
<ol type="1">
<li><a href="https://www.sqlstyle.guide/">SQL Style Guide</a></li>
<li>Flask Web 开发: 基于 Python 的 Web 应用开发实践: 第 2 版. ISBN
978-7-115-48945-6</li>
<li><a
href="https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm">Roy
Thomas Fielding 在他 2000 年的博士论文提出的 REST 原则</a></li>
<li><a href="https://restfulapi.net/">REST API 的官方教程</a></li>
<li>阮一峰, <a
href="http://ruanyifeng.com/blog/2018/10/restful-api-best-practices.html">RESTful
API 最佳实践</a>.</li>
<li><a
href="https://learn.microsoft.com/en-us/azure/architecture/best-practices/api-design">微软出品的API教程</a></li>
<li><a href="https://mathieu.fenniak.net/the-api-checklist/">Web API
Checklist</a></li>
<li><a
href="https://techglimpse.com/error-grant-identified-by-password/">Error
using GRANT with IDENTIFIED by password in MySQL</a>: 讨论了为什么 MySQL
5.7.6 之后为什么不再适用 GRANT IDENTIFIED BY.</li>
<li>Flask 官方<a href="https://flask.net.cn/">中文文档</a>.</li>
</ol>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Flask</tag>
        <tag>后端</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>x86-64 汇编介绍</title>
    <url>/2022/12/17/x86-64%E6%B1%87%E7%BC%96%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<blockquote>
<p>程序就是状态机。——jyy, on 2022 NJU OS Lecture 01</p>
</blockquote>
<p>这句话道出了程序的本质. 实际上, 如今的计算机本质上就是通用<a
href="https://plato.stanford.edu/entries/turing-machine/">图灵机</a>,
而我们研究汇编语言就是研究程序在机器层面上的运行.</p>
<p>程序的进行依赖于<code>rip</code>寄存器,
它储存的值是当前运行的指令地址.
程序的进行实际上就是一条指令一条指令的移动(你可以在<code>gdb</code>里随时监控<code>rip</code>).
这和图灵机读写控制的方式本质上是一致的!</p>
<span id="more"></span>
<blockquote>
<p>书中出示的汇编指令是<code>AT&amp;T</code>格式,
为<code>gcc</code>和<code>gdb</code>编译选项默认.
如果不熟悉某一种风格的话,
<code>set disassembly-flavor att</code>或者<code>intel</code>就可以切换成对应的反汇编风格啦.
大部分情况下两种格式是互通的. 唯一值得注意的是读取顺序,
两者<strong>源操作数</strong>和<strong>目的操作数</strong>的顺序是<strong>反的</strong>.
例如下面的语句表示栈指针减8:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">subq     $8,%rsp             # ATT flavor</span><br><span class="line">sub      rsp,8               # Intel flavor</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="访问值和访问地址">访问值和访问地址</h2>
<p><code>%rsp</code> 表示 <code>rsp</code> 寄存器储存的值,
通常来说栈指针保存的是一个地址. 对于更一般的寄存器,
例如<code>rax</code>寄存器, 是可以保存值的, 而且通常是返回值. 我们用
<span class="math inline">\(r_a\)</span> 表示寄存器<code>a</code>
存储的值. 内存本质上是一个很长的数组, <strong>内存引用</strong>表示
<span class="math inline">\(M[r_a]\)</span>, 例如
<code>(%rsp)</code>表示<code>*rsp</code>, 也就是<code>rsp</code>
寄存器储存地址上的值.</p>
<p><code>lea</code>和<code>mov</code>指令间的区别:
前者常用于简单的算术运算, 例如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* i in %rsi */</span><br><span class="line">leal    (%eax,%eax,2), %eax</span><br></pre></td></tr></table></figure>
<p>实际上进行的操作是:
源操作数计算为<code>S = M[%eax + 2 * %eax] = M[3 * %eax]</code>,
然后求出 <code>&amp;S</code>(<code>S</code>的有效地址),
然后将这个值复制给 <code>D</code>. 如果对<code>%rax</code>解引用,
例如<code>gdb</code>指令 <code>p *(int*) $rax</code>,
可以得到<code>3i</code>.</p>
<p><code>mov</code>指令可以干两件事: 把内存地址复制给另一个寄存器,
或者将一个值复制给寄存器.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = a[i];</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* x in %eax, a in %rdx, i in %rcx */</span><br><span class="line">movl    (%rdx,%rcx,4),%eax</span><br></pre></td></tr></table></figure>
<p>源操作数<code>S = M[a + 4*i]</code>,
<code>a</code>是<code>int</code>数组的起始地址.
将内存地址<code>S</code>上的值赋值给寄存器<code>rax</code>. 此时
<code>p $rax</code> 就是<code>a[i]</code>.</p>
<blockquote>
<p>数组和结构本质上就是人为规定的一段内存.
上面的例子显示了数组<code>int a[N]</code>可以用<code>*(a+i)</code>访问<code>a[i]</code>的本质.
对于下面的结构体:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> val;</span><br><span class="line">    node* next; </span><br><span class="line">&#125; node;</span><br></pre></td></tr></table></figure>
<p>假设<code>node</code>类型<code>node1</code>的指针为<code>ptr</code>,
那么<code>*ptr</code>是什么? <code>*(ptr+8)</code>代表什么?
<code>**(ptr+8)</code> 又是什么? <code>mov    0x8(%rdx),%rdx</code>
假设<code>rdx</code>是<code>ptr</code>, 这句指令代表什么?</p>
</blockquote>
<p>区别下面的指令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov    0x20(%rsp),%rbx </span><br><span class="line">lea    0x28(%rsp),%rax </span><br></pre></td></tr></table></figure>
<p>其中<code>rbx</code>的值是内存地址<code>$rsp+32</code>上储存的值,
<code>rax</code>现在是一个指针, 它的值是<code>$rsp+40</code>,
也就是一个内存地址.</p>
<h2 id="控制语句">控制语句</h2>
<p>跳转命令<code>jmp</code>等价于C中的<code>goto</code>.
<code>if</code>语句对应条件跳转指令.
循环控制语句都可以通过<code>if</code>和<code>goto</code>所模拟.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">absdiff_se</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y)</span> &#123;</span><br><span class="line">    <span class="type">long</span> res;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; y) &#123;</span><br><span class="line">        res = y - x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        res = x - y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* x in %rdi, y in %rsi */</span><br><span class="line">absdiff_se:</span><br><span class="line">   cmpq %rsi, %rdi              ; x - y              </span><br><span class="line">   jge .L6                      ; if &gt;= goto .L6</span><br><span class="line">   movq %rsi, %rax              ; res = y</span><br><span class="line">   subq %rdi, %rax              ; res -= x</span><br><span class="line">   ret                          ; return</span><br><span class="line">.L6:                         </span><br><span class="line">   movq %rdi, %rax              ; res = x</span><br><span class="line">   subq %rsi, %rax              ; res -= y</span><br><span class="line">   ret                          ; return</span><br></pre></td></tr></table></figure>
<p>判断条件(<code>if</code>括号内的语句)基于一组条件码寄存器,
通过<code>test</code>或<code>cmp</code>指令设置.</p>
<blockquote>
<p><strong>Q:</strong> 这里发生了什么? <strong>A:</strong>
<code>cmq</code>等同为不修改源操作数的<code>sub</code>指令(<code>a-b</code>),
<code>test</code>类似<code>and</code>指令(<code>a&amp;b</code>),
程序根据结果设置<code>OF</code>和<code>SF</code>以及其他的条件码寄存器(默认为0).</p>
<p>假设结果小于<code>0</code>,
那么<code>SF</code>会被设置为<code>1</code>;
还会判断是否发生数据类型的溢出, 假设溢出,
<code>OF</code>会被设置为<code>1</code>.</p>
<p><code>jge</code>会先对条件码进行位运算, 这里:<code>~(SF ^ OF)</code>,
如果结果为<code>1</code>, 那么跳转, 否则程序继续执行下去.</p>
</blockquote>
<p>在实际阅读汇编代码的过程中, 可以忽略这部分细节,
明白程序按照条件跳转即可.</p>
<p><code>-O1</code>级别以上的优化还会出现条件移动指令,
针对的是CPU条件预测的优化.
通常来说条件移动(<code>CMOV</code>类)指令可以用下面的C代码抽象:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// v = test_expr ? then_expr : else_expr;</span></span><br><span class="line">v = then-expr;</span><br><span class="line">ve = <span class="keyword">else</span>-expr;</span><br><span class="line">t = test-expr;</span><br><span class="line"><span class="keyword">if</span> (!t) v = ve;</span><br></pre></td></tr></table></figure>
<p>下面我们来讨论循环语句: <code>do while</code> 作为最不常用的循环,
模拟方式却是最简单的. 它的流程就和它本身一致.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">loop:</span><br><span class="line">    body</span><br><span class="line">    t = test_expr;</span><br><span class="line">    <span class="keyword">if</span>(t)</span><br><span class="line">        <span class="keyword">goto</span> loop;</span><br></pre></td></tr></table></figure>
<p>和<code>while</code>语句的区别是,
<code>while</code>语句在进入之前会进行一次条件判断.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">goto</span> test;</span><br><span class="line">loop:</span><br><span class="line">    body</span><br><span class="line">test:</span><br><span class="line">    t = test_expr;</span><br><span class="line">    <span class="keyword">if</span>(t)</span><br><span class="line">        <span class="keyword">goto</span> loop;</span><br></pre></td></tr></table></figure>
<p>至于最常用的<code>for</code>语句, 它有等价的<code>while</code>表述,
此处从略.</p>
<p>做完了要不要试试手? 要不要拆个<a
href="http://csapp.cs.cmu.edu/3e/bomb.tar">二进制炸弹</a>试试手:)
在Linux下输入下面的指令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://csapp.cs.cmu.edu/3e/bomb.tar</span><br><span class="line">tar xvf bomb.tar</span><br><span class="line"><span class="built_in">cd</span> bomb</span><br></pre></td></tr></table></figure>
<p>你需要做的是<code>gdb bomb</code>然后对汇编代码进行分析,
然后给出拆弹必要的字符串! 在<code>bomb.c</code>给出了程序流,
你至少知道该在哪里打断点. 而函数具体如何实现,
这就得看你汇编的能力了!</p>
<h2 id="函数调用的过程">函数调用的过程</h2>
<p>函数调用的过程满足<strong>栈</strong>的前进后出(First in, Last
out)原则.</p>
<blockquote>
<p><strong>Q:</strong> 怎么画函数栈帧的示意图? 是栈顶放最上面,
还是内存高位的一端放在最上面? <strong>A:</strong> 看个人习惯. <a
href="http://www.stackgrowsup.com/">UP?</a> 还是 <a
href="http://www.stackgrowsdown.com/">DOWN?</a>
只要你看别人的示意图不会被绕晕就可以. 通常来说,
栈朝着<strong>低地址</strong>增长, 从这个意义上来说,
往下画是更多人的选择.</p>
</blockquote>
<p>当过程P执行过程Q时, 会把返回地址,
也就是<code>call</code>指令的下一句(记作A)压入栈中(PC++),
Q返回时就会从A开始继续执行. 我们认为A是P栈帧的一部分. 对应的
<code>ret</code> 会将A从栈中弹出, 然后将<code>rip</code>设置为A.</p>
<p>调用函数的时候怎么传入参数? 一般来说, 如果还有空闲的寄存器,
程序在调用过程Q之前, 在过程P, 会先将参数移动到对应的寄存器,
例如第一个参数会移动到指定寄存器<code>rdi</code>上(<code>rsi</code>和<code>rdx</code>以此类推),
然后在过程Q中调用这几个寄存器, "共享"过程中,
实际上就实现了参数的传递.</p>
<p>在函数调用的一开始, 会为过程Q分配栈空间.
因为程序运行地址是往低址增长,
所以扩大栈需要减小栈指针<code>rsp</code>(指向栈顶元素).
将栈指针减小一个适当的值可以为没有初始值的数据在栈上分配空间.</p>
<p>通常来说<code>push</code>指令(将参数压入栈)就可以满足需要.
压栈实际上就是复制一个参数. 某些情况下,
还需要通过主动利用<code>sub</code>指令来分配栈帧. 在结束调用时,
对应的需要增加栈指针, 对应指令<code>pop</code>,
本质上是<code>add</code>一个特定的值.</p>
<blockquote>
<p><strong>Q1:</strong> <code>push</code>指令到底是什么意思?
<strong>A:</strong>
<code>push</code>指令实际上可以通过更简单的指令模拟出来:
<code>pushq %rbp</code> 等价于 <code>subq $8,%rsp</code>然后
<code>movq %rbp,(%rsp)</code>.
区别在于<code>pushq</code>指令占的字节数更少.
同理可以知道<code>pop</code>的含义.</p>
<p><strong>Q2:</strong> 还有什么时候需要用到栈帧? <strong>A:</strong>
上面提到了, 如果寄存器不足够放置所有的本地数据, 就需要用栈去储存. 此外,
对一个临时变量取地址<code>&amp;</code>, 局部变量是数组或结构,
同样需要分配栈帧. 栈帧的具体分配可以查阅书.</p>
</blockquote>
<p>理解了函数调用的过程, 实际上你就可以实现将任何递归程序<a
href="https://zhuanlan.zhihu.com/p/467871987">改写</a>成非递归! 比方说,
写一个非递归版的汉诺塔程序.</p>
<p>此外, 关于栈帧有一个有趣的话题: 内存越界和缓冲区溢出.
主要是这样一个库函数<code>gets()</code>,
它可以无视字符串长度向字符数组写入, 引起内存越界, 小则修改栈上的值,
大则修改返回地址, 使得函数调用到奇怪的地方!</p>
<p>有关这部分, CSAPP提供了<a
href="http://csapp.cs.cmu.edu/3e/target1.tar">attack lab</a>,
让你模拟为一名hacker去攻击程序! 很有意思.</p>
<p>在这里, 我们给出缓冲区溢出的一个例子:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">win</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(arg == <span class="number">0x15213</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;You win 1 cookie! Great start!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(arg == <span class="number">0x18213</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;You win 2 cookies! Woohoo!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(arg == <span class="number">0x18613</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;You win 3 cookies! That&#x27;s right!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">solve</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> before = <span class="number">0xb4</span>;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> after = <span class="number">0xaf</span>;</span><br><span class="line"></span><br><span class="line">    gets(buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(before == <span class="number">0x3331323531</span>)</span><br><span class="line">        win(<span class="number">0x15213</span>);</span><br><span class="line">    <span class="keyword">if</span>(after == <span class="number">0x3331323831</span>)</span><br><span class="line">        win(<span class="number">0x18213</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改<code>after</code>的值, 这个其实不难做到.
按照临时变量在栈上的顺序, 首先<code>before</code>先压栈,
然后是<code>buf</code>, 最后是<code>after</code>.
又因为栈是朝内存低的方向生长的,
知<code>buf</code>超出的部分会影响到<code>before</code>的值.
具体在内存中是怎么分配的呢? 可以尝试反汇编调试一下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Dump of assembler code for function solve:</span><br><span class="line">   0x00000000004006b5 &lt;+0&gt;:     sub    $0x38,%rsp</span><br><span class="line">   0x00000000004006b9 &lt;+4&gt;:     movq   $0xb4,0x28(%rsp)</span><br><span class="line">   0x00000000004006c2 &lt;+13&gt;:    movq   $0xaf,0x8(%rsp)</span><br><span class="line">   0x00000000004006cb &lt;+22&gt;:    lea    0x10(%rsp),%rdi</span><br><span class="line">   0x00000000004006d0 &lt;+27&gt;:    call   0x40073f &lt;Gets&gt;</span><br><span class="line">   0x00000000004006d5 &lt;+32&gt;:    mov    0x28(%rsp),%rdx</span><br><span class="line">   0x00000000004006da &lt;+37&gt;:    movabs $0x3331323531,%rax</span><br></pre></td></tr></table></figure>
<p><code>buf</code> 在 <code>rsp+0x10</code> 的位置,
<code>buf[16]</code> 在 <code>0x20</code>, 而 <code>0xb4</code> 在
<code>rsp+0x28</code> 的位置,
也就是要覆盖<code>before</code>的值还必须填充8个字节. 于是,
可以构造攻击字符串<code>00001111222233334444555515213</code>,
就可以获得1个cookie啦!</p>
<p>想一想, 你可以怎么做, 来完成剩余的关卡? 例如,
修改<code>after</code>的值, 或者直接修改传递的<code>arg</code>参数值?
而这一切都可以通过缓冲区的溢出来实现! 如果你感兴趣,
可以下载CMU官网提供的rec:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://www.cs.cmu.edu/~213/activities/rec5.tar</span><br><span class="line">tar xvf rec5.tar</span><br><span class="line"><span class="built_in">cd</span> rec5</span><br></pre></td></tr></table></figure>
<p>补充一些细节: 传递参数存在保护机制.
方才我们提到参数传入靠的是<code>push</code>和<code>pop</code>,
实际是参数的复制. 在此之外, 我们还有一组特殊的寄存器: <code>rbx</code>,
<code>rbp</code>和
<code>r12 ~ r15</code>寄存器被称为<strong>被调用者保存</strong>寄存器.
在P调用Q的过程中, Q必须保护这些寄存器的值,
使得当Q返回P的时候与调用Q时是一样的.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">P</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> u = Q(y);</span><br><span class="line">    <span class="type">long</span> v = Q(x);</span><br><span class="line">    <span class="keyword">return</span> u + v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第四行<code>sub $8,%rsp</code>是为了内存对齐.
第五行把<code>x</code>储存到了<code>rbp</code>寄存器上,
这样就不需要担心<code>rdi</code>寄存器后来被修改导致<code>x</code>丢失.
同样<code>rbx</code>储存了<code>Q(y)</code>的值,
这样就不用担心<code>rax</code>寄存器修改导致<code>Q(y)</code>的丢失.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P:</span><br><span class="line">   pushq %rbp                Save %rbp</span><br><span class="line">   pushq %rbx                Save %rbx</span><br><span class="line">   subq $8, %rsp             Align stack frame</span><br><span class="line">   movq %rdi, %rbp           Save x</span><br><span class="line">   movq %rsi, %rdi           Move y to first argument</span><br><span class="line">   call Q                    Call Q(y)</span><br><span class="line">   movq %rax, %rbx           Save result</span><br><span class="line">   movq %rbp, %rdi           Move x to first argument</span><br><span class="line">   call Q                    Call Q(x)</span><br><span class="line">   addq %rbx, %rax           Add saved Q(y) to Q(x)</span><br><span class="line">   addq $8, %rsp             Deallocate last part of stack</span><br><span class="line">   popq %rbx                 Restore %rbx</span><br><span class="line">   popq %rbp                 Restore %rbp</span><br><span class="line">   ret</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>汇编</tag>
        <tag>CSAPP</tag>
        <tag>计算机系统</tag>
      </tags>
  </entry>
  <entry>
    <title>前缀函数和KMP算法</title>
    <url>/2022/12/21/KMP%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>做期末大作业里面有个字符串匹配的问题, 用暴力算法做完觉得不够爽,
于是自找的麻烦.</p>
<p>想用最简明的方式去解释这个较为抽象的算法! 事实上明白了一个道理:
缺乏数学的算法都是玄学, 只有数学证明了才能让人心服口服......</p>
<p>就好像物理规律, 如果数学上证明了成立, 你会感到无比安心.
模拟样例终归比不了证明有说服力.</p>
<span id="more"></span>
<p>问题: 在一个<strong>文本串</strong>(<code>s</code>,
也称主串)中找到一个<strong>匹配串</strong>(<code>p</code>),
返回它在文本串中的下标. 如果无法匹配返回<code>-1</code>.</p>
<h2 id="前言-暴力解决问题">前言: 暴力解决问题</h2>
<p>思路很明了: 用指针<code>i</code>遍历<code>s</code>,
<code>j</code>遍历<code>p</code>. 具体的遍历过程</p>
<ul>
<li><strong>指针移动</strong> <code>s[i]</code>是否匹配<code>p[j]</code>
<ol type="1">
<li>如果匹配, 则后移<code>j</code>指针,
比较<code>p</code>后继字符是否和<code>s</code>中的一致.</li>
<li>如果不匹配, 那么后移<code>i</code>指针,
并将<code>j</code>指针重新设置为<code>0</code>.</li>
</ol></li>
<li><strong>终止条件</strong>
当<code>j</code>指针指向<code>p</code>最后一个字符, 说明匹配完成.
这时候就可以输出<code>i - j</code>的值, 作为匹配串在文本串中的索引.</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bf</span><span class="params">(<span class="type">char</span> *s, <span class="type">char</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (s[i] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == p[j])</span><br><span class="line">            i++, j++;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            i -= j; i++; j = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p[j] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> i - j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度分析: 考虑最坏情况, $O(|P| (|S|+|P|-1)) = O(|P||S|) $,
也就是 <span class="math inline">\(O(nm)\)</span>.</p>
<h2 id="预备知识">预备知识</h2>
<h3 id="字符串基础">字符串基础</h3>
<p><strong>子串</strong>: 串中任意个连续的字符组成的子序列.</p>
<p><strong>字符串前缀</strong>:
一个字符串的<strong>全部头部组合</strong>,
但<strong>不包括自身</strong>.</p>
<blockquote>
<p>严格来说, KMP讨论的是字符串的真前缀.</p>
</blockquote>
<p>例子: <code>abcab</code> 的前缀(集合)为
<code>&#123;a, ab, abc, abca&#125;</code></p>
<p>同样的有<strong>字符串后缀</strong>, 按上面的例子, 后缀(集合)就应该为
<code>&#123;b, ab, cab, bcab&#125;</code>.</p>
<h3 id="前缀函数">前缀函数</h3>
<p>给定长度<code>n</code>的字符串<code>s</code>,
其<strong>前缀函数</strong>定义为长度为<code>n</code>的数组<span
class="math inline">\(\pi\)</span>, 其中<span
class="math inline">\(\pi[i]\)</span>是子串<code>s[0...i]</code><strong>最长的相等前缀和后缀长度</strong>.
具体来说:</p>
<ul>
<li><span class="math inline">\(\pi[0]\)</span> = 0.
因为此时无前缀及后缀.(对于部分实现可能会规定其为<code>-1</code>)</li>
<li>如果子串有一对相同的前后缀, 那么 <span
class="math inline">\(\pi[i]\)</span> 就等于这个前缀(或后缀)的长度.
如果存在多对, 那么就是它们中的最大值.</li>
</ul>
<p>例如, 对于<code>abcab</code>, <code>pi[0] = 0</code>,
<code>pi[1] = 0</code>, <code>pi[2] = 0</code>, <code>pi[3] = 1</code>,
<code>pi[4] = 2</code>. 那么它的前缀函数就为
<code>&#123;0, 0, 0, 1, 2&#125;</code>.</p>
<p>优雅求得一个字符串的前缀函数是件并不容易的事情.
我们会在下面接着讨论.</p>
<h2 id="kmp-算法就是状态机">KMP 算法就是状态机</h2>
<p>所谓算法, 就是把暴力穷举优化成聪明的枚举. 这句话对KMP算法同样适用:
利用<strong>匹配失败后的信息</strong>,
<strong>减少</strong>模式串和文本串的<strong>匹配次数</strong>.</p>
<p>在暴力算法中, 每当<code>s[i] != p[j]</code>, <code>j</code>
被重新设置为<code>0</code>, 而<code>i</code>回溯到匹配前的位置,
同时只自增<code>1</code>. 我们的目的是:
减少算法复杂度<code>O(nm)</code>中的<code>n</code>,
也即减少不必要的匹配次数, 换句话说, 要么动态增加<code>i</code>的步长;
要么不回溯<code>i</code>, 让<code>i</code>一直自增下去.</p>
<p>为了实现这一点, 我们需要利用一切匹配失败前获取的信息.
而在匹配失败之前, 有字符是匹配的:
<strong>文本串的一部分等于模式串的一段前缀</strong>.</p>
<p>如果我们能跳过不可能成功匹配的字段, 就可以有效减少匹配的次数.</p>
<figure>
<img src="/images/pic.png" alt="skip" />
<figcaption aria-hidden="true">skip</figcaption>
</figure>
<p>如图所示, 如果能够跳过中间标蓝的不必要的匹配(第一个字符都失败了,
明显不可能匹配成功), 就可以大幅减少我们的匹配次数.</p>
<p>我们要做的实际上就一件事:
<strong>让文本串的一段对上匹配串的一段前缀</strong>,
而且跳过越多不必要的匹配越好. 跳过的这个长度在我们匹配失败前就应确定,
根据已有的信息, 这个<strong>最优长度</strong>是
<strong><code>s</code>子串的后缀和<code>p</code>子串的前缀交集中最长元素的长度</strong>.
在上例中, 就是 <span class="math inline">\(\text{\{a,ab,abc,abca\}}\cap
\text{\{b, ab, cab, bcab\}} = \text{\{ab\}}\)</span> 的长度,
也就是<code>2</code>, 表示的含义也即:
让<code>p</code>的<code>ab</code>对上<code>s</code>的<code>ab</code>.</p>
<p>而且, 由于在匹配失败之前, 匹配都是成功的, 我们可以得到另外一个信息是
<strong><code>s</code>串的部分子串等同于<code>p</code>串的部分子串</strong>,
那么,
此时<code>s</code>子串的后缀和<code>p</code>子串的前缀交集中最长元素的长度,
就等同于 <strong><code>p</code>子串的最大前后缀长度</strong>,
也就是<code>p</code>串的<strong>前缀函数</strong>.</p>
<p>这是巨大的一步!
因为我们可以在<code>s</code>和<code>p</code>进行匹配之前就计算出<code>p</code>每一次向右移动的长度.</p>
<p>在KMP算法中, 我们记这个数组为<code>next</code>数组.</p>
<p>在下面的算法中,
我们依然用<code>i</code>表示指向<code>s</code>的字符下标,
<code>j</code>表示指向<code>p</code>的字符下标.</p>
<p>相较于暴力算法, 我们优化的点主要在于<code>j != 0</code>的情况:
让<code>i</code>不回溯, 只让<code>j</code>回溯. <code>i</code>不动,
让<code>p[next[j - 1]]</code>和<code>s</code>中方才匹配失败的字符<code>s[i]</code>进行比较.
假使这一步又失败了, 我们还是回溯<code>j</code>,
找<code>s[i] == p[j]</code>, 直到<code>j</code>为<code>0</code>,
也就意味着<code>s</code>和<code>p</code>没有交集了. 这时,
移动<code>i</code>, 进行新一轮的匹配. 注意, 这是KMP最差的情况:
<code>i++</code>, <code>j=0</code>, 这和暴力算法实际上没有多少区别.
但通过<code>j = next[j - 1]</code>的状态转移,
我们减少了大量的匹配次数!</p>
<p>一切操作,
只是简单地改变<code>i</code>和<code>j</code>状态——KMP算法本质上就是一个<strong>优化了的状态机</strong>!</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> next[N];</span><br><span class="line"><span class="type">int</span> <span class="title function_">kmp</span><span class="params">(<span class="type">char</span> *s, <span class="type">char</span> *p)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(s[i] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == p[j])</span><br><span class="line">            i++, j++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j)</span><br><span class="line">            j = next[j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span>(p[j] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> i - j;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多例查询你可以这么写:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(p[j] == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i - j &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    j = next[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你是用 C++ 写的代码, 建议将 <code>next</code> 数组命名为
<code>ne</code>, 否则容易和 STL 库的命名冲突.</p>
<p>至于<code>next</code>数组, 我们其实也可以暴力解决:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">getNext</span><span class="params">(<span class="type">char</span> *p)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">strlen</span>(p);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="type">int</span> match = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; j; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p[k] != p[i - j + <span class="number">1</span> + k]) &#123;</span><br><span class="line">                    match = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (match) &#123;</span><br><span class="line">                next[i] = j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>暴力算法的时间复杂度是<code>O(n^3)</code>, 数据量大必爆,
而且非常丑陋, 这对KMP这样优雅的算法简直就是致命的. 下面,
我们就来看看怎么才能优雅地计算<code>next</code>数组.</p>
<h2 id="优雅计算前缀函数">优雅计算前缀函数</h2>
<p>就像动态规划<code>dp</code>找到状态转移方程,
找到前缀函数的递推公式将是我们解题的关键.</p>
<figure>
<img src="/images/pic2.png" alt="相邻的前缀函数值最大增加 1" />
<figcaption aria-hidden="true">相邻的前缀函数值最大增加 1</figcaption>
</figure>
<p>仔细观察前缀函数, 第一个重要性质就是:
<strong>相邻的前缀函数值最大增加 <code>1</code></strong>.</p>
<p>不要忘记我们对前缀函数的定义是:
<strong>最长的相等前缀和后缀长度</strong>.</p>
<p>那么, 这个性质可以这么思考: 要取一个尽可能大的<span
class="math inline">\(\pi[i]\)</span>, 必然要求新增的 <code>s[i]</code>
能和对应的字符匹配, 也即 <span class="math inline">\(s[i] =
s[\pi[i-1]]\)</span>, 此时 <span class="math inline">\(\pi[i] = \pi[i-1]
+ 1\)</span>. 例如: 上图中, <code>i = 5</code>的位置(<code>c</code>),
比较的是 <code>i = pi[4] = 2</code> 的位置(<code>c</code>),
即相等前缀的下一字符, 因为相等, 所以<code>pi[5] = pi[4] + 1</code>;
<code>i = 11</code>(c) 比较的是 <code>i = pi[10] = 5</code>(c),
相等所以加一.</p>
<figure>
<img src="/images/pic3.png" alt="假如不匹配怎么办?" />
<figcaption aria-hidden="true">假如不匹配怎么办?</figcaption>
</figure>
<p>下一步是考虑 <span class="math inline">\(s[i] \neq
s[\pi[i-1]]\)</span> 的情况. 如图所示, 我们期望,
当<code>s[i]</code>失配时, 对于子串<code>s[0...i-1]</code>,
依然能找到仅次于 <span class="math inline">\(\pi[i-1]\)</span>
的第二长度 <code>j</code>, 使得在位置 <code>i-1</code>
的前缀性质依然保持, 也即 <code>s[0...j-1] = s[i-j...i-1]</code>.</p>
<p>数学看上去有些抽象, 举个例子: 如图, <code>i = 11</code> 时失配了,
对于子串 <code>abcabdabcab</code>, 依然能找到比 <span
class="math inline">\(\pi[10] = 5\)</span> 小的<strong>第二长度</strong>
<code>j</code> (在这里是 <code>2</code>), 使得 <code>i = 10</code>
的前缀性质依然保持, 这里找到的公共前后缀为<code>ab</code>.</p>
<p>如果我们找到了这样的<code>j</code>,
那么就只需要比较<code>s[i]</code>和<code>s[j]</code>.</p>
<ul>
<li>如果它们相等, 就有 <span class="math inline">\(\pi[i] = j +
1\)</span>. 在上面的例子中, 因为 <code>s[11] = s[2]</code>, 因此 <span
class="math inline">\(\pi[11] = 3\)</span>.
此时最大前后缀为<code>abc</code>.</li>
<li>如果它们不相等, 假设本例中的 <code>s[11] = 'a'</code>,
根据上面的讨论, 我们需要再找到一个仅次于 <span
class="math inline">\(j\)</span> 的 <span
class="math inline">\(j^{(2)}\)</span>, 使得前缀性质得以保持. 此时 <span
class="math inline">\(j^{(2)}\)</span> 只能为<code>0</code>了,
因为<code>s[i] = s[0]</code>, 所以<code>pi[11] = 1</code>.</li>
</ul>
<p>以此类推, 按照数学归纳, 直到 <span class="math inline">\(j^{(n)} =
0\)</span> 时我们结束寻找第二长度, 并且我们可以知道, 如果 <span
class="math inline">\(s[i]\neq s[0]\)</span>, 那么 <span
class="math inline">\(\pi[i] = 0\)</span>,
正如本例中的<code>i = 5</code>(<code>d</code>不匹配任何一个字符).</p>
<p>前缀函数另一个重要的性质,
也就是<code>j</code>实际上<strong>等价于子串</strong><span
class="math inline">\(s[0...\pi[i - 1] -
1]\)</span>的<strong>前缀函数值</strong>, 也即</p>
<p><span class="math display">\[j = \pi[\pi[i - 1] - 1] \]</span></p>
<p>上例中, 也即<code>i = 5</code>处<code>pi</code>的值,
也就是我们已经求得的 <code>2</code>! 同理, <span
class="math inline">\(j^{(2)} = \pi[j-1]\)</span>, 那么归纳可得 <span
class="math inline">\(j^{(n)} = \pi[j^{(n-1)}-1]\)</span>.</p>
<p>于是我们就有了最终的代码:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> next[N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">getNext</span><span class="params">(<span class="type">char</span> *p)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p[i] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p[i] == p[j]) &#123;</span><br><span class="line">            next[i] = next[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            i++, j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(j)</span><br><span class="line">            j = next[j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            next[i] = <span class="number">0</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调整下代码, 写成双指针的形式, 就可以得到更符合算法竞赛的算法啦!
(见下)</p>
<p>各位可以揣读一下这段代码的精妙, 甚至框架和KMP搜索惊人的一致!
(都是改变状态实现)</p>
<h2 id="例题">例题</h2>
<p><a href="https://www.acwing.com/problem/content/143/">AcWing 141.
周期</a> <code>next</code> 数组的另一种解释.</p>
<p>首先要理解什么是字符串的周期. 给出一个样例: <code>aa</code>, 由 2 个
<code>a</code> 的循环节构成, 它的周期为 1. <code>aab</code>
就不存在这样的循环节, 也即不存在周期. <code>aabaab</code> 由 2 个
<code>aab</code> 的循环节构成, 它的周期为 3.</p>
<p>严格些的定义: 对字符串 <span class="math inline">\(s\)</span> 和
<span class="math inline">\(0 &lt; p \leqslant |s|\)</span>, 若 <span
class="math inline">\(s[i] = s[i+p]\)</span> 对所有 <span
class="math inline">\(i\in[0,|s|-p-1]\)</span> 成立, 那么 <span
class="math inline">\(p\)</span> 是 <span
class="math inline">\(s\)</span> 的<strong>周期</strong>.</p>
<p>我们再给出另一个概念的定义: 对字符串 <span
class="math inline">\(s\)</span> 和 <span class="math inline">\(0 &lt; r
\leqslant |s|\)</span>, 若 <span class="math inline">\(s\)</span> 和
<span class="math inline">\(r\)</span> 的前缀和长度为 <span
class="math inline">\(r\)</span> 的后缀相等, 就称 <span
class="math inline">\(s\)</span> 长度为 <span
class="math inline">\(r\)</span> 的前缀是 <span
class="math inline">\(s\)</span> 串的<strong>border</strong>.</p>
<p>推论: <span class="math inline">\(s\)</span> 有长度为 <span
class="math inline">\(r\)</span> 的border可以推出 <span
class="math inline">\(|s| - r\)</span> 为 <span
class="math inline">\(s\)</span> 的周期.</p>
<p>例如 <code>bbabbab</code> 满足一个 Border <span
class="math inline">\(r=4\)</span> <code>"bbab"</code> 且 <span
class="math inline">\(p=3\)</span>, 满足 <span
class="math inline">\(r+p=|S|=7\)</span>.</p>
<p>推论告诉我们求一个字符串的周期就等同于求Border.</p>
<p>按照前缀函数的定义, 即可得到 <span class="math inline">\(s\)</span>
所有的border长度, 即 <span
class="math inline">\(\pi[n-1],\pi[\pi[n-1]-1],\dots\)</span>, 且 <span
class="math inline">\(\pi[n-1]\)</span> 是非平凡的最大Border.
于是我们可以在 <span class="math inline">\(O(n)\)</span>
的时间内计算出所有 <span class="math inline">\(s\)</span> 的周期, 且知
<span class="math inline">\(n - \pi[n-1]\)</span> 是 <span
class="math inline">\(s\)</span> 的最小正周期.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> ne[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) == <span class="number">1</span> &amp;&amp; n != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = ne[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j])</span><br><span class="line">            &#123;</span><br><span class="line">                j = ne[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j])</span><br><span class="line">                j++;</span><br><span class="line">            ne[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Test case #%d\n&quot;</span>, ++m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> T = i - ne[i - <span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> k = i / T;</span><br><span class="line">            <span class="keyword">if</span> (i % T == <span class="number">0</span> &amp;&amp; k &gt; <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, i, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其它应用: 统计每个前缀的出现次数, 一个字符串中本质不同子串的数目,
字符串压缩, 根据前缀函数构建一个自动机</p>
<h2 id="模板">模板</h2>
<p>正文部分给出的是C语言实现版本.
下面给出主流算法竞赛中使用的C++实现方式.</p>
<p>来源: <a href="https://oi-wiki.org/string/kmp/">OI-wiki
前缀函数和KMP算法</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">prefix_function</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = (<span class="type">int</span>)s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pi</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = pi[i - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 不匹配且 j 不为 0</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j])</span><br><span class="line">            j = pi[j - <span class="number">1</span>];  <span class="comment">// 满足前缀性质的第二长度</span></span><br><span class="line">        <span class="comment">// 匹配</span></span><br><span class="line">        <span class="keyword">if</span> (s[i] == s[j])</span><br><span class="line">            j++;</span><br><span class="line">        pi[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来源: <a
href="https://www.acwing.com/activity/content/problem/content/869/">AcWing
831.KMP字符串</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> p[N], s[N];</span><br><span class="line"><span class="type">int</span> ne[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; p &gt;&gt; m &gt;&gt; s;</span><br><span class="line">    ne[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">-1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; p[i] != p[j + <span class="number">1</span>])</span><br><span class="line">            j = ne[j];</span><br><span class="line">        <span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>])</span><br><span class="line">            j++;</span><br><span class="line">        ne[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">-1</span>; i &lt; m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; s[i] != p[j + <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            j = ne[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            j ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == n - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; i - j &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            j = ne[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<p>[1]. <a href="https://oi-wiki.org/string/kmp/">OI-wiki
前缀函数和KMP算法</a></p>
<p>[2]. 邓俊辉. <a
href="https://dsa.cs.tsinghua.edu.cn/~deng/ds/dsacpp/">数据结构(C++语言版)</a>.
北京: 清华大学出版社, 2013.09第三版. ISBN: 7-302-33064-6. P331.
KMP算法</p>
<p>[3]. 木子喵neko. <a
href="https://www.bilibili.com/video/BV1234y1y7pm/">【喵的算法课】KMP算法【7期】</a></p>
<p>[4]. calabash_boy (注: NJU final爷). <a
href="https://ac.nowcoder.com/acm/contest/28737">牛客竞赛字符串专题班Trie（字典树多模式匹配）</a>.
2022年1月15日.</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>字符串</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL cheetsheet</title>
    <url>/2023/05/16/SQL-cheetsheet/</url>
    <content><![CDATA[<p>初步接触 DBMS: 不就是存个数据吗, 有什么难的. 增删改查,
我上我也行.</p>
<p>进一步了解 DBMS: 好像有点东西<del>(全然余裕)</del>.</p>
<p>看完一本 DBMS 的书后: B+树索引结构, 关系模型和外键约束,
连接优化、投影消除...</p>
<p>记这么多DML作甚? <del>实际还不是用的GUI.</del>
涉及复杂业务逻辑的时候, 写SQL语句照样烧脑. 设计表的时候还不是照样头疼.
不考虑优化, 结果性能巨差有谁来负责. 没个 Cheatsheet
还真没一下想不出来.</p>
<span id="more"></span>
<h2 id="检索数据">检索数据</h2>
<h3 id="基础操作-select">基础操作: SELECT</h3>
<ul>
<li>所有的 SQL 语句用 <code>;</code> 结尾.</li>
<li>SQL 关键字大写, 变量名小写是好习惯.</li>
<li>结果是未排序的.</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查找单列</span></span><br><span class="line"><span class="keyword">SELECT</span> course_id <span class="keyword">FROM</span> courses;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查找多列</span></span><br><span class="line"><span class="keyword">SELECT</span> course_id, course_name <span class="keyword">FROM</span> courses;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 检索所有列</span></span><br><span class="line"><span class="comment">-- * 是个通配符. 检索不必要的列通常会降低性能.</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> courses;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 检索不同的行</span></span><br><span class="line"><span class="comment">-- 不能部分使用 DISTINCT</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> course_id <span class="keyword">FROM</span> courses;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 限制结果</span></span><br><span class="line"><span class="comment">-- 返回结果不多于 5 行</span></span><br><span class="line"><span class="keyword">SELECT</span> course_id <span class="keyword">FROM</span> courses</span><br><span class="line">LIMIT <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 完全限定名称</span></span><br><span class="line"><span class="comment">-- 为了避免命名空间冲突</span></span><br><span class="line"><span class="keyword">SELECT</span> courses.course_id <span class="keyword">FROM</span> courses;</span><br></pre></td></tr></table></figure>
<h3 id="排序检索-order-by">排序检索: ORDER BY</h3>
<p>SQL 语句由子句(clause)构成, 有些子句是必须的, 有些则不是.</p>
<p><code>ORDER BY</code> 字句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 按 course_name 排序</span></span><br><span class="line"><span class="keyword">SELECT</span> course_name <span class="keyword">FROM</span> courses</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> course_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 按多列排序</span></span><br><span class="line"><span class="keyword">SELECT</span> course_id, course_name <span class="keyword">FROM</span> courses</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> course_id, course_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 按指定排序方向, 关键字: DESC(ascending)</span></span><br><span class="line"><span class="comment">-- 默认是 ASC(ascending)</span></span><br><span class="line"><span class="comment">-- 本例按 id 高排序</span></span><br><span class="line"><span class="keyword">SELECT</span> course_id, course_name <span class="keyword">FROM</span> courses</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> course_id <span class="keyword">DESC</span>, course_name;</span><br></pre></td></tr></table></figure>
<h3 id="数据过滤-where">数据过滤: WHERE</h3>
<ul>
<li>通常数据过滤在服务器而不是在客户端解决. 想想为什么?</li>
<li><code>ORDER BY</code> 得放在 <code>WHERE</code> 后面.</li>
<li>使用圆括号分组操作符是个好习惯.</li>
<li>MySQL 里的 <code>NOT</code> 和其他 SQL 语句略有不同.
<code>NOT IN</code>, <code>NOT BETWEEN</code> 也支持.</li>
</ul>
<table>
<thead>
<tr class="header">
<th>操作符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>=</code></td>
<td>等于</td>
</tr>
<tr class="even">
<td><code>&lt;&gt;</code></td>
<td>不等于<a href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a></td>
</tr>
<tr class="odd">
<td><code>!=</code></td>
<td>不等于</td>
</tr>
<tr class="even">
<td><code>&lt;</code></td>
<td>小于</td>
</tr>
<tr class="odd">
<td><code>&lt;=</code></td>
<td>小于等于</td>
</tr>
<tr class="even">
<td><code>&gt;</code></td>
<td>大于</td>
</tr>
<tr class="odd">
<td><code>&gt;=</code></td>
<td>大于等于</td>
</tr>
<tr class="even">
<td><code>BETWEEN AND</code></td>
<td>在指定的两个值之间</td>
</tr>
</tbody>
</table>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 按指定的搜索条件条件过滤</span></span><br><span class="line"><span class="keyword">SELECT</span> prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="operator">=</span> <span class="number">2.50</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 空值检查</span></span><br><span class="line"><span class="keyword">SELECT</span> prod_name <span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- AND, OR</span></span><br><span class="line"><span class="comment">-- AND 运算优先级高于 OR</span></span><br><span class="line"><span class="keyword">SELECT</span> prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> (vend_id <span class="operator">=</span> <span class="number">1002</span> <span class="keyword">OR</span> vend_id <span class="operator">=</span> <span class="number">1003</span>) <span class="keyword">AND</span> prod_price <span class="operator">&gt;=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- IN</span></span><br><span class="line"><span class="comment">-- 像是个语法糖</span></span><br><span class="line"><span class="comment">-- 但比常规的 OR 要快</span></span><br><span class="line"><span class="keyword">SELECT</span> prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="keyword">IN</span> (<span class="number">1002</span>, <span class="number">1003</span>) <span class="keyword">AND</span> prod_price <span class="operator">&gt;=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- NOT</span></span><br><span class="line"><span class="comment">-- 和 Python 里的一样</span></span><br><span class="line"><span class="keyword">SELECT</span> prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="number">1002</span>, <span class="number">1003</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure>
<h3 id="通配符和-regex">通配符和 regex</h3>
<ul>
<li><strong>通配符</strong>(wildcard)用来匹配值的一部分的特殊字符.</li>
<li><strong>搜索模式</strong>(search pattern<a href="#fn2"
class="footnote-ref" id="fnref2"
role="doc-noteref"><sup>2</sup></a>)由字面值(literal),
通配符或两者组合构成的搜索条件.</li>
<li>通配符就是 WHERE 字句中具有特殊含义的字符.</li>
<li><code>%</code> 匹配不了 <code>NULL</code>.</li>
<li>不要过度使用通配符, 注意通配符位置.</li>
<li>MySQL 只实现 REGEX 里的很小一块子集.</li>
<li><code>LIKE</code> 和 <code>REGEXP</code><a href="#fn3"
class="footnote-ref" id="fnref3"
role="doc-noteref"><sup>3</sup></a>的区别:
完全匹配整个列和部分匹配.</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- % 通配符: 任何字符出现次数</span></span><br><span class="line"><span class="comment">-- &#x27;jet%&#x27; 匹配模式: 任何以词jet开头的产品</span></span><br><span class="line"><span class="comment">-- % 可以多次出现, 可以出现在任何位置</span></span><br><span class="line"><span class="keyword">SELECT</span> prod_id, prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name <span class="keyword">LIKE</span> <span class="string">&#x27;jet%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- _ 通配符: 只匹配单个字符</span></span><br><span class="line"><span class="keyword">SELECT</span> prod_id, prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name <span class="keyword">LIKE</span> <span class="string">&#x27;_ ton anvil&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用正则表达式</span></span><br><span class="line"><span class="comment">-- &#x27;.000&#x27; 匹配诸如 `1000`, `2000`...</span></span><br><span class="line"><span class="comment">-- &#x27;1000|2000&#x27; 类似于 OR</span></span><br><span class="line"><span class="comment">-- &#x27;[1234]000&#x27; 几个字符之一 简写`[1-4]`</span></span><br><span class="line"><span class="comment">-- 剩下的 REGEX 就不介绍了</span></span><br><span class="line"><span class="keyword">SELECT</span> prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name REGEXP <span class="string">&#x27;.000&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 区分大小写: BINARY 关键字</span></span><br><span class="line"><span class="keyword">SELECT</span> prod_id, prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name REGEXP <span class="string">&#x27;JetPack .000&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="计算字段">计算字段</h3>
<ul>
<li>字段(field)基本上就是列的意思.</li>
<li>拼接字段得到一个导出列(derived column)</li>
<li><code>AS</code> 关键字: 别名(alias)</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 拼接字段</span></span><br><span class="line"><span class="comment">-- 示例输出:</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">+----------------------+</span></span><br><span class="line"><span class="comment">| vend_title           |</span></span><br><span class="line"><span class="comment">+----------------------+</span></span><br><span class="line"><span class="comment">| Vendor 1 (USA)       |</span></span><br><span class="line"><span class="comment">| Vendor 2 (Germany)   |</span></span><br><span class="line"><span class="comment">+----------------------+</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">SELECT</span> Concat(vend_name, <span class="string">&#x27; (&#x27;</span>, vend_country, <span class="string">&#x27;)&#x27;</span>) <span class="keyword">AS</span> vend_title</span><br><span class="line"><span class="keyword">FROM</span> vendors</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 执行算术运算</span></span><br><span class="line"><span class="comment">-- 支持加减乘除</span></span><br><span class="line"><span class="keyword">SELECT</span> prod_id,</span><br><span class="line">       quantity,</span><br><span class="line">       item_price,</span><br><span class="line">       quantity <span class="operator">*</span> item_price <span class="keyword">AS</span> expanded_price</span><br><span class="line"><span class="keyword">FROM</span> orderitems</span><br><span class="line"><span class="keyword">WHERE</span> order_num <span class="operator">=</span> <span class="number">20005</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- SELECT 可以拿来测试计算</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">3</span> <span class="operator">*</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">Trim</span>(<span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line"><span class="keyword">SELECT</span> Now()</span><br></pre></td></tr></table></figure>
<h3 id="数据处理函数">数据处理函数</h3>
<p>文本处理函数:</p>
<table>
<thead>
<tr class="header">
<th>函数名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>CONCAT</td>
<td>用于连接多个字符串</td>
</tr>
<tr class="even">
<td>UPPER</td>
<td>将字符串转换为大写</td>
</tr>
<tr class="odd">
<td>LOWER</td>
<td>将字符串转换为小写</td>
</tr>
<tr class="even">
<td>SUBSTRING</td>
<td>从字符串中提取子字符串</td>
</tr>
<tr class="odd">
<td>LENGTH</td>
<td>返回字符串的长度</td>
</tr>
<tr class="even">
<td>TRIM</td>
<td>去除字符串首尾的空格</td>
</tr>
<tr class="odd">
<td>LTRIM</td>
<td>去除字符串开头的空格</td>
</tr>
<tr class="even">
<td>RTRIM</td>
<td>去除字符串末尾的空格</td>
</tr>
<tr class="odd">
<td>LEFT</td>
<td>返回字符串左边指定长度的子字符串</td>
</tr>
<tr class="even">
<td>RIGHT</td>
<td>返回字符串右边指定长度的子字符串</td>
</tr>
<tr class="odd">
<td>REPLACE</td>
<td>替换字符串中的指定子字符串</td>
</tr>
<tr class="even">
<td>CHARINDEX</td>
<td>返回指定子字符串在字符串中第一次出现的位置</td>
</tr>
<tr class="odd">
<td>REVERSE</td>
<td>反转字符串</td>
</tr>
<tr class="even">
<td>FORMAT</td>
<td>将数值或日期格式化为指定的字符串表示</td>
</tr>
<tr class="odd">
<td>COALESCE</td>
<td>返回第一个非空表达式的值</td>
</tr>
<tr class="even">
<td>CASE</td>
<td>条件语句，用于在结果中根据条件返回不同的值</td>
</tr>
<tr class="odd">
<td>REGEXP_REPLACE</td>
<td>使用正则表达式替换字符串中的内容</td>
</tr>
<tr class="even">
<td>TRANSLATE</td>
<td>替换字符串中的指定字符</td>
</tr>
<tr class="odd">
<td>SOUNDEX</td>
<td>返回字符串的 SOUNDEX 码，用于模糊匹配字符串的发音</td>
</tr>
<tr class="even">
<td>CONCAT_WS</td>
<td>用指定的分隔符连接多个字符串，并去除空字符串</td>
</tr>
<tr class="odd">
<td>INITCAP</td>
<td>将字符串的首字母大写</td>
</tr>
<tr class="even">
<td>STRPOS</td>
<td>返回指定子字符串在字符串中第一次出现的位置</td>
</tr>
<tr class="odd">
<td>LEFTPAD</td>
<td>在字符串的左侧填充指定字符</td>
</tr>
<tr class="even">
<td>RIGHTPAD</td>
<td>在字符串的右侧填充指定字符</td>
</tr>
</tbody>
</table>
<p>日期函数:</p>
<table>
<thead>
<tr class="header">
<th>函数名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>AddDate</td>
<td>增加一个日期（天、周等）</td>
</tr>
<tr class="even">
<td>AddTime</td>
<td>增加一个时间（时、分等）</td>
</tr>
<tr class="odd">
<td>CurDate</td>
<td>返回当前日期</td>
</tr>
<tr class="even">
<td>CurTime</td>
<td>返回当前时间</td>
</tr>
<tr class="odd">
<td>Date</td>
<td>返回日期时间的日期部分</td>
</tr>
<tr class="even">
<td>DateDiff</td>
<td>计算两个日期之差</td>
</tr>
<tr class="odd">
<td>Date_Add</td>
<td>高度灵活的日期运算函数</td>
</tr>
<tr class="even">
<td>Date_Format</td>
<td>返回一个格式化的日期或时间串</td>
</tr>
<tr class="odd">
<td>Day</td>
<td>返回一个日期的天数部分</td>
</tr>
<tr class="even">
<td>DayOfWeek</td>
<td>对于一个日期，返回对应的星期几</td>
</tr>
<tr class="odd">
<td>Hour</td>
<td>返回一个时间的小时部分</td>
</tr>
<tr class="even">
<td>Minute</td>
<td>返回一个时间的分钟部分</td>
</tr>
<tr class="odd">
<td>Month</td>
<td>返回一个日期的月份部分</td>
</tr>
<tr class="even">
<td>Now</td>
<td>返回当前日期和时间</td>
</tr>
<tr class="odd">
<td>Second</td>
<td>返回一个时间的秒部分</td>
</tr>
<tr class="even">
<td>Time</td>
<td>返回一个日期时间的时间部分</td>
</tr>
<tr class="odd">
<td>Year</td>
<td>返回一个日期的年份部分</td>
</tr>
</tbody>
</table>
<p>不同的 DBMS 对函数的实现和语法有些区别. <del>这么多谁记得住.</del>
建议看<a
href="https://dev.mysql.com/doc/refman/8.0/en/functions.html">文档</a>.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 使用范例:</span></span><br><span class="line"><span class="keyword">SELECT</span> cust_id, order_num</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">Year</span>(order_date) <span class="operator">=</span> <span class="number">2005</span> <span class="keyword">AND</span> <span class="keyword">Month</span>(order_date) <span class="operator">=</span> <span class="number">9</span>;</span><br></pre></td></tr></table></figure>
<h3 id="汇总数据-聚集函数">汇总数据: 聚集函数</h3>
<ul>
<li>汇总数据严格来说<strong>不是检索数据</strong>.</li>
<li>聚集函数(aggregate function): 运行在行组上,
计算和返回单个值的函数.</li>
<li><code>COUNT(*)</code>: 行的值为空依然计数
<code>COUNT(column)</code>: column 有值的计数</li>
<li><code>MAX()</code> 要求<strong>指定</strong>列名</li>
<li><code>ALL</code> 默认 <code>DISTINCT</code> 只包含不同的值</li>
<li>可以组合聚集函数.</li>
</ul>
<p>聚合函数:</p>
<table>
<thead>
<tr class="header">
<th>函数名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>AVG()</td>
<td>返回某列的平均值</td>
</tr>
<tr class="even">
<td>COUNT()</td>
<td>返回某列的行数</td>
</tr>
<tr class="odd">
<td>MAX()</td>
<td>返回某列的最大值</td>
</tr>
<tr class="even">
<td>MIN()</td>
<td>返回某列的最小值</td>
</tr>
<tr class="odd">
<td>SUM()</td>
<td>返回某列值之和</td>
</tr>
</tbody>
</table>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 聚集函数</span></span><br><span class="line"><span class="comment">-- 效率更高. 想想看和下面的差在哪?</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(column_name) <span class="keyword">AS</span> max_value</span><br><span class="line"><span class="keyword">FROM</span> table_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 普通的查询</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name <span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> column_name</span><br><span class="line"><span class="keyword">DESC</span> LIMIT <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h3 id="分组数据-group-by-和-having">分组数据: GROUP BY 和 HAVING</h3>
<ul>
<li><code>GROUP BY</code>(创建分组) 和
<code>HAVING</code>(过滤分组)</li>
<li><code>GROUP BY</code> 支持多级分组.
数据将在最后规定的分组上进行汇总.</li>
<li><code>GROUP BY</code> 在 <code>WHERE</code> 后,
<code>ORDER BY</code> 前</li>
<li><code>WHERE</code> 过滤行, 而 <code>HAVING</code>
过滤分组(两者很相似, 操作符通用)</li>
<li>可以这么想: <code>WHERE</code> 在分组前过滤, <code>HAVING</code>
在分组后过滤.</li>
<li>而且 <code>HAVING</code> 可以和 <code>WHERE</code> 混着用</li>
</ul>
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 35%" />
<col style="width: 55%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>ORDER BY</th>
<th>GROUP BY</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>输出</td>
<td>按指定列排序的结果</td>
<td>分组后的结果，但输出可能不按照分组的顺序</td>
</tr>
<tr class="even">
<td>列的使用</td>
<td>任意列，甚至非选择的列也可以使用</td>
<td>只能使用选择列或表达式列，必须使用每个选择列表达式</td>
</tr>
<tr class="odd">
<td>必要性</td>
<td>不一定需要</td>
<td>如果与聚集函数一起使用列（或表达式），则必须使用</td>
</tr>
</tbody>
</table>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建分组</span></span><br><span class="line"><span class="comment">-- GROUP BY 按 vend_id 排序并分组数据</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">| vend_id | num_prods |</span></span><br><span class="line"><span class="comment">|---------|-----------|</span></span><br><span class="line"><span class="comment">|   1     |    5      |</span></span><br><span class="line"><span class="comment">|   2     |    3      |</span></span><br><span class="line"><span class="comment">|   3     |    7      |</span></span><br><span class="line"><span class="comment">|   4     |    2      |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">SELECT</span> vend_id, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> num_prods</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> vend_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- WITH ROLLUP: 添加汇总行</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">| vend_id | num_prods |</span></span><br><span class="line"><span class="comment">|---------|-----------|</span></span><br><span class="line"><span class="comment">|   1     |    5      |</span></span><br><span class="line"><span class="comment">|   2     |    3      |</span></span><br><span class="line"><span class="comment">|   3     |    7      |</span></span><br><span class="line"><span class="comment">|   4     |    2      |</span></span><br><span class="line"><span class="comment">|  NULL   |    17     |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">SELECT</span> vend_id, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> num_prods</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> vend_id <span class="keyword">WITH</span> <span class="keyword">ROLLUP</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- GROUP BY 多级分组</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">| customer_id | order_date | order_amount |</span></span><br><span class="line"><span class="comment">|-------------|------------|--------------|</span></span><br><span class="line"><span class="comment">|     1001    | 2023-01-01 |     50.00    |</span></span><br><span class="line"><span class="comment">|     1002    | 2023-01-01 |     75.00    |</span></span><br><span class="line"><span class="comment">|     1001    | 2023-01-02 |     30.00    |</span></span><br><span class="line"><span class="comment">|     1003    | 2023-01-02 |     20.00    |</span></span><br><span class="line"><span class="comment">|     1002    | 2023-01-03 |     45.00    |</span></span><br><span class="line"><span class="comment">|     1001    | 2023-01-03 |     60.00    |</span></span><br><span class="line"><span class="comment">|     1003    | 2023-01-03 |     35.00    |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">SELECT</span> customer_id, order_date, <span class="built_in">SUM</span>(order_amount) <span class="keyword">AS</span> total_amount</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> customer_id, order_date;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 过滤分组</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">| cust_id | orders |</span></span><br><span class="line"><span class="comment">|---------|--------|</span></span><br><span class="line"><span class="comment">|   1001  |   3    |</span></span><br><span class="line"><span class="comment">|   1003  |   2    |</span></span><br><span class="line"><span class="comment">|   1002  |   2    |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">SELECT</span> cust_id, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> orders</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> cust_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>在SQL查询中, <code>SELECT</code> 子句的一般顺序如下:</p>
<ul>
<li><code>SELECT</code>：指定要检索的列或表达式。</li>
<li><code>FROM</code>：指定要从中检索数据的表或视图。</li>
<li><code>WHERE</code>：应用条件来筛选满足特定条件的行。</li>
<li><code>GROUP BY</code>：根据指定的列或表达式对结果进行分组。</li>
<li><code>HAVING</code>：筛选分组后的结果集。</li>
<li><code>ORDER BY</code>：指定结果集的排序顺序。</li>
<li><code>LIMIT</code> /
<code>OFFSET</code>（在某些数据库中可用）：限制返回的行数或指定结果集的偏移量。</li>
</ul>
<h3 id="使用子查询">使用子查询</h3>
<ul>
<li>子查询(subquery): 查找一遍又一遍</li>
<li>子查询总是<strong>从内向外</strong>处理.</li>
<li>相关子查询(correlated subquery): 涉及外部查询的子查询.</li>
<li>逐渐增加子查询来建立查询. 也就是先分成多部查询,
确定正常后再写进子查询.</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 用子查询</span></span><br><span class="line"><span class="comment">-- 括号里的先算</span></span><br><span class="line"><span class="keyword">SELECT</span> cust_id</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">WHERE</span> order_num <span class="keyword">IN</span> (<span class="keyword">SELECT</span> order_num</span><br><span class="line">                    <span class="keyword">FROM</span> orderitems</span><br><span class="line">                    <span class="keyword">WHERE</span> prod_id <span class="operator">=</span> <span class="string">&#x27;TNT2&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 其实你可以拆成两个查询. 最好先写成两步, 然后合并为子查询.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 作为计算字段使用子查询</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">| cust_name | cust_state | orders |</span></span><br><span class="line"><span class="comment">|-----------|------------|--------|</span></span><br><span class="line"><span class="comment">|   John    |     NY     |   3    |</span></span><br><span class="line"><span class="comment">|   Mary    |     CA     |   2    |</span></span><br><span class="line"><span class="comment">|   David   |     TX     |   0    |</span></span><br><span class="line"><span class="comment">|   Lisa    |     NY     |   1    |</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">SELECT</span> cust_name,</span><br><span class="line">       cust_state,</span><br><span class="line">       (<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> orders </span><br><span class="line">       <span class="keyword">WHERE</span> orders.cust_id <span class="operator">=</span> customers.cust_id) <span class="keyword">AS</span> orders</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> cust_name</span><br></pre></td></tr></table></figure>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>我去, 这不是我们 PASCAL 的写法吗!<a href="#fnref1"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p><code>schema</code> 和 <code>pattern</code>
都译作模式.<a href="#fnref2" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>MPE 的问题, REGEXP 代码块里应当高亮.<a href="#fnref3"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>双指针算法</title>
    <url>/2023/01/13/%E5%8F%8C%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<p>双指针核心要义是将含两层嵌套的朴素算法,
利用某种性质(例如单调性)将其优化成<code>O(n)</code>的过程.
有种并发的感觉——一步能干两个人的事情, 就不要等另一个人干完再去做.</p>
<p>双指针一般会结合其他数据结构或者算法一起使用.</p>
<span id="more"></span>
<h2 id="通用模板">通用模板</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 也可能是 j = n, 那么条件改为 j &gt; i, 以及 j--</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt; i &amp;&amp; <span class="built_in">check</span>(i, j))</span><br><span class="line">        j++;</span><br><span class="line">    <span class="comment">// 每道题目的具体逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="双指针应用">双指针应用</h2>
<h3 id="字符串删减">字符串删减</h3>
<p><a
href="https://www.acwing.com/problem/content/3771/">https://www.acwing.com/problem/content/3771/</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">string s;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; s;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Brute Force</span></span><br><span class="line">    <span class="comment">// for (int i = 2; i &lt; n; i++)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     if (s[i - 2] == &#x27;x&#x27; &amp;&amp; s[i - 1] == &#x27;x&#x27; &amp;&amp; s[i - 2] == &#x27;x&#x27;)</span></span><br><span class="line">    <span class="comment">//         cnt++;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// Optimization</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            j = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; n &amp;&amp; s[j] == <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">                j++;</span><br><span class="line">            cnt += <span class="built_in">max</span>(j - i - <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">            i = j - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最长连续不重复子序列">最长连续不重复子序列</h3>
<p><a
href="https://www.acwing.com/problem/content/description/801/">AcWing
799. 最长连续不重复子序列</a></p>
<p>朴素算法:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(v1, j, i))</span><br><span class="line">            res = <span class="built_in">max</span>(res, i - j + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 检查 [l, r] 区间上有无重复元素</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v1, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l + <span class="number">1</span>; i &lt;= r; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = l; j &lt; i; j++)</span><br><span class="line">            <span class="keyword">if</span> (v1[i] == v1[j])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>换用双指针(有点hashmap的感觉):</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    s[a[i]]++;          <span class="comment">// a[i]出现的次数(标记)加一</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt; i &amp;&amp; s[a[i]] &gt; <span class="number">1</span>)</span><br><span class="line">        s[a[j++]]--;    <span class="comment">// 如果存在重复元素 标记减一 j 右移 </span></span><br><span class="line">    res = <span class="built_in">max</span>(res, i - j + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组元素的目标和">数组元素的目标和</h3>
<p><a href="https://www.acwing.com/problem/content/802/">AcWing 800.
数组元素的目标和</a></p>
<p>朴素做法:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i] + B[j] == x)</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>双指针:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = m - <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; A[i] + B[j] &gt; x)</span><br><span class="line">        j--;</span><br><span class="line">    <span class="keyword">if</span>(j &gt;= <span class="number">0</span> &amp;&amp; A[i] + B[j] == x)</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断子序列">判断子序列</h3>
<p><a href="https://www.acwing.com/problem/content/2818/">AcWing 2816.
判断子序列</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i, j;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>, j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; n &amp;&amp; a[i] == b[j])</span><br><span class="line">        i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, (i == n) ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>2023寒假每日一题</title>
    <url>/2023/01/14/%E5%AF%92%E5%81%87%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
    <content><![CDATA[<p>收录一些寒假做的题目. 题目来源: <a
href="https://www.acwing.com/activity/content/introduction/2712/">寒假每日一题2023</a>
我才不是水题大师呢, 因为蒟蒻所以只能做这些入门题,
但实际上更水的题目已经被我筛掉了 (</p>
<span id="more"></span>
<h2 id="孤独的照片">孤独的照片</h2>
<p>导航: <a
href="http://www.usaco.org/index.php?page=viewproblem2&amp;cpid=1155&amp;lang=zh">USACO
2021 December Contest, Bronze Problem 1. Lonely Photo</a></p>
<p>题目等价于: 长度大于等于3, 且子串中两种字符中的一种, 数量小于等于1,
求这些子串的数目. 示例: <code>GHGHG</code> 输出 <code>3</code>, 其中
<code>GHG</code>, <code>HGH</code>, <code>GHG</code> 就是题目要求的.</p>
<p>暴力枚举会超时. 自己思考这个问题,
你会发现这道题实际上是个<strong>排列组合问题</strong>. 高考数学遇到求
<code>GGGGHGGGG</code> 符合题目条件的子串, 你会怎么做? 分类讨论,
然后利用乘法原理:</p>
<ul>
<li><code>H</code> 左边连续的 <code>G</code> 有 4 个, 右边连续的
<code>G</code> 有 4 个.</li>
<li>两边可以任选连续个数的 <code>G</code>, 左边可以不选, 也可以选1个,
一直到4个<code>G</code>; 右边也是同样的道理.
<ul>
<li>如果左右各选一个 <code>G</code>, 最小子串为 <code>GHG</code>,
剩下各边还有 <code>3</code> 个连续的 <code>G</code>, 可以不选,
或者选1个, 一直到3个, 依乘法原理有 <code>4 * 4 = 16</code>.</li>
<li>如果 <code>H</code> 作为子串的右端点, 最短子串为 <code>GGH</code>,
剩下可以不选, 或者选1个或2个. 那么有 <code>4 - 1 = 3</code> 种情况.</li>
<li>如果 <code>H</code> 作为子串的左端点, 本例中有
<code>4 - 1 = 3</code> 种情况.</li>
</ul></li>
<li>一共有 <code>16 + 3 + 3 = 22</code> 种情况.</li>
</ul>
<p>推广: <code>ans = l * r + l - 1 + r - 1</code>, 其中 <code>l</code>
表示"孤独"字符左边连续的另一字符的数量, <code>r</code> 同理. 一个问题是,
对于"孤独"字符处于端点的情况, <code>l - 1</code>
必须大于等于<code>2</code>, 否则构成不了最短子串. 因此可以做一个小操作:
<code>max(l - 1, 0)</code>. 然后依次遍历整个数组.</p>
<p>通过数学做法, 计算每一个字符和左右满足的子串,
时间复杂度压到了<code>O(1)</code>.</p>
<p>接下来是获取每一个字符对应的 <code>l</code> 和 <code>r</code>. 用
<code>g</code> 表示连续遇到的 <code>G</code>, <code>h</code>
表示连续遇到的 <code>H</code>.</p>
<ul>
<li>如果下一个字符不同, 假设当前字符为 <code>G</code>, 下一个字符为
<code>H</code>, 那么将 <code>g</code> 储存在 <code>l[i]</code> 或者
<code>r[i]</code>, 然后 <code>g</code> 归零, 因为不再连续.</li>
<li>如果下一个字符相同, 那么 <code>g</code> 或者 <code>h</code> 自增,
然后将 <code>g</code>(或者 <code>h</code>) 存储在 <code>l</code> 或者
<code>r</code> 中.</li>
</ul>
<p>本题也需要注意卡 <code>int</code>.</p>
<h2 id="上课睡觉">上课睡觉</h2>
<p>导航: <a
href="http://www.usaco.org/index.php?page=viewproblem2&amp;cpid=1203&amp;lang=zh">USACO
2022 February Contest, Bronze, Problem 2 Sleep in Class</a></p>
<p>本地化导航: <a
href="https://www.acwing.com/problem/content/description/4369/">AcWing
4366. 上课睡觉</a></p>
<p>题目要求: 合并, 石子堆集合中的每堆石子的数量都相同</p>
<p>假设总数 <code>sum</code> 的石子堆可以被平分成 <code>i</code> 堆,
每堆石子的个数为 <code>cnt</code>, 且易知
<code>cnt = sum / i</code>.</p>
<p>因为每次合并操作会使得石子堆的个数减一, 那么平分成 <code>i</code>
堆需要的操作数为 <code>n - i</code>, 所以最终输出的答案为
<code>n - i</code>. 我们只需要<strong>枚举找到这个最大的
<code>i</code></strong> 即可.</p>
<p>判断石子堆能否合并, 题目给出了一个良好的性质:
<strong>仅可以</strong>合并两个<strong>相邻</strong>的元素, 也就是说,
合并的部分是一段连续的区间, 我们就可以用一个变量 <code>s</code>
来累加石子堆, 从 <code>a[0]</code> 开始累加, 并判断如果
<code>s == cnt</code>, 那么重置 <code>s = 0</code>; 如果大于
<code>0</code>, 说明我们假设的 <code>cnt</code> 不成立. 如果能够遍历完
<code>a</code>, 则说明可以平分成 <code>i</code> 份.</p>
<p>本题一定有解, 因为 <code>i = 1</code> 一定成立.</p>
<h2 id="奶牛大学">奶牛大学</h2>
<p>导航: <a
href="http://www.usaco.org/index.php?page=viewproblem2&amp;cpid=1251">USACO
2022 December Contest, Bronze Problem 1. Cow College</a></p>
<p>我们会首先会对输入进行排序, 使得 <span class="math inline">\(c_0
\leqslant c_1 \leqslant c_2 \cdots \leqslant c_n\)</span>,
方便我们进一步讨论.</p>
<p>首先可以证明, 选取的学费 <span class="math inline">\(x \in \{c_0,
c_1, \cdots, c_n \}\)</span>. 可以反证. 假设 <span
class="math inline">\(c_{i}&lt;x&lt;c_{i+1}\)</span>, 那么收取的总费用
<span class="math inline">\(y = x\cdot (n - i) &lt; c_{i}\cdot(n -
i)\)</span>, 需要比较的仅是 <span class="math inline">\(c_{i}\)</span>
和 <span class="math inline">\(c_{i+1}\)</span> 情况下的收取总费用. 对
<span class="math inline">\(c\)</span> 从 0 到 n 枚举即可.</p>
<p>这题会卡<code>int</code>,
算收取总费用的时候要转换成<code>long long</code>.</p>
<h2 id="选数异或">选数异或</h2>
<p>导航: <a
href="https://www.dotcpp.com/oj/problem2665.html">第十三届蓝桥杯省赛C++A/C/研究生组
Problem D</a></p>
<p>目标: 在数组 <span class="math inline">\(a\)</span> 中找到满足 <span
class="math inline">\(p_i\oplus q_i = x\)</span> 的最小区间 <span
class="math inline">\([p_i,q_i]\)</span>, 判断每次询问的 <span
class="math inline">\([l,r]\)</span> 是否使得 <span
class="math inline">\([a_l\dots a_r]\)</span> 包含任一 <span
class="math inline">\([p_i,q_i]\)</span>.</p>
<p><strong>性质 1</strong> 如果 <code>p</code> 符合条件, 那么
<code>p ^ x</code> 一定存在于数组.</p>
<p><strong>证明</strong> 利用异或运算的性质</p>
<p><span class="math display">\[ p\oplus q = x \iff q = p \oplus
x\]</span></p>
<p>而 <code>q</code> 在数组里, 那么 <code>p ^ x</code> 存在. 换过来说,
如果 <code>q ^ x</code> 存在, 则能判定 <code>p</code> 存在. 利用这一点,
枚举 <code>i</code>, 然后找到距离 <span
class="math inline">\(q_i\)</span> 最近的一个 <span
class="math inline">\(p_i\)</span> 的位置, 我们记函数 <span
class="math inline">\(f(i)\)</span>, 它代表 <span
class="math inline">\(a_i\)</span> 左侧与 <span
class="math inline">\(a_i\)</span> 最近的一个配对数, 并约定,
如果左侧不存在配对, 那么 <span class="math inline">\(f(i) =
0\)</span>.</p>
<p>模拟样例:</p>
<figure>
<img src="/images/pic4.png" alt="模拟" />
<figcaption aria-hidden="true">模拟</figcaption>
</figure>
<p><strong>性质 2</strong> 原问题等价于: 判断 <span
class="math inline">\(f(r) \geqslant l\)</span>.</p>
<p><strong>证明</strong> <span class="math inline">\(f(r)\)</span> 表示
<span class="math inline">\(a_r\)</span> 左侧最近的一个匹配数下标,
若存在, 那么一定存在 <span class="math inline">\(q \leqslant r\)</span>,
且 <span class="math inline">\(f(r)\)</span> 大小为 <span
class="math inline">\([1,r]\)</span> 中最大的 <span
class="math inline">\(p\)</span> 下标. 记 <span
class="math inline">\(i(x)\)</span> 为元素 <span
class="math inline">\(x\)</span> 在数组中的下标位置. 即能找到一个 <span
class="math inline">\(p\)</span> 满足 <span class="math inline">\(i(p)
\geqslant l\)</span>, 使得 <span class="math inline">\(l \leqslant i(p)
&lt; i(q) \leqslant r \iff \{p\dots q\}\subseteq a[l\dots
r]\)</span>.</p>
<p>下一步就是求出 <span class="math inline">\(f(i)\)</span>
的递推表达式. 如果在 <span class="math inline">\([1,r]\)</span>
找到了新的匹配数 <span class="math inline">\(p&#39;\)</span>, 那么就更新
<span class="math inline">\(f(i) = i(p&#39;)\)</span>, 否则 <span
class="math inline">\(f(i) = f(i-1)\)</span>.</p>
<p>利用性质1, 可以利用一个哈希表. 如果哈希表内不存在
<code>a[i] ^ x</code> 的值, 那么会返回 <code>0</code>. 因为返回的是数值,
我们可以取 <code>f(i - 1)</code> 和 <code>hash(a[i] ^ x)</code>
的最大值作为 <code>f(i)</code>.</p>
<p>下面的代码在处理输入时做了一些静态优化:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1</span> &gt;&gt; <span class="number">20</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, x;</span><br><span class="line"><span class="type">int</span> a[M], dp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>], a[t ^ x]);</span><br><span class="line">        a[t] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        cout &lt;&lt; (dp[r] &gt;= l ? <span class="string">&quot;yes&quot;</span> : <span class="string">&quot;no&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数位排序">数位排序</h2>
<p>导航: <a
href="https://www.dotcpp.com/oj/problem2684.html">第十三届蓝桥杯省赛C++C组
数位排序</a></p>
<p>本题自定义实现一个比较函数, 然后STL sort即可.</p>
<p>但求数位和不能放在 <code>cmp</code> 里, 会TLE.
原因是<code>sort</code>的实现会进行 <code>n</code> 次 <code>cmp</code>
操作, 而 <code>cmp</code> 有 <code>c = 10^1</code> 级别的操作数,
<code>sort</code> 时间复杂度为 <code>O(n logn)</code>, 最大数据量
<code>n = 10^6</code>, 那么操作数约有
<code>10 * 10 * 10^6 = 10^8</code>, 就会卡时间.</p>
<p>在本地测试<code>0.98s</code>, 非常惊险, 但放oj平台TLE了.</p>
<p>所以我们需要<strong>预处理</strong>求 <code>1~n</code> 的数位和,
并保存到另一个数组里. 更优解是写一个结构体, 储存这个值和它的数位和,
然后对结构体数组排序.</p>
<p>使用排序预处理可以降低求解问题所需要的时间复杂度.
本质上这属于以空间换时间的一个平衡.</p>
<p>这样能少乘一个常数. 最大负载实际运行时间约为 <code>0.23s</code>.</p>
<h2 id="重新排序">重新排序</h2>
<p>导航: <a
href="https://www.dotcpp.com/oj/problem2690.html">第十三届蓝桥杯省赛C++C组
H: 重新排序</a></p>
<p>本题类似于<a href="https://vijos.org/p/1779">NOIP 2012 国王游戏</a>
以及 <a href="https://www.luogu.com.cn/problem/P2123">P2123
皇后游戏</a>. 题解可以参考: <a
href="https://ouuan.github.io/post/%E6%B5%85%E8%B0%88%E9%82%BB%E9%A1%B9%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F%E7%9A%84%E5%BA%94%E7%94%A8%E4%BB%A5%E5%8F%8A%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98/">浅谈邻项交换排序的应用以及需要注意的问题</a></p>
<p>贪心可以知道, 求和次数最多的位置, 重排后, 应当对应最大值.
这个可以通过邻项交换法证明.</p>
<p>一个想法是构造一个结构体, 包含值和这个位置被求和的次数,
然后对其排序.</p>
<p>但我们也可以构造两个数组, 对两个数组进行排序, 最后只用计算
<code>a[i] * b[i]</code> 的和就可以了, 甚至不用计算 <code>[1,n]</code>
上的前缀和, 因为如果一段区间如果没有被求和, <code>b[i] = 0</code>, 那么
<code>sum += 0</code>.</p>
<p>求 <code>b[i]</code>, 利用每一组的 <code>l, r</code>
可以求得数组中各个元素被求和了多少次. 让 <code>[l,r]</code>
中的数据加上一个相同的数, 快速做法是<strong>差分</strong>.</p>
<h2 id="技能升级">技能升级</h2>
<p>导航: <a
href="https://www.dotcpp.com/oj/problem2688.html">第十三届蓝桥杯省赛C++C组
倒数第二题</a></p>
<p>类似问题: <a
href="https://www.acwing.com/problem/content/description/1264/">鱼塘钓鱼</a></p>
<p>钓鱼数量只和在某一鱼塘待的时间相关(因为不会折返).
我们要做的是以下几件事:</p>
<ul>
<li>枚举最远钓到哪个鱼塘(确定路上花费的时间)</li>
<li>总钓鱼时间 <code>n</code> = <code>T</code> - 走的时间</li>
<li>已知总钓鱼时间 <code>n</code>, 分配各个鱼塘, 求最大和,
即三个数组排序, 求前<code>n</code>元素的和. 用多路归并排序</li>
</ul>
<p>这道题用的相同的思路: 求出堆前 <code>m</code>
个最大的元素的和<code>s</code>, 可以证明 <code>s</code> 就是最优解.
然而爆TLE, 原因是堆优化复杂度为<code>O(m log n)</code>, 而
<code>m</code> 可以取到 <code>2e9</code>. 如果要解决本题,
那算法复杂度必须要 <code>log m</code> 或者和 <code>m</code> 无关.</p>
<p>换一种思路, 如果能找到归并后的数组中第 <code>m</code> 个数
<code>x</code>, 以及每个技能升级的次数<code>t</code>, 我们可以用
<code>O(n)</code> 的时间(多次利用等差数列的求和)计算前 <code>m</code>
项数的和:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">res += <span class="built_in">sum</span>(a[i], b[i], t);</span><br></pre></td></tr></table></figure>
<p>数组按从大到小排序, 我们可以发现 <span
class="math inline">\(\geqslant x\)</span> 的数的个数 <span
class="math inline">\(\geqslant m\)</span>, 也就表示 $x + 1 $ 的数 <span
class="math inline">\(&lt; m\)</span> 个, 答案具有二段性,
于是我们可以用二分快速找出 <code>x</code>, 并且它的复杂度为
<code>O(log n)</code>.</p>
<p>二分检查的性质可以用一种更快速的方法判断, 我们假设 <code>t</code>
为当前技能升级的次数, 那么</p>
<p><span class="math display">\[a_i - (t-1)b_i \geqslant x \iff t =
\lfloor\dfrac{a_i-x}{b_i}\rfloor + 1\]</span></p>
<p>只用判断 <span class="math inline">\(\sum t \geqslant m\)</span>
即可.</p>
<h2 id="如此编码">如此编码</h2>
<p>导航: <a href="https://www.cspro.org/">27th CCF CSP认证 官网</a></p>
<p>考察对编码系统的理解, 我觉得还挺有意思的.</p>
<p>我们知道, 十进制数可以表示为</p>
<p><span class="math display">\[m = \sum^{n}_{i=1}10^{i-1}\cdot
b_{i}\]</span></p>
<p>利用</p>
<p><span class="math display">\[ m \bmod{10^{j}} =
\sum^{j}_{i=1}10^{i-1}\cdot b_{i} = m \bmod{10^{j - 1}} + 10^{j - 1}
\cdot b^{j}\]</span></p>
<p>记 <span class="math inline">\(p_i = m \bmod{10^{i}}\)</span>,
那么</p>
<p><span class="math display">\[b_j = \frac{p_j -
p_{j-1}}{10^{j-1}}\]</span></p>
<p>模拟样例: 假设 <span class="math inline">\(m = 177\)</span>, <span
class="math inline">\(j = 2\)</span>, 那么 <span
class="math inline">\(b_1 = \dfrac{7 - 0}{1} = 7\)</span>, <span
class="math inline">\(b_{2} = \dfrac{77 - 7}{10} = 7\)</span>, <span
class="math inline">\(b_3 = \dfrac{177 - 77}{100} = 1\)</span>.</p>
<p>这个算法的关键在于下面的数学表达式:</p>
<p><span class="math display">\[m \bmod c_{j}=\sum_{i=1}^{j} c_{i-1}
\times b_{i}\]</span></p>
<p>读取各数位的算法可以写成:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    p[i] = m % c[i];    <span class="comment">// c[i] = 10^i</span></span><br><span class="line">    b[i] = (p[i] - p[i - <span class="number">1</span>]) / c[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相比于原本求数位的方法要麻烦许多. 但这个算法的好处在于对一个变化的
<code>c</code>, 只要存在 <code>c</code> 和 <code>i</code>
的一个映射关系, 就一定能求出 <code>b[i]</code>.</p>
<p>按照本题的意思, 可以先计算 <code>a[i]</code> 的前缀乘积
<code>c[i]</code>, 然后利用上面的公式即可. 实际操作可以做一些静态处理,
例如 <code>p[i]</code> 在计算前缀乘积时就可以预处理了.</p>
<p>这种做法并不关注本题 <code>c[i]</code> 为 <code>a[i]</code>
的累乘这一性质. 另外一个常用的公式:</p>
<p><span
class="math display">\[m=c_{i}\left\lfloor\frac{m}{c_{i}}\right\rfloor+m
\bmod c_{i}\]</span></p>
<p>如果你能发现</p>
<p><span class="math display">\[m = \sum_{i=1}^{n}\left(b_{i} \times
\prod_{j=1}^{i-1} a_{j}\right) = a_{1}\left[a_{2}\left(a_{3} \times
\cdots+b_{3}\right)+b_{2}\right]+b_{1}\]</span></p>
<p>再利用 <span
class="math inline">\(m=a_{i}\left\lfloor\frac{m}{a_{i}}\right\rfloor+m
\bmod a_{i}\)</span> 的性质, 发现 <span class="math inline">\(b_i = m
\bmod a_i\)</span>. 之后只需要更新一下 <span
class="math inline">\(m&#39; = \dfrac{m - b_i}{a_i}\)</span> 就可以计算
<span class="math inline">\(b_{i+1}\)</span> 的值了.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, m, x, i;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        cout &lt;&lt; m % x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        m /= x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="出行计划">出行计划</h2>
<p>原题出处: 25th CCF CSP 认证</p>
<p>朴素解法: 判断 <span class="math inline">\(t_i - (q+k) \leqslant c_i
- 1\)</span>, 同时要保证 <span class="math inline">\(t_i \geqslant q +
k\)</span>.</p>
<p>这样做的复杂度为 <code>O(mn)</code>, 数量级为 <code>10^10</code>,
明显TLE. 尝试空间换时间:</p>
<p>假设 <span class="math inline">\(p_i\)</span> 表示第 <span
class="math inline">\(i\)</span> 时刻出行, <strong>且此时刻核酸结果对
<span class="math inline">\(c_i\)</span> 有效</strong>,
可行的方案个数.</p>
<p>这样做的好处是面对多例查询, 可以用 <code>a[q + k]</code>
快速得出结果. 这样算法复杂度就降低成 <code>O(n + m)</code>,
变为可计算的问题了. 下面的问题在于怎么用 <code>O(n)</code>
的复杂度求出这个 <code>a</code> 数组.</p>
<p>在我们的假设中, <code>i</code> 时刻核酸结果对 <code>c[i]</code> 有效,
首先可以知道 <code>t[i]</code> 时刻的可行的方案数需要加一, 考虑
<code>t[i]</code> 恰好是<strong>核酸有效的最后一个时刻</strong>.
往前倒推 <code>c[i]</code> 个时刻, 从 <code>t[i] - c[i] + 1</code> 开始,
这一段区间上的方案数也需要加一, 考虑 <code>t[i] - c[i] + 1</code>
恰好是<strong>核酸结果刚出的时刻</strong>.</p>
<p>一个问题是如果 <code>t[i] &lt; c[i]</code>, 此时下标会得到一个负数.
我们只需要默认最远回退到下标 <code>1</code> 即可.</p>
<p>一组 <code>t, c</code> 得到一段区间 <code>[l, r]</code>, 让
<code>a[l...r]</code> 的元素自增1,
这个操作可以通过<strong>差分</strong>实现.</p>
<h2 id="左孩子右兄弟">左孩子右兄弟</h2>
<p>导航: 第十二届蓝桥杯省赛第一场 C++ A/C 组, 第十二届蓝桥杯省赛第一场
JAVA A/C 组</p>
<p>这道题难点在于看懂题意. 对于一个根节点 <code>u</code>,
它的子节点必然大于父节点 <code>u</code>, 子树处于左侧,
子树的第一个节点即为第一个儿子, 儿子的右兄弟则为 <code>u</code>
的第二个儿子, 以此类推, 直到 <code>p[i] &lt;= u</code>.</p>
<figure>
<img src="/images/pic5.png" alt="模拟样例" />
<figcaption aria-hidden="true">模拟样例</figcaption>
</figure>
<p>例如, 在上面的例子中, 4, 3, 2 都大于 1, 因此它们都是 1 的儿子; 3, 2
小于 4, 作为 4 的右兄弟; 而 5 因为大于 2, 因此是 2 的儿子.</p>
<p>关注一个性质: 4, 3, 2 之间的<strong>顺序是可以互换</strong>的.
我们并不强求右兄弟的值小于当前节点, 因为仍然满足都小于 1
的条件(即便切换顺序以后, 可以多出新的分支)</p>
<p>我们考虑 <code>h</code> 为当前节点子树的高度, 假设 <code>u</code>
的儿子为 <code>a, b</code>, 那么 <code>h(a)</code> 表示 <code>a</code>
节点子树的高度. 例如在上面的例子中, 考虑 <code>a = 2</code>,
<code>h(a) = 1</code>. 我们计算的答案为 <code>h(2) + 3 = 4</code>.</p>
<p>我们要求的是 <span class="math inline">\(f(u) = \max \{ h(s_i) + c_i
\}\)</span>, 其中 <span class="math inline">\(c_i\)</span>
是当前节点的高度. 那么就可以按照树形dp的方法处理: DFS <code>u</code>
的所有子节点, 求出 <code>f(u)</code>, 答案即为
<code>f(1)</code>(根节点).</p>
<p>如果你乐意, 可以证明 <span class="math inline">\(h(s_i) +
c_i\)</span> 的最大值可以在 <span class="math inline">\(c_i\)</span>
为最大值时取到, 考虑反证法. 并且由于右兄弟之间可以互换的性质, <span
class="math inline">\(c_i\)</span> 取最大值, 即 <code>u</code>
子节点的数量 <code>cnt</code>(即上例中节点 2 位于子树的最高处).</p>
<p>我们只需要求出子节点中的 <span class="math inline">\(h_{max} +
cnt\)</span> 即可.</p>
<h2 id="后记">后记</h2>
<p>这次的寒假每日一题, 总的来说, 还是收获不小的.</p>
<p>以做代练确实是很好的一种做法, 因为当我们上手一道题感到一筹莫展的时候,
你会自主地去挖掘这道题目的背景, 以及需要掌握的预备知识.
对于算法新人来说, 这么做比一味地刷视频打卡, 学习效率要高很多,
最主要是涉及的知识更广: 这里有数论, 有dp, 有贪心, 有数据结构,
也有基础——提前预习, 或者复习某些已经刷过的知识点, 真的获益不少.</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>刷题</tag>
        <tag>数论</tag>
        <tag>枚举</tag>
        <tag>动态规划</tag>
        <tag>贪心</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title>简单的分治排序算法</title>
    <url>/2023/01/05/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>我们介绍两个基于分治且 <code>O(nlogn)</code> 的排序算法:
快速排序和归并排序. 理解排序算法的最好方法是模拟, 手动模拟指针的移动,
感受数据是怎么逐渐变得有序的. 配合动图食用更佳.</p>
<p>你可能会问: <code>std::sort</code> 它不香吗? 答:
让你手搓是为了理解算法思想, 没让你去用. 顺便提防将来的面试官.</p>
<p>两个算法困难的点在于边界分析. 算法导论就是干这个证明的.
不过正常人记模板就可以了 :)</p>
<span id="more"></span>
<h2 id="快速排序">快速排序</h2>
<h3 id="原理">原理</h3>
<p>快速排序的核心要义:
任取一个数<code>x</code>作为<strong>基准值</strong>,
<strong>调整<code>x</code>的左右区间</strong>,
使得左区间的值小于<code>x</code>, 右区间的值都大于<code>x</code>,
然后对这两个子区间<strong>递归调用</strong>.</p>
<p>怎么调整区间:</p>
<ul>
<li><del>扫描并比较整个数组, 大于 <code>x</code> 的放在数组
<code>a</code>, 小于的放在 <code>b</code>,
最后再复制回去.</del>(空间开销大)</li>
<li>双指针. <code>i</code> 从 <code>l</code> 开始移动, 确保
<code>q[l...i-1]</code> 比 <code>x</code> 小. 当遇到比 <code>x</code>
大的值, 就让这个值和 <code>j</code> 交换位置, 然后从后移动
<code>j</code> 指针, 确保 <code>q[j...r]</code> 比 <code>x</code> 大.
遇到比 <code>x</code> 小的值, 就再交换回去, 直到 <code>i</code>,
<code>j</code> 相遇.</li>
</ul>
<p>这两个区间的值也可以等于<code>x</code>. 算法的正确性, 用<a
href="https://www.acwing.com/solution/content/16777/">循环不变式</a>证明:
<code>q[l..i] &lt;= x</code> 以及 <code>q[j..r] &gt;= x</code></p>
<h3 id="性质">性质</h3>
<p>朴素的快排是一种不稳定的排序方式.</p>
<p>最优时间复杂度和平均时间复杂度为 <span class="math inline">\(O(n \log
n)\)</span> (基准数是中位数的情况), 最差情况退化成冒泡排序 <span
class="math inline">\(O(n^2)\)</span> (每一次基准数的选取都是最值).</p>
<h3 id="模板">模板</h3>
<p>来源: <a
href="https://www.acwing.com/activity/content/code/content/39784/">AcWing
785. 快速排序</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span>(q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j--; <span class="keyword">while</span>(q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j), <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="归并排序">归并排序</h2>
<p>归并排序是典范的分治思想的例子. 归并排序的核心要义是: 把数组一分为二,
一直分下去直到不能再分, 然后逐层合并两个有序的数组.</p>
<p>用程序语言描述就是下面的代码:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(array)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (basecase) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">merge_sort</span>(left);</span><br><span class="line">  <span class="built_in">merge_sort</span>(right);</span><br><span class="line">  <span class="built_in">merge</span>(left, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>核心是实现子程序 <code>merge</code>: 合并两个排好序的数组.
实现起来很简单, 用到了临时数组, 令
<code>tmp[k] = min(left[i], right[j])</code> 最后复制回原数组就可以了.
整个过程要用到三个指针, 分别指向临时数组, 以及两个排好序的数组.</p>
<h3 id="板子">板子</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">merge_sort</span>(q, l, mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> N = l + r - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> tmp[N];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        tmp[k++] = (q[i] &lt;= q[j]) ? q[i++] : q[j++];</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid)</span><br><span class="line">        tmp[k++] = q[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= r)</span><br><span class="line">        tmp[k++] = q[j++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= r; i++, j++)</span><br><span class="line">        q[i] = tmp[j];   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="应用">应用</h3>
<p><a href="https://www.acwing.com/problem/content/790/">AcWing 788.
逆序对的数量</a></p>
<p>用归并排序看待这个问题: 逆序对只存在三种情况, 在左半边, 在右半边,
或者横跨左右区间. 假设 <code>merge_sort</code>
能在排序的同时计算出逆序对的数量, 那么前两种情况等于递归调用
<code>merge_sort</code> 的值. 横跨左右区间的情况稍微比较复杂.
利用的是<code>merge</code>区间的单调性.
我们求的是<code>left</code>中每一个元素对应<code>right</code>中逆序对的数量.
假设我们找到了 <code>left[i] &gt; right[j]</code>, 那么一定有
<code>left[i...mid] &gt; right[j]</code>. 也就是说存在
<code>mid - i + 1</code> 个逆序对.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    LL res = <span class="built_in">merge_sort</span>(q, l, mid) + <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(q[i] &lt;= q[j])</span><br><span class="line">            tmp[k++] = q[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            res += mid - i + <span class="number">1</span>;</span><br><span class="line">            tmp[k++] = q[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid)</span><br><span class="line">        tmp[k++] = q[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= r)</span><br><span class="line">        tmp[k++] = q[j++];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = l, j = <span class="number">0</span>; i &lt;= r; i++, j++)</span><br><span class="line">        q[i] = tmp[j];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="k-way-merge">k-way merge</h3>
<p>如果需要merge的数组不止2个, 该怎么实现呢?</p>
<ul>
<li>建立一个小根堆.</li>
<li>将每一路的第一个元素插入小根堆. 我们可以知道<code>heap[1]</code>
就是最小值.</li>
<li>将堆顶元素弹出, 并将堆顶元素所在数组的下一元素加入堆中.</li>
<li>重复上面两步, 直到每一路都读取结束.</li>
</ul>
<p><a href="https://leetcode.cn/problems/merge-k-sorted-lists/">LeetCode
第 23 号问题: 合并 K 个排序链表</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// struct ListNode</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     int val;                                </span></span><br><span class="line"><span class="comment">//     ListNode *next;                         </span></span><br><span class="line"><span class="comment">//     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">mycomp</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(ListNode *a, ListNode *b)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a-&gt;val &gt; b-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">ListNode *<span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode *&gt; &amp;lists)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        priority_queue&lt;ListNode *, vector&lt;ListNode *&gt;, mycomp&gt; queue;</span><br><span class="line">        <span class="keyword">for</span> (ListNode *head : lists)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (head)</span><br><span class="line">                queue.<span class="built_in">push</span>(head);</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode *temp = dummy;</span><br><span class="line">        <span class="keyword">while</span> (!queue.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *p = queue.<span class="built_in">top</span>();</span><br><span class="line">            queue.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;next)</span><br><span class="line">                queue.<span class="built_in">push</span>(p-&gt;next);</span><br><span class="line">            temp-&gt;next = p;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a
href="https://www.acwing.com/problem/content/description/1264/">鱼塘钓鱼</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> a[N], d[N], s[N];</span><br><span class="line">priority_queue&lt;PII&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">work</span><span class="params">(<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= t; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> p = q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p.first &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        res += p.first;</span><br><span class="line">        p.first -= p.second;</span><br><span class="line">        q.<span class="built_in">push</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, T;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; d[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; s[i];</span><br><span class="line">        s[i] += s[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n &amp;&amp; s[i] &lt;= T; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">            q.<span class="built_in">push</span>(&#123;a[j], d[j]&#125;);</span><br><span class="line"></span><br><span class="line">        ans = <span class="built_in">max</span>(ans, <span class="built_in">work</span>(T - s[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
        <tag>分治</tag>
        <tag>多路归并</tag>
      </tags>
  </entry>
  <entry>
    <title>把Python写成shell脚本</title>
    <url>/2023/02/26/%E6%8A%8APython%E5%86%99%E6%88%90%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<p>为什么 Shell 脚本要用 Python 来写!? UNIX用户痛骂这是大逆不道.</p>
<p>比起 BAT/Bash 我更喜欢 Python 的语法, 高效又简洁, 想想看一个list
bash要怎么写. 有 os/sys 模块的存在完全可以把 Python
写成类shell脚本(本质即调用shell命令), 再加上 <code>pandas</code>
等包更是让 Python 实用到一个新的高度(Windows干活干的多).</p>
<p>当然, 工具就是顺手就好. 你喜欢用什么写就用什么写.</p>
<p>不考虑更底层的应用. 别扯什么嵌入式驱动, C语言顶着你的脑门问: 师傅,
我是干什么的.</p>
<span id="more"></span>
<h2 id="预备知识">预备知识</h2>
<p>其实就是当个 python 的 tldr</p>
<h3 id="字符串处理">字符串处理</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 去除多余的空格</span></span><br><span class="line">s = <span class="string">&#x27;  AAA   &#x27;</span></span><br><span class="line">s.strip()   <span class="comment"># lstrip().rstrip()</span></span><br><span class="line"><span class="comment"># 默认参数是空格, 其实可以上参数</span></span><br><span class="line">s.strip(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 大小写转换</span></span><br><span class="line">s.upper() <span class="comment"># s.lower()</span></span><br><span class="line"><span class="comment"># 大小写互换</span></span><br><span class="line">s.swapcase()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 分割字符串成为一个列表</span></span><br><span class="line"><span class="comment"># oj 题的读入</span></span><br><span class="line">a, b, c = <span class="built_in">input</span>().split()</span><br><span class="line"><span class="comment"># 按逗号分割</span></span><br><span class="line">s = <span class="string">&#x27;a,b,c&#x27;</span></span><br><span class="line">ls = s.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"><span class="comment"># 反向合成 s</span></span><br><span class="line"><span class="comment"># 注意 p.join 是以 p 为分隔符, 把 ls 这样一个字符串列表拼接起来</span></span><br><span class="line">new_s = <span class="string">&#x27;,&#x27;</span>.join(ls)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 字符串反转</span></span><br><span class="line"><span class="comment"># 没有 reverse(), 但可以用切片 :)</span></span><br><span class="line">s = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">reverse_s = s[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查找子串</span></span><br><span class="line">s = <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;hello&#x27;</span> <span class="keyword">in</span> s.lower():</span><br><span class="line">    <span class="comment"># 找不到返回 -1</span></span><br><span class="line">    <span class="built_in">print</span>(s.lower().find(<span class="string">&#x27;hello&#x27;</span>)) <span class="comment"># rfind</span></span><br><span class="line">    <span class="comment"># 替换字串, 还可以指定替换次数</span></span><br><span class="line">    new_s = s.replace(<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;goodbye&#x27;</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>字符串的语法糖</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 转义 这里的 \ 都不起作用了</span></span><br><span class="line">s = <span class="string">r&#x27;C:\tmp\Game&#x27;</span></span><br><span class="line">s = <span class="string">&#x27;C:\\tmp\\Game&#x27;</span></span><br></pre></td></tr></table></figure>
<p>用正则表达式!</p>
<h3 id="文件io">文件I/O</h3>
<h2 id="实际案例">实际案例</h2>
<h3 id="格式化文档">格式化文档</h3>
<p>故事是这样的: 英语老师发了一个Word文档, 但纯文本非常的丑陋...文本拖进
vscode, markdownlint 爆了 1000+ 的 warnings...</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">filename = sys.argv[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    lines = f.readlines()</span><br><span class="line"></span><br><span class="line">new_lines = []</span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i, line <span class="keyword">in</span> <span class="built_in">enumerate</span>(lines):</span><br><span class="line">    <span class="keyword">if</span> line <span class="keyword">or</span> (i &gt; <span class="number">0</span> <span class="keyword">and</span> lines[i-<span class="number">1</span>]):</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;。&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> line:</span><br><span class="line">            new_lines.append(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            new_lines.append(line)</span><br><span class="line">            new_lines.append(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            new_lines.append(line)</span><br><span class="line"></span><br><span class="line">lines = [line.rstrip() <span class="keyword">for</span> line <span class="keyword">in</span> new_lines]</span><br><span class="line"></span><br><span class="line">count += <span class="built_in">len</span>(new_lines) - <span class="built_in">len</span>(lines)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> lines <span class="keyword">and</span> <span class="keyword">not</span> lines[-<span class="number">1</span>]:</span><br><span class="line">    lines.pop()</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">trimmed_lines = []</span><br><span class="line"><span class="keyword">for</span> i, line <span class="keyword">in</span> <span class="built_in">enumerate</span>(lines):</span><br><span class="line">    <span class="keyword">if</span> line <span class="keyword">or</span> (i &gt; <span class="number">0</span> <span class="keyword">and</span> lines[i-<span class="number">1</span>]):</span><br><span class="line">        trimmed_lines.append(line)</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&#x27;\n&#x27;</span>.join(trimmed_lines))</span><br><span class="line">    f.write(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Modified <span class="subst">&#123;count&#125;</span> lines in file <span class="subst">&#123;filename&#125;</span>.&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="系统操作">系统操作</h2>
<h3 id="批量处理文件名">批量处理文件名</h3>
<p>故事是这样的: 看到文件夹下的图片都是
<code>微信图片_20210611232301</code>, <code>EAQ1vesW4AEaIdk</code>,
<code>v2-1db136aa02affc53f6f31c99f6977a86</code> 这样的命名,
我直接要爆炸了.</p>
<p>百度之, 发现居然还有人为之专门开发了改名程序.</p>
<p>明明几行代码就可以解决战斗的说.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取当前工作目录</span></span><br><span class="line">cwd = os.getcwd()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取当前目录中所有的 .jpg 文件</span></span><br><span class="line">files = [f <span class="keyword">for</span> f <span class="keyword">in</span> os.listdir(cwd) <span class="keyword">if</span> f.endswith(<span class="string">&#x27;.jpg&#x27;</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将文件重命名为 p(i).jpg, 其中 i 是文件的创建时间</span></span><br><span class="line"><span class="keyword">for</span> i, f <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">sorted</span>(files, key=<span class="keyword">lambda</span> x: os.path.getctime(x))):</span><br><span class="line">    os.rename(f, <span class="string">&#x27;p(&#123;&#125;).jpg&#x27;</span>.<span class="built_in">format</span>(i+<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>实际使用的时候可以改改代码. 例如多一个<code>.png</code>,
<code>.webp</code>, <code>.gif</code> 的识别啥的.</p>
<h2 id="拓展阅读">拓展阅读</h2>
<p>[1]. <a
href="https://google.github.io/styleguide/shellguide.html">Google Shell
Style Guide</a> 里面解释了你什么时候不应该使用 shell, 该怎么写
shell.</p>
<p>[2]. <a
href="https://missing-semester-cn.github.io/2020/shell-tools/">Shell
工具和脚本 - The missing semester of your cs education</a>
是一个很好的shell入门.</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建一个tiny-docker</title>
    <url>/2023/04/08/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAtiny-docker/</url>
    <content><![CDATA[<p>怎么理解Docker? 自己手搓一个.</p>
<p>这不是吹牛, 实际上核心技术就 Kernel 里的 Namespace, CGroup, UnionFS.
实现一个 tiny-docker, 对于了解 OS 也是大有裨益的!</p>
<p>多说无用, show me the code!</p>
<span id="more"></span>
<blockquote>
<p>Simply put, a container is another process on your machine that has
been isolated from all other processes on the host machine. That
isolation leverages kernel namespaces and cgroups, features that have
been in Linux for a long time. Docker has worked to make these
capabilities approachable and easy to use.</p>
</blockquote>
<h2 id="命令">命令</h2>
<p><code>ps</code>, <code>pstree -pan</code>(树结构表示)</p>
<p><code>ps</code> 的一些 option:</p>
<ul>
<li><code>a</code>: 一个终端的<strong>所有</strong>进程</li>
<li><code>u</code>：显示进程的<strong>归属用户</strong>以及<strong>内存使用</strong>情况</li>
<li><code>x</code>：显示出和终端<strong>没有关联</strong>的进程</li>
<li><code>j</code>：显示进程归属的<strong>进程组</strong> id,
<strong>会话</strong> id, <strong>父进程</strong> id</li>
<li><code>f</code>：以 ascii
形式显示出进程的<strong>层次</strong>关系</li>
</ul>
<p>常用选项: <code>ps aux</code>(关注主进程) /
<code>ps axjf</code>(关注进程间的关系)</p>
<p>配合 <code>grep</code> pipeline 食用更佳.</p>
<h2 id="进程管理">进程管理</h2>
<p>程序就是一串二进制<strong>代码</strong>. 当程序被执行时,
它就成为了<strong>进程</strong>. 进程用一个唯一整数 <code>pid</code>
标记.</p>
<p>众所周知一个程序可以开出多个进程. <code>fork</code>
函数可以在保留原进程的基础上开出新进程,
实际上就是父进程开出了子进程.</p>
<p>执行一个文件使用 <code>execvp</code> 函数族. 结束一个程序, 一般是
<code>main</code> 函数 <code>return 0</code> 或者调用
<code>exit()</code></p>
<p>子进程运行结束, 父进程需要用 <code>wait</code> 或
<code>waitpid</code> 回收子进程的资源. 不回收?
子进程会变成僵尸进程.(kernel 里的<code>task_struct</code> 没有释放)
或者你把它 <code>kill</code> 掉! 如果父进程先于子进程终止,
那么子进程就被 <code>init</code> 进程 <code>pid = 1</code> 收养.</p>
<p>Docker 的第一步是复读机!</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> string <span class="title">cmd</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">run</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">run_child</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Too few arguments&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;run&quot;</span>))</span><br><span class="line">        <span class="built_in">run</span>(argc - <span class="number">2</span>, &amp;argv[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">run</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Running &quot;</span> &lt;&lt; <span class="built_in">cmd</span>(argc, argv) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> child_pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(child_pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Failed to work&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(child_pid) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">waitpid</span>(child_pid, <span class="literal">NULL</span>, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            cerr &lt;&lt; <span class="string">&quot;Fail to wait for child&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Child terminated&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">run_child</span>(argc, argv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">run_child</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">execvp</span>(argv[<span class="number">0</span>], argv))</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Failed to exec&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> string <span class="title">cmd</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string prompt = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; argc; i++)</span><br><span class="line">        prompt.<span class="built_in">append</span>(argv[i] + <span class="built_in">string</span>(<span class="string">&quot; &quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> prompt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们来干正事: 实现 isolation!</p>
<h2 id="uts-namespace">UTS namespace</h2>
<p>Linux Namespace: 内核级别<strong>隔离</strong>系统资源 UTS: 在
container 里显示主机名(hostname)</p>
<p>Namespace 就好比 C++ 里的 namespace, <code>using namespace</code>
就是让你获取某一命名空间下的内容, Namespace
就是为了限制"你能看到什么"存在的.</p>
<p>UTS 是系统资源隔离机制中的一种. 此外还有
<code>Mount</code>(隔离文件和挂载点), <code>PID</code>(隔离
<code>pid</code>), <code>User</code>(隔离用户和用户组)... Namespace
类别负责限制进程在"某一方面"都能看到什么. 例如
<code>CLONE_NEWUTS</code>: 用于指定UTS Namespace.</p>
<p>UTS Namespace 隔离了不同进程的 hostname view, 这样修改 container 的
UTS Namespace 中的主机名就和 host 进程 Namespace 中的主机名不同了.</p>
<p>先回答一个问题: 为什么需要对主机名和域名进行隔离呢?</p>
<p>因为主机名和域名可以用来代替IP地址. 如果没有这一层隔离,
同一主机上不同的容器的网络访问就可能出问题.</p>
<p>涉及到 Namespace 的操作接口包括:</p>
<ul>
<li><code>clone()</code>: 创建一个独立 Namespace 的进程.</li>
<li><code>setns()</code>: 把进程加入到指定的 Namespace 中</li>
<li><code>unshare()</code>: 将进程脱离到新的 Namespace</li>
<li>以及 <code>/proc</code> 下的部分文件</li>
</ul>
<p>通过 <code>/proc</code> 文件查看已存在的 Namespace 试试
<code>ls -al /proc/$pid/ns</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">run_child</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> flags = CLONE_NEWUTS;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">unshare</span>(flags) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Fail to unshare in child&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">execvp</span>(argv[<span class="number">0</span>], argv))</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Failed to exec&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">besthope:~/mini-docker$ hostname</span><br><span class="line">LAPTOP-3CUODIL3</span><br><span class="line">besthope:~/mini-docker$ sudo ./mocker run /bin/bash</span><br><span class="line">Running /bin/bash</span><br><span class="line">root@LAPTOP-3CUODIL3:/home/besthope/mini-docker<span class="comment"># hostname container</span></span><br><span class="line">root@LAPTOP-3CUODIL3:/home/besthope/mini-docker<span class="comment"># hostname</span></span><br><span class="line">container</span><br><span class="line">root@LAPTOP-3CUODIL3:/home/besthope/mini-docker<span class="comment"># exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">Child terminated</span><br><span class="line">besthope:~/mini-docker$ hostname</span><br><span class="line">LAPTOP-3CUODIL3</span><br></pre></td></tr></table></figure>
<p>我们用 <code>sethostname</code> 给它自动化:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">run_child</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> flags = CLONE_NEWUTS;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">unshare</span>(flags) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Fail to unshare in child&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">sethostname</span>(child_hostname, <span class="built_in">strlen</span>(child_hostname)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Fail to change hostname&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">execvp</span>(argv[<span class="number">0</span>], argv))</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Failed to exec&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在就挺有模有样了, 不是嘛...?</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">besthope:~/mini-docker$ sudo ./mocker run /bin/bash</span><br><span class="line">Running /bin/bash</span><br><span class="line">root@container:/home/besthope/mini-docker<span class="comment"># ls -l</span></span><br><span class="line">total 32</span><br><span class="line">-rwxr-xr-x 1 besthope besthope 24656 Apr  8 20:34 mocker</span><br><span class="line">-rw-r--r-- 1 besthope besthope  1507 Apr  8 20:34 mocker.cc</span><br><span class="line">root@container:/home/besthope/mini-docker<span class="comment"># ps</span></span><br><span class="line">    PID TTY          TIME CMD</span><br><span class="line">   1067 pts/6    00:00:00 sudo</span><br><span class="line">   1068 pts/6    00:00:00 mocker</span><br><span class="line">   1069 pts/6    00:00:00 bash</span><br><span class="line">   1085 pts/6    00:00:00 ps</span><br></pre></td></tr></table></figure>
<h2 id="pid-namespace">PID namespace</h2>
<p><code>mocker</code> 中执行进程的 pid 是从 host 中增长而来的.
如果我想要 pid 从 1 开始增长, 要怎么做呢? 这就需要隔离 pid
namespace.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">run</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Parent running &quot;</span> &lt;&lt; <span class="built_in">cmd</span>(argc, argv) &lt;&lt; <span class="string">&quot;as &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">unshare</span>(CLONE_NEWPID) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Fail to unshare PID namespace&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">pid_t</span> child_pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(child_pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Failed to work&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(child_pid) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">waitpid</span>(child_pid, <span class="literal">NULL</span>, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            cerr &lt;&lt; <span class="string">&quot;Fail to wait for child&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Child terminated&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">run_child</span>(argc, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">besthope:~/mini-docker$ sudo ./mocker run /bin/bash</span><br><span class="line">Parent running /bin/bash as 1176</span><br><span class="line">Child running /bin/bash as 1</span><br><span class="line">root@container:/home/besthope/mini-docker<span class="comment"># ps</span></span><br><span class="line">    PID TTY          TIME CMD</span><br><span class="line">   1175 pts/6    00:00:00 sudo</span><br><span class="line">   1176 pts/6    00:00:00 mocker</span><br><span class="line">   1177 pts/6    00:00:00 bash</span><br><span class="line">   1184 pts/6    00:00:00 ps</span><br></pre></td></tr></table></figure>
<p><code>ps</code> 的 pid 怎么和 <code>getpid</code> 的不一样? 这个是
<code>ps</code> 的锅. 具体来说, <code>ps</code> 读取的是
<code>/proc</code> 目录下的进程信息, <code>container</code>
虽然放到了一个新的 <code>pid namespace</code>, 但是读取
<code>/proc</code> 的信息依然和 host 进程是相同的.</p>
<p>但这不影响我们成功隔离了 pid namespace.</p>
<p>一个细节: <code>unshare</code> 创建 pid namespace 是在父进程中进行的,
而不是像 UTS namespace 在子进程中进行. 原因: Kernel 这么做!</p>
<h2 id="文件系统隔离">文件系统隔离</h2>
<p>不同的 mount namespace 本身不能提供 filesystem 的隔离.</p>
<p>问题: mount isolation != filesystem isolation</p>
<p>为什么?</p>
<p>假设我手头有一个 <code>ubuntu-fs</code>, 里头有:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin  boot  dev  etc  home  init  lib  lib32  lib64  libx32  lost+found  media  mnt  opt  proc  root  run  sbin  snap  srv  sys  tmp  usr  var</span><br></pre></td></tr></table></figure>
<p>我们可以对子进程代码做简单的修改, 将 container 对整个 filesystem 的
<code>view</code> 限制在这个目录下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">run_child</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Child running &quot;</span> &lt;&lt; <span class="built_in">cmd</span>(argc, argv) &lt;&lt; <span class="string">&quot;as &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> flags = CLONE_NEWUTS;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">unshare</span>(flags) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Fail to unshare in child&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">chroot</span>(<span class="string">&quot;../ubuntu-fs&quot;</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Fail to chroot&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">chdir</span>(<span class="string">&quot;/&quot;</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Fail to chdir to /&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">sethostname</span>(child_hostname, <span class="built_in">strlen</span>(child_hostname)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Fail to change hostname&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">execvp</span>(argv[<span class="number">0</span>], argv))</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Failed to exec&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心在于 <code>chroot</code>: make path root directory. 后续的
absolute path 文件访问全都从这个新的根目录开始. 注意 <code>chroot</code>
只是 view isolation. 你可以利用相对目录访问来逃离这个根目录.</p>
<p>用 <code>chdir</code> 将目录切换到新设置的 <code>/</code>: change
working directory to path</p>
<p>看起来已经像那么回事了...?</p>
<p>当然要注意到一点: <code>/proc</code> 目录的问题依然没有解决.
如果这时候运行 <code>ps</code> 会直接报错, 原因是 <code>ubuntu-fs</code>
下的 <code>/proc</code> 里是什么都没有的...</p>
<p>但我们可以用一步挂载解决问题:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">run_child</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Child running &quot;</span> &lt;&lt; <span class="built_in">cmd</span>(argc, argv) &lt;&lt; <span class="string">&quot;as &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> flags = CLONE_NEWUTS;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">unshare</span>(flags) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Fail to unshare in child&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">chroot</span>(<span class="string">&quot;../ubuntu-fs&quot;</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Fail to chroot&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">chdir</span>(<span class="string">&quot;/&quot;</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Fail to chdir to /&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">mount</span>(<span class="string">&quot;proc&quot;</span>, <span class="string">&quot;proc&quot;</span>, <span class="string">&quot;proc&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Fail to mount /proc&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">sethostname</span>(child_hostname, <span class="built_in">strlen</span>(child_hostname)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Fail to change hostname&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">execvp</span>(argv[<span class="number">0</span>], argv))</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Failed to exec&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新的问题是: 当我们回到 host,
<code>cat /proc/mounts | grep ^proc</code>, 你会发现
<code>proc /home/user/ubuntu-fs/proc proc rw,relatime 0 0</code>
也出现在了 host 里!</p>
<h2 id="mount-namespace">Mount namespace</h2>
<p>Mount 比较蛋疼的一点在于, 你没法简单的加一个 flag 就实现 mount point
isolation. 你需要重新设置根目录mount point的propagation type.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">run_child</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Child running &quot;</span> &lt;&lt; <span class="built_in">cmd</span>(argc, argv) &lt;&lt; <span class="string">&quot;as &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> flags = CLONE_NEWUTS | CLONE_NEWNS;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">unshare</span>(flags) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Fail to unshare in child&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">mount</span>(<span class="literal">NULL</span>,<span class="string">&quot;/&quot;</span>, <span class="literal">NULL</span>, MS_SLAVE | MS_REC, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Fail to mount /&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">chroot</span>(<span class="string">&quot;../ubuntu-fs&quot;</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Fail to chroot&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">chdir</span>(<span class="string">&quot;/&quot;</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Fail to chdir to /&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">mount</span>(<span class="string">&quot;proc&quot;</span>, <span class="string">&quot;proc&quot;</span>, <span class="string">&quot;proc&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Fail to mount /proc&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">sethostname</span>(child_hostname, <span class="built_in">strlen</span>(child_hostname)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Fail to change hostname&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">execvp</span>(argv[<span class="number">0</span>], argv))</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Failed to exec&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们运行 container 的时候挂载 <code>\proc</code> 就不会 propagate
到 host view, container 的 <code>\proc</code> mount point visibility
就被限制在了 <code>container</code> 的 <code>mount container</code>
中.</p>
<p>当然, 你在 container 运行着的时候在 host 中依然能看到这个
<code>mount namespace</code> 的存在.</p>
<h2 id="完">完</h2>
<p>附一个完整代码:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mount.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *child_hostname = <span class="string">&quot;container&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> string <span class="title">cmd</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">run</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">run_child</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Too few arguments&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;run&quot;</span>))</span><br><span class="line">        <span class="built_in">run</span>(argc - <span class="number">2</span>, &amp;argv[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">run</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Parent running &quot;</span> &lt;&lt; <span class="built_in">cmd</span>(argc, argv) &lt;&lt; <span class="string">&quot;as &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">unshare</span>(CLONE_NEWPID) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Fail to unshare PID namespace&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">pid_t</span> child_pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(child_pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Failed to work&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(child_pid) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">waitpid</span>(child_pid, <span class="literal">NULL</span>, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            cerr &lt;&lt; <span class="string">&quot;Fail to wait for child&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Child terminated&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">run_child</span>(argc, argv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">run_child</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Child running &quot;</span> &lt;&lt; <span class="built_in">cmd</span>(argc, argv) &lt;&lt; <span class="string">&quot;as &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> flags = CLONE_NEWUTS | CLONE_NEWNS;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">unshare</span>(flags) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Fail to unshare in child&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">mount</span>(<span class="literal">NULL</span>,<span class="string">&quot;/&quot;</span>, <span class="literal">NULL</span>, MS_SLAVE | MS_REC, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Fail to mount /&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">chroot</span>(<span class="string">&quot;../ubuntu-fs&quot;</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Fail to chroot&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">chdir</span>(<span class="string">&quot;/&quot;</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Fail to chdir to /&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">mount</span>(<span class="string">&quot;proc&quot;</span>, <span class="string">&quot;proc&quot;</span>, <span class="string">&quot;proc&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Fail to mount /proc&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">sethostname</span>(child_hostname, <span class="built_in">strlen</span>(child_hostname)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Fail to change hostname&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">execvp</span>(argv[<span class="number">0</span>], argv))</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Failed to exec&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> string <span class="title">cmd</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string prompt = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; argc; i++)</span><br><span class="line">        prompt.<span class="built_in">append</span>(argv[i] + <span class="built_in">string</span>(<span class="string">&quot; &quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> prompt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码并不算长(?)</p>
<h2 id="参考">参考</h2>
<ol type="1">
<li><p><a
href="https://www.youtube.com/watch?app=desktop&amp;v=8fi7uSYlOdc&amp;feature=youtu.be">Containers
From Scratch • Liz Rice • GOTO 2018</a></p></li>
<li><p><a href="https://github.com/Kirhhoff/mini-docker">mini-docker:
illustrate what docker really is in 100 lines of C/C++</a> 是一个 C++
的实现版本, 这是对应的<a
href="https://www.zhihu.com/question/28300645/answer/2488146755">中文版本</a>.</p></li>
</ol>
]]></content>
      <categories>
        <category>小项目</category>
      </categories>
      <tags>
        <tag>Linux系统编程</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>数理逻辑人话ver</title>
    <url>/2023/03/11/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91%E4%BA%BA%E8%AF%9Dver/</url>
    <content><![CDATA[<p>为了严谨性以及交流方便, 我们需要术语来描述问题: 这很好,
某些问题数学语言胜千言——但由 terminology 组成的句子经常会让人不知所云.
尤其对于数理逻辑, 因为是翻译文字所以句子看起来就更糟心了.
本身不是数学专业, 还要被符号定义纠缠半死. 想要明白问题的核心要义,
非得二次翻译不可, 但最后描述的事情却是显而易见的.</p>
<blockquote>
<p>It is not what you read, but how you read it.——Richard Feynman</p>
</blockquote>
<p>一切在于你的理解:
是愿意如背古诗一般去背定义——事实上这也足够你做题了——还是<em>真真正正地</em>去理解所描述的问题?
以及, 为什么要这么定义?</p>
<span id="more"></span>
<h2 id="命题逻辑">命题逻辑</h2>
<p>免责声明: 这不是教会你怎么去应试的.</p>
<p>你学的是 CS, 那么学数学理应把数学和 CS 紧密联系起来.
说我们学习数学是效用主义, 没错, 就要这样.</p>
<p>与其在脑子里装些不明不白的"定义",
倒不如对逻辑学里讨论的问题以及讨论的方法多一些认真.</p>
<p>这篇文章只是对数理逻辑的一个简单梳理, 忽略了许多数学上的严谨性,
某些"末节"和"小技"在应对复杂的数学问题时就体现出它应有的作用.</p>
<h3 id="命题符号化">命题符号化</h3>
<h4 id="句子变符号">句子变符号</h4>
<p>什么是<strong>命题</strong>(statement)? 一个布尔值.</p>
<ul>
<li><code>1 + 1 != 2</code> <code>false</code></li>
<li><code>1 + 1 = 2</code> (<del>哈? 这不是赋值语句嘛.</del>)
<code>true</code></li>
</ul>
<p>换句话说就是: 有<strong>确切</strong>真值的陈述句(定义).</p>
<ul>
<li><span class="math inline">\(\sqrt{2}\)</span> 是无理数.
<code>true</code></li>
</ul>
<p>要求: 不能<em>含糊不清</em>(ambiguious).</p>
<ul>
<li><code>x + 1 == 2</code> (<code>x</code> is undefined)</li>
<li>I love you. (Hmmm...)</li>
</ul>
<p>所谓命题的符号化就是给命题起一个标识符. 比方说:</p>
<ul>
<li><code>P = (1 == 2)</code> (<code>p = false</code>)</li>
<li><code>P = 可导一定连续</code> (<code>p = true</code>)</li>
</ul>
<p>上面的 <code>P</code> 就称为<em>原子命题</em>. 举手: 老师,
那有分子命题吗? 你猜对了. 不过我们叫它<em>复合命题</em>.</p>
<h4 id="联接词就是连起来">联接词就是连起来</h4>
<p><strong>联接词</strong>(connective)可以认为是连接原子命题之间的化学键.</p>
<p>联接词是逻辑运算符. 熟悉编程语言, 这东西再简单不过.
只不过是换成数学的符号, 多一个名字而已:</p>
<ul>
<li><span class="math inline">\(P\wedge Q\)</span>
<strong>合取</strong>(conjunction) (<code>&amp;&amp;</code>,
<code>and</code>)
<ul>
<li>当且仅当 <span class="math inline">\(P\)</span> 和 <span
class="math inline">\(Q\)</span> 同为真为真.</li>
<li>把合取理解成乘法: 如果有一个零, 乘积就是零, 真值就为 0.</li>
<li><code>P = 1 != 2</code>, <code>Q = 1 % 2 == 0</code>, 那么 <span
class="math inline">\(P \wedge Q = 1 \wedge 0 = 0\)</span>.</li>
</ul></li>
<li><span class="math inline">\(P\vee Q\)</span>
<strong>析取</strong>(disjunction) (<code>||</code>, <code>or</code>)
<ul>
<li>当 <span class="math inline">\(P\)</span> 和 <span
class="math inline">\(Q\)</span> 任一为真即为真.</li>
<li>把析取理解成加法: 如果有一个 1, 和就必定大于等于 1, 那么真值就为
1.</li>
<li><code>P = 1 != 2</code>, <code>Q = 1 % 2 == 0</code>, 那么 <span
class="math inline">\(P \vee Q = 1 \vee 0 = 1\)</span>.</li>
</ul></li>
</ul>
<p>上面都是二元运算符, 联接词就是把<em>真值</em>连起来.</p>
<p><em>否定</em>联接词稍微特殊一些, 它是一元的.
搞得像它应该被开除联接词籍:</p>
<ul>
<li><span class="math inline">\(\neg P\)</span>
<strong>否定</strong>(negation) (<code>!</code>, <code>not</code>)
<ul>
<li>反转一个布尔值.</li>
<li><code>P = 1 &gt; 2</code>, 那么 <span class="math inline">\(\neg P =
1\)</span>.</li>
</ul></li>
</ul>
<p>如果你熟悉位运算的话, 这点联接词也能说是布尔变量(之间)的
<code>&amp;</code> <code>|</code> <code>!</code> 运算. 你可能会好奇:
我<em>异或</em> <code>xor</code> <code>^</code> 呢? 事实上,
异或其实也是有对应联接词的(<span class="math inline">\(P\oplus
Q\)</span>).</p>
<p>试试看你能不能只用 <code>&amp;</code> 和 <code>!</code> 模拟出
<code>^</code>!</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bitXor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> p = ~((~x) &amp; (~y)); <span class="comment">// or</span></span><br><span class="line">    <span class="type">int</span> q = ~(x &amp; y);</span><br><span class="line">    <span class="keyword">return</span> p &amp; q; <span class="comment">// Xor</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Remark: 这个例子实际上说明了基本运算符<em>可以剪裁</em>.
<code>or</code> 可以被 <code>and</code> 和 <code>neg</code> 模拟,
等价的一种说法是在 <span class="math inline">\(\{ \neg,
\wedge\}\)</span> 上构造 <span class="math inline">\(L\)</span>. (<span
class="math inline">\(L = \oplus\)</span>).
这也说明了某些真值联接词具有<strong>函数完全性</strong>,
比方说所有真值函数都可以在 <span
class="math inline">\(\mathscr{L}_{\neg,\vee,\wedge}\)</span>
中表达.</p>
</blockquote>
<p>剩下两个联接词很常用. 但它们同样可以被上面三种联接词模拟出来.</p>
<ul>
<li><span class="math inline">\(P\rightarrow Q\)</span>
<strong>蕴含</strong>(implication)
<ul>
<li><span class="math inline">\(P\)</span> 称作假设(hypothesis), <span
class="math inline">\(Q\)</span> 为结论(conclusion).
(<del>前件和后件?</del> 真不熟)</li>
<li>规则: <code>1 ➡ 1 = 1</code>, <code>1 ➡ 0 = 0</code>,
<code>0 ➡ 1 = 1</code>, <code>0 ➡ 0 = 1</code></li>
<li>除了 <code>P = true, Q = false</code> 外其它情况都为
<code>true</code>.</li>
<li><code>P</code> 为 <code>false</code> 而整个蕴含式一定为真(vacuously
true)<a href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a>.</li>
</ul></li>
<li><span class="math inline">\(P\leftrightarrow Q\)</span>
<strong>等价</strong>(equivlance) (<code>==</code>)
<ul>
<li><del>童贞</del>同真时为真, 同假时也为真.</li>
<li>也叫<em>双蕴含</em>. <code>iff</code></li>
</ul></li>
</ul>
<p>什么蕴含? 看符号不就是<em>推出</em>嘛. 就是 <code>P</code> 可以推出
<code>Q</code>, 如果成立, 就为真(?).</p>
<ul>
<li><code>P: 1+1=2</code>, <code>Q: 地球绕着太阳转</code></li>
<li><span class="math inline">\(P \rightarrow Q\)</span> 的含义:</li>
<li><code>C: 如果 1 + 1 = 2, 那么地球绕着太阳转.</code></li>
</ul>
<p>你看规则上说的, 1 implies 1 is 1, 那么 <code>C</code> 也是 1.
但这句话非常令人迷惑 🤔. 两个毫不相关的事实, 然后声明"事实推事实"为真,
这是在干什么.</p>
<p>特别说明一点: <strong>真值的联结不等同于命题间的联结</strong>.
牢记一点, <em>命题都是 1 和 0</em>.</p>
<p>讨论符号和公式的理论称为<strong>语义</strong>(semantics)理论. 1 + 1 =
2 和 one plus one equals two 是同一个语义.</p>
<p>蕴含可能会出现各种各样的地方, 或许你意识不到:</p>
<ul>
<li>不能玩游戏( <span class="math inline">\(\neg p\)</span> ),
除非写完作业(unless <span class="math inline">\(q\)</span>)</li>
<li>不写完作业, 就不能玩游戏. (<span class="math inline">\(\neg q
\rightarrow \neg q\)</span>)</li>
</ul>
<p>下面的都等价于 <span class="math inline">\(P \rightarrow
Q\)</span>:</p>
<ul>
<li>if P, then Q</li>
<li>Q if P</li>
<li>P only if Q</li>
<li>P 是 Q 的充分(sufficient)条件.</li>
<li>Q 是 P 的必要(necessary)条件.</li>
<li>Q unless not P.</li>
</ul>
<p>联接词有没有运算的优先级? 有. 要不要记? 不用. 总之按顺序算就对了.</p>
<h4 id="命题表达式">命题表达式</h4>
<p>我们之前提到过, 命题必须是一个<em>确切的真值语句</em>.</p>
<p>那可真可假怎么办? 也就是一个布尔变量, 0 或 1.
此时我们称其为<strong>命题变元</strong>.</p>
<p>用联接词, 我们可以将原子(简单)命题联系起来, 得到了复合命题. 同样,
命题变元的联结构成了一个<strong>命题表达式</strong>, 或者说是
propositional form, 或者说是 Well-Formed Formula(WFF)<a href="#fn2"
class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>,
或者说是 truth-value function.</p>
<p>严谨起见, 命题表达式是递归定义的:</p>
<ul>
<li>单个命题变元 <span class="math inline">\(p_1, p_2, \dots\)</span>
是命题表达式.</li>
<li>如果 <span class="math inline">\(\phi\)</span> 是命题表达式, 那么
<span class="math inline">\(\neg \phi\)</span> 也是.</li>
<li>如果 <span class="math inline">\(\phi\)</span> 和 <span
class="math inline">\(\psi\)</span> 都是命题表达式,
那么用联接词联结得到的新表达式也是.</li>
<li>只有<em>有限次</em>应用上述规则的符号串才是命题表达式.</li>
</ul>
<p>这个定义约定了命题表达式的"语法". 现在, 你就可以写一个算法,
来判定一个字符串是否是有效的命题表达式了! (我们留作习题 :)</p>
<h3 id="命题逻辑的判定">命题逻辑的判定</h3>
<h4 id="解释和真值表">解释和真值表</h4>
<p>给命题表达式 <span class="math inline">\(G\)</span> 解释 <span
class="math inline">\(I\)</span> == 给所有的命题变元 <span
class="math inline">\(p_1, p_2,\dots,p_n\)</span> 赋值</p>
<p>别扭的说法: 做一组<em>指派</em>(assignment), 如果命题表达式此时为真,
则称做一组<em>成真指派</em>(<del>全真教派</del>).</p>
<p>命题公式所有解释下得到的真值, 构成一张表,
叫<strong>真值表</strong>(truth table).
换句话说就是枚举了所有情况然后打表.</p>
<p>我们给出一个例子:</p>
<figure>
<img src="\images\pic9.png" alt="真值表 例子" />
<figcaption aria-hidden="true">真值表 例子</figcaption>
</figure>
<table>
<thead>
<tr class="header">
<th>P</th>
<th>Q</th>
<th>P ➡ Q</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr class="even">
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="odd">
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<h4 id="命题表达式的分类">命题表达式的分类</h4>
<p>如果打表发现所有解释下, 真值都为真,
那么这个表达式就叫<strong>永真公式</strong>,
也叫<em>重言式</em>(tautology). 真值全为假,
称其<strong>永假公式</strong>, 也叫<em>矛盾式</em>(contradiction).
不是矛盾式就是<em>可满足式</em>.</p>
<p>注意: 可满足式不是<em>偶然式</em>(或然式, contingency).</p>
<p>判定一个公式是否是永真公式, 最简单的办法就是枚举,
也就是列出真值表.</p>
<p>例如上面的真值表, 我们实际上证明了 <span class="math inline">\((P
\rightarrow Q) \leftrightarrow (\neg P \vee Q)\)</span> 是一个永真公式.
不信你再多看看.</p>
<p>有无算法, 能够判定对于一个任意的命题公式 <span
class="math inline">\(\phi\)</span>, 其是否可满足? 这个问题也叫 SAT(或
3-SAT) Problem, The Satisfiability Problem.</p>
<p>求解: 真值表枚举, 指数级的时间复杂度. 它是 NP-Complete 问题,
<strong>Cook-Levin Theorem</strong> 描述的就是这个事情.
如果你对算法分析感兴趣可以 Google 一下!</p>
<h4 id="逻辑等价">逻辑等价</h4>
<p>如果我们能证明 <span class="math inline">\(P \leftrightarrow
Q\)</span> 是个永真公式, 那么我们称 <span
class="math inline">\(P\)</span> 和 <span
class="math inline">\(Q\)</span>
是<strong>逻辑等价的</strong>(也叫<em>重言等价</em>). 用符号 <span
class="math inline">\(P=Q\)</span>, <span class="math inline">\(P
\Leftrightarrow Q\)</span> 或者 <span class="math inline">\(P\equiv
Q\)</span> 表示.</p>
<p>那么 <span class="math inline">\(\equiv\)</span> 和 <span
class="math inline">\(\leftrightarrow\)</span> 有什么区别吗? 结论:
这里没区别. 到一阶谓词逻辑才有区别.</p>
<p>类似的, 你可以用打表证明<em>德摩根律</em>(De Morgan's Laws):
Distribute and Flip</p>
<p><span class="math display">\[\neg (P \wedge Q) \equiv (\neg P \vee
\neg Q)\]</span></p>
<p><span class="math display">\[\neg(P \vee Q) \equiv (\neg P \wedge
\neg Q)\]</span></p>
<p>打表可以建立以下的 24 种基本的等价关系:</p>
<figure>
<img src="/images/pic10.png" alt="24 种基本的等价关系" />
<figcaption aria-hidden="true">24 种基本的等价关系</figcaption>
</figure>
<p>举手: 这些公式都要记吗? 要. 但实际上不难记忆,
就把联接词当成加法乘法来看待. 记住几个最常用的足足够了.</p>
<p>对于一个 <span class="math inline">\(n\)</span> 元的命题表达式,
显然有 <span class="math inline">\(2^n\)</span> 种赋值方式. 或者,
对于一个表达式很长的命题公式,
显然打表去求一个表达式的等价公式效率太低了.
此时可以用上面的这些基本等价公式去化简, 有时甚至能直接判定:</p>
<p><strong>例 1</strong> <span class="math inline">\(\neg(p \rightarrow
q)\)</span> 和 <span class="math inline">\(p \wedge \neg q\)</span>
逻辑等价吗?</p>
<p><span class="math display">\[
\begin{aligned}
\neg(p \rightarrow q) &amp; \equiv \neg(\neg p \vee q) \\
&amp; \equiv \neg(\neg p) \wedge \neg q \\
&amp; \equiv p \wedge \neg q
\end{aligned}
\]</span></p>
<p><strong>例 2</strong> 小明写了下面的程序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (a) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b) &#123;</span><br><span class="line">        <span class="built_in">x</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">y</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (b) &#123;</span><br><span class="line">        <span class="built_in">x</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">y</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请你帮他改改代码.</p>
<p><strong>解</strong> 分析一下, 执行 <span
class="math inline">\(x\)</span> 条件是 <span
class="math inline">\((a\wedge b)\vee (\neg a \wedge b) = b\)</span>,
执行 <span class="math inline">\(y\)</span> 条件 <span
class="math inline">\((a\wedge \neg b)\vee (\neg a \wedge \neg b) = \neg
b\)</span>, 所以</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (b)</span><br><span class="line">    <span class="built_in">x</span>();</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">y</span>();</span><br></pre></td></tr></table></figure>
<h4 id="逻辑蕴含">逻辑蕴含</h4>
<p>有逻辑等价, 有逻辑蕴含吗? 有!</p>
<p><span class="math inline">\(\phi\models \psi\)</span> 定义为: 对于
<span class="math inline">\(\phi\)</span> 任一为真的解释, <span
class="math inline">\(\psi\)</span> 为真; 换言之 <span
class="math inline">\(\phi \rightarrow \psi\)</span> 永真.</p>
<p>例如 <span class="math inline">\((P \rightarrow Q) \models (\neg P
\vee Q)\)</span>.</p>
<p>此外我们定义 <span class="math inline">\(\phi\)</span> 永真当且仅当
<span class="math inline">\(\models \phi\)</span>. (称 <span
class="math inline">\(\phi\)</span> is valid)</p>
<p>举手: 那么 <span class="math inline">\(\rightarrow\)</span> 和 <span
class="math inline">\(\models\)</span> 有什么区别吗? <span
class="math inline">\(\models\)</span> 和 <span
class="math inline">\(\Rightarrow\)</span> 有什么区别吗?</p>
<p>我们之前提到, 联接词是一种布尔值之间的<strong>运算</strong>,
最后得到一个新的真值为 0 或 1 的命题(复合命题), 可以理解 <span
class="math inline">\(\rightarrow\)</span> 就是一个运算符,
我们关注的是运算后得到的<strong>值</strong>. 而 <span
class="math inline">\(\models\)</span>
表示的是<strong>命题之间的关联</strong>, <span
class="math inline">\(P\)</span> 推 <span
class="math inline">\(Q\)</span>, 这个"推"用的就是 <span
class="math inline">\(\models\)</span>; 我们关注的侧重点不是 <span
class="math inline">\(\phi\models \psi\)</span> 等于多少,
它已经永真了.</p>
<p>至于 <span class="math inline">\(\Rightarrow\)</span>,
平时在写数学题你会用到这个记号, 例如从条件 1 可以推出条件 2, 条件 2
推出条件 3, 直到推出结论. 那么这里的"推出"你会写 <span
class="math inline">\(\Rightarrow\)</span> 而不是数理逻辑里的符号 <span
class="math inline">\(\models\)</span>. 当然, 一般来说我们也不区分 <span
class="math inline">\(\Rightarrow\)</span> 和 <span
class="math inline">\(\models\)</span>, 你也可以认为这两个符号等价.</p>
<p>当然, 这个世界上还存在一个 <span
class="math inline">\(\vdash\)</span> 的东西. 如果你感兴趣, 你可以 check
这个<a
href="https://www.zhihu.com/question/21191299/answer/17469774">回答</a>.</p>
<h3 id="规范化canonical">规范化(canonical)</h3>
<h4 id="范式">范式</h4>
<p>什么是范式? 在回答这个问题之前, 我们需要引入一些相关的定义:</p>
<ul>
<li>命题变元或命题变元的否定称为文字.</li>
<li>有限个文字的析取式称为简单析取式(基本和)</li>
<li>有限个文字的合取式称为简单合取式(基本积)</li>
<li>由有限个简单合取式构成的析取式称为析取范式.</li>
<li>由有限个简单析取式构成的合取式称为合取范式.</li>
</ul>
<p>简单来说:</p>
<ul>
<li>OR 连接 AND(称<em>简单合取式</em>或<em>基本积</em>)
的式子称为<strong>析取范式(DNF)</strong>.</li>
<li>AND 连接 OR(称<em>简单析取式</em>或<em>基本和</em>)
的式子称为<strong>合取范式(CNF)</strong>.</li>
</ul>
<p>这么理解就好懂它的命名了:</p>
<ul>
<li>简单合取式, 就是一堆变元<a href="#fn3" class="footnote-ref"
id="fnref3" role="doc-noteref"><sup>3</sup></a> AND 相连得到的式子.
之前讲过 <span class="math inline">\(\wedge\)</span> 可以理解成乘法,
所以也叫做基本积.</li>
<li>析取范式, 那么就是 OR 相连得到的式子, 只不过基本单位是上面的基本积.
因为规范过, 所以称为范式.</li>
<li>剩下同理.</li>
</ul>
<p>举几个例子就很清楚了:</p>
<p><span class="math display">\[
\begin{array}{l}
(1) p \\
(2) p \vee q \vee \neg r \\
(3) \neg p \wedge q \wedge r \\
(4) (p \wedge q) \vee(\neg p \wedge q) \\
(5) (p \vee q) \wedge(\neg p \vee q)
\end{array}
\]</span></p>
<p>类似 (1) 这样的命题表达式(文字)既是析取范式又是合取范式.
这不是一种约定, 通过幂等律可以说明这一点.</p>
<ol start="2" type="1">
<li><p>是一个析取范式(用 or 连接). 但同时也可以看成是一个合取范式,
只需要 <span class="math inline">\((p \vee q \vee \neg r)\wedge
T\)</span> 即可.</p></li>
<li><p>是一个合取范式(用 or 连接). 但同时也可以看成是析取范式.</p></li>
<li><p>只能是一个析取范式. (5) 只能是一个合取范式.</p></li>
</ol>
<p><strong>定理</strong> 任何命题公式可以化成析取范式或合取范式的形式,
而且二者(重言)等价.</p>
<p>我们的操作如下:</p>
<ul>
<li>首先用等价公式消去 <span class="math inline">\(\rightarrow\)</span>
和 <span class="math inline">\(\leftrightarrow\)</span>.</li>
<li>消去多余的 <span class="math inline">\(\neg\)</span>.</li>
<li>用分配律化成 DNF 或 CNF.</li>
</ul>
<h4 id="主范式">主范式</h4>
<p>DNF 和 CNF 实际上不唯一. 例如 <span class="math inline">\(P \wedge (Q
\vee R)\)</span> 还可以写成 <span class="math inline">\((P \vee P)
\wedge (Q \vee R)\)</span> 之类.</p>
<p>范式还不够强, 要进一步约束限定, 于是就有了主范式.
主范式规定的是它的<em>基本构成</em>:</p>
<ul>
<li>对于合取范式中的每一个简单析取式,
要求<strong>包含所有的命题变元</strong>,
且每个<strong>只能出现一次</strong>.(称其为<em>极大项</em>, maxterm)
<ul>
<li>主合取范式就是由有限个极大项组成的布尔表达式.</li>
</ul></li>
<li>对于析取范式也是如此.
简单合取式更名为了<em>极小项</em>(minterm).</li>
</ul>
<p>举个例子:</p>
<ul>
<li>对于三个变元的场景, <span class="math inline">\(P \wedge Q\)</span>
不是极大项, 因为还缺了一个变元.</li>
<li>只考虑两个变元: <span class="math inline">\(P \wedge \neg P\)</span>
不是极大项, 因为 <span class="math inline">\(P\)</span> 变元出现了两次.
(显然出现两次同一个变元, 合取是永假的)</li>
<li><span class="math inline">\(P \wedge Q\)</span> 是一个极大项,
每一个变元前可以加一个 <span class="math inline">\(\neg\)</span>,
所以对于只有两个变元的情况, 极大项有 4 个, 极小项也有 4 个.</li>
</ul>
<blockquote>
<p>容易推广, 对于 <span class="math inline">\(n\)</span> 个命题变元,
可以组合出 <span class="math inline">\(2^n\)</span> 个极大项和 <span
class="math inline">\(2^n\)</span> 个极小项.</p>
</blockquote>
<p>为什么称规范后的简单析取式为极大项? 一种解释是,
析取是对所有变元(或变元的否)取极大值:</p>
<p><span class="math display">\[p_1 \vee p_2 \vee ... \vee p_n = \max
\{p_1, p_2, ..., p_n \}\]</span></p>
<p>观察到一个性质:
全体极大项的合取永假(总存在<strong>唯一的</strong>一个假的极大项),
全体极小项的析取永真(总存在<strong>唯一的</strong>一个真的极小项).</p>
<p>这其实很好理解: 当且仅当所有变元为假时, 简单析取式为假;
当且仅当所有变元为真时, 简单合取式为真.</p>
<p>利用<strong>唯一性</strong>,
我们可以对极小项和极大项<strong>编码</strong>. 我们用 <span
class="math inline">\(1\)</span> 表示一个命题变元, <span
class="math inline">\(0\)</span> 表示命题变元的否,
这么做恰好能满足编码的<strong>完备性</strong>, 对于极小项:</p>
<ul>
<li><span class="math inline">\(P \wedge Q \wedge \neg R\)</span>
就可以编码成 <span class="math inline">\(110\)</span>, 用 <span
class="math inline">\(m_{110}(m_6)\)</span> 表示.</li>
</ul>
<p>对应的真值表上的一组成真赋值:</p>
<figure>
<img src="/images/pic11.png" alt="成真赋值" />
<figcaption aria-hidden="true">成真赋值</figcaption>
</figure>
<p>对于极大项, 那么就是按照成假赋值去编码. 例如 <span
class="math inline">\(P \vee Q \vee \neg R\)</span> 就是 <span
class="math inline">\(001\)</span>, 也就是 <span
class="math inline">\(M_{001}(M_1)\)</span>.</p>
<blockquote>
<p>编码计算思维的体现: 假设 <span class="math inline">\(B = \{0,
1\}\)</span>, <span class="math inline">\(B^{A}\)</span> 表示 <span
class="math inline">\(A\)</span> 到 <span
class="math inline">\(B\)</span> 的所有函数构成的集合, 那么 <span
class="math inline">\(B^A = P(A)\)</span>, 通常也记 <span
class="math inline">\(2^{A}\)</span>,
我们可以用类似编码的思想来说明!</p>
</blockquote>
<p>显然, 没有两个不同的极大项(极小项同理)是等价的.
那么极大项的<strong>组合</strong>(极小项同理)也是唯一的. 这样规范以后,
就保证了<strong>范式的唯一性</strong>.</p>
<blockquote>
<p>这实际上表示了一种 <span class="math inline">\(B^{n}\to B\)</span>
的一种映射关系(函数).</p>
</blockquote>
<p>在求出了主合取范式了以后, 它的主析取范式也就确定了. 反之亦然.
我们可以简单推导一下: 假设主合取范式为 <span
class="math inline">\(G\)</span>, 那么</p>
<p><span class="math display">\[G = \vee^{k}_{i = 1}
M_{l_i}\]</span></p>
<p>对应主析取范式 <span class="math inline">\(G=\neg(\neg G)=\neg
(\vee^{2^{n}-k}_{i = 1} M_{l_i})=\vee^{2^{n}-k}_{i=1}(\neg
M_{l_i})=\vee^{2^{n}-k}_{i=1}m_{l_i}\)</span>.</p>
<p>用真值表就很清楚了. 动手试试看!</p>
<h3 id="最终任务-推理">最终任务: 推理</h3>
<p>数理逻辑的最大作用: 把推理<strong>形式化</strong>.</p>
<p>什么是推理? 举一个简单的例子:</p>
<p>前提: 1. 如果天下雨, 那么路上有水. 2. 天下雨了 结论: 路上有水</p>
<p>简单的符号化: 如果 A, A-&gt;B, 那么 B.</p>
<ul>
<li>A: 下雨</li>
<li>B: 路上有水</li>
</ul>
<p>这就是一个<strong>有效(valid)推理</strong>(或者说这个论说是<strong>好的</strong>).
这里<strong>前提</strong>(premises)是 A 和 A-&gt;B,
<strong>结论</strong>(conclusion)为 B.</p>
<p>所谓有效推理, 并不要求我们的前提和结论一定为真. 若前提为真,
则结论为真, 这就<strong>合乎逻辑</strong>.</p>
<p>有一个误区是:"你的前提是假的, 即便论说是有效的, 但结论一定是假的".
例如你怎能确定今天一定下雨? 如果不下雨, 路上就没有水, 结论明显为假,
你的论证不对.</p>
<p>我们可以举出一个反例:</p>
<p>前提: 1. 所有的猫都是人. 2. 所有的学生都是猫 结论:
所有的学生都是人</p>
<p>两个前提都是假的, 但结论无疑是真的. 此时你可能会开始质疑,
是这个论证的问题吗? 换句话说,
怎么去说明一个论证是<strong>坏的</strong>?</p>
<p>如果一个论说的形式存在<strong>反例</strong>(counterexample),
那么他就是坏的. 例如:</p>
<p>前提: 1. 企鹅都是鸟 2. 猴子都不是企鹅 结论: 猴子都不是鸟</p>
<p>考虑反例:</p>
<p>前提: 1. 企鹅都是鸟 2. 麻雀都不是企鹅 结论: 麻雀都不是鸟</p>
<p>显然两个前提为真, 但结论为假. 这明显和上面的例子矛盾!
这个论说是不满足<strong>一致性</strong>(consistency)的, 或者说不自洽的.
这个例子, 和上面的例子, 都是一个无效的论证.</p>
<p>回到上例, 如果今天没下雨, 显然天下雨了这个前提不成立,
但这影响这个推理的有效性吗?</p>
<p>"今天下雨"的情况取决于实际情况, 也就是需要一个<strong>解释</strong>.
我们的推理如果有效, 对于任意的解释, 都成立. 这里的成立指的是</p>
<p>在我们的符号化中, 我们实际上要说明的是 <span class="math inline">\(A
\wedge (A\rightarrow B)\rightarrow B\)</span> 在任何解释 <span
class="math inline">\(I\)</span> 下都为真, 也即, 它是个永真公式, 也即
<span class="math inline">\(A \wedge (A\rightarrow B)\Rightarrow
B\)</span> (条件 <span class="math inline">\(\Gamma\)</span> 逻辑蕴含
<span class="math inline">\(H\)</span>)</p>
<p>这就是我们推理有效的理论支撑!</p>
<p>进一步推广, <span class="math inline">\(\Gamma\)</span>
是一组前提构成的集合, 这些前提的合取可以推出 <span
class="math inline">\(H\)</span>. 我们验证一个推理是否有效, 只要证明
<span class="math inline">\(G_1\wedge G_2\wedge...\wedge G_n\rightarrow
H\)</span> 永真即可! 不过, 正如我们上面所叙述的, 判断永真公式是个 NP
hard 的问题, 我们需要一种更有效的推理方法,
这就引出了<strong>演绎法</strong>.</p>
<h4 id="基于规则的推理-演绎法">基于规则的推理: 演绎法</h4>
<p>命题逻辑有不同的演绎系统, 例如希尔伯特式推演系统.
最常研究的希尔伯特风格演绎系统只有一个推理规则, 即肯定前件(MP)和<a
href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E4%BC%AF%E7%89%B9%E6%BC%94%E7%BB%8E%E7%B3%BB%E7%BB%9F">几个无限公理模式</a>:</p>
<figure>
<img src="/images/pic14.png" alt="希尔伯特式推演系统" />
<figcaption aria-hidden="true">希尔伯特式推演系统</figcaption>
</figure>
<p>Hilbert 的这套系统好处是很简单. 坏处是太难用了.</p>
<p>自然演绎系统(Gerhard Gentzen 提出)做了相反的取舍,
包括了很多演绎规则但有非常少甚至没有公理模式. 它(例如Finch-style,
Jaśkowski style)基于一套引入(introduction)和消去(elimination)的规则<a
href="#fn4" class="footnote-ref" id="fnref4"
role="doc-noteref"><sup>4</sup></a>.</p>
<p>那我们教科书上的这套演绎规则是什么呢?</p>
<ul>
<li>规则 P(引入前提): 可引入前提集合中任意一个前提.</li>
<li>规则 T(引入结论): 可引入逻辑蕴含式 + 基本等价公式作为已知结论.</li>
</ul>
<p>命题公式的等价公式上面我们已经给出了,
这里是另外一些基本的逻辑蕴含式:</p>
<figure>
<img src="/images/pic12.png" alt="逻辑蕴含式" />
<figcaption aria-hidden="true">逻辑蕴含式</figcaption>
</figure>
<p>以上公式可以打表证明.</p>
<p>利用 <span class="math inline">\(P, T\)</span>
规则的证明称为<strong>直接证明</strong>.</p>
<ul>
<li>规则 CP(附加前提): 如果 <span class="math inline">\(\Gamma\wedge
P\Rightarrow S\)</span>, 那么 <span
class="math inline">\(\Gamma\Rightarrow P\rightarrow S\)</span>.</li>
<li>正确性: <span class="math inline">\(P\rightarrow(Q\to
R)\Leftrightarrow(P\land Q)\rightarrow R\)</span>.</li>
</ul>
<p>使用附加前提的证明称为<strong>条件证明</strong>.
我们再给出一种特殊的条件证明: <strong>反证法</strong></p>
<p>我们将结论 <span class="math inline">\(R\)</span> 的否定 <span
class="math inline">\(\neg R\)</span> 作为附加前提作为条件, 倘若得到了
<span class="math inline">\(\Gamma \wedge \neg R\)</span> 为矛盾式, 那么
<span class="math inline">\(R\)</span> 为真.</p>
<p>事实上还可以证明命题逻辑的可靠性(soundness), 即:
凡是系统中可证明的都是系统的语言的重言式.
同理我们有完全性(completeness), 任何重言式都可以在系统中被证明.</p>
<h2 id="谓词逻辑">谓词逻辑</h2>
<h3 id="我在学语法吗">我在学语法吗?</h3>
<p>谓词逻辑, in short, 就是把命题逻辑中的原子命题进一步分解.
我们举个例子:</p>
<ul>
<li>地球绕着太阳转.</li>
</ul>
<p>可以分解成: 地球-绕-太阳, 那么我们用 <code>绕(x, y)</code> 表示
<code>x</code> 绕着 <code>y</code>, 它的值域是 0 和 1. 这里
<code>绕(..)</code> 就是所谓"谓词".</p>
<p>换言之, 谓词(predicate): 返回 <code>bool</code> 的一个函数.</p>
<p>既然也是 true or false, 问题来了: <em>谓词是一个命题吗</em>?
这个问题等价于 <code>x == 1</code> 是命题吗? 显然不是. 因为
<code>x</code> 不确定.</p>
<p>谓词要成为命题, 需要赋值. 例如 <code>绕(地球, 太阳)</code>
就是一个命题. 实际上, 我们一般研究的是<em>一阶</em>谓词逻辑,
也就是变量数为一的情形. 一般来说, 我们会这么符号化: <code>绕(x)</code>
为 <code>x</code> 绕着太阳转.</p>
<p>你可能会好奇: 不是说好了主谓宾吗? 怎么谓词还包含宾语呢? 实际上,
<code>绕(x) = 绕(x, c)</code>, 而 <code>c = 太阳</code>,
因为我们把太阳看成了常量, 因此这个可以降为一阶谓词.</p>
<p>当然, 一般我们都会用符号来表示这些文字, 因此 <span
class="math inline">\(P(x)\)</span> 就是我们研究谓词的一般形式.</p>
<p>更严格来说, <span class="math inline">\(x\)</span>
也称为<em>个体词</em>, 或者说<em>项</em>. 它可以是常量 <span
class="math inline">\(1,2,...\)</span>, 也可以是变量 <span
class="math inline">\(x, y,...\)</span>, 也可以是函数 <span
class="math inline">\(x^2,\cos y,...\)</span>. 所谓谓词就是一个 <span
class="math inline">\(D^{n} \to \{0,1\}\)</span> 的一个映射.</p>
<h3 id="命题需要范围-量词">命题需要范围: 量词</h3>
<p>之前提过, 如果谓词想要成为命题, 就需要赋值. 例如: <span
class="math inline">\(P(x): x \text{ is prime}\)</span>, 我们给定 <span
class="math inline">\(x\)</span> 的范围是 <span class="math inline">\(0
\leqslant x \leqslant 5\)</span>, 那么命题</p>
<p><span class="math display">\[P(0) \wedge P(1) \wedge P(2) \wedge P(3)
\wedge P(4) \wedge P(5)\]</span></p>
<p>就表示 <span class="math inline">\(P(x)\)</span> 在 <span
class="math inline">\(0 \leqslant x \leqslant 5\)</span>
上是否<em>都满足</em>条件.</p>
<p><span class="math display">\[P(0) \vee P(1) \vee P(2) \vee P(3) \vee
P(4) \vee P(5)\]</span></p>
<p>就表示 <span class="math inline">\(P(x)\)</span> 在 <span
class="math inline">\(0 \leqslant x \leqslant 5\)</span>
上是否<em>有一个</em>满足条件的项.</p>
<p>因为这么写太麻烦了. 而且对于某些无穷集, 如 <span
class="math inline">\(\mathbb{N}^{+}\)</span>, 显然枚举到头也不是个办法,
因此我们引入了<strong>量词</strong>.</p>
<ul>
<li>全称量词 <span class="math inline">\(\forall\)</span>
就是用来表示"所有, 全部".</li>
<li>存在量词 <span class="math inline">\(\exists\)</span>
就是用来表示"存在, 至少".</li>
</ul>
<p>上面的例子就可以改写为</p>
<ul>
<li><span class="math inline">\(\forall x, P(x), x\in \{x|0\leqslant x
\leqslant 5\}\)</span></li>
<li><span class="math inline">\(\exists x, P(x), x\in \{x|0\leqslant x
\leqslant 5\}\)</span></li>
</ul>
<p>注意到 <span class="math inline">\(x\)</span> 的个体域描述的也是关于
<span class="math inline">\(x\)</span> 的一个性质,
那么我们也可以用一个<strong>特性谓词</strong>来描述 <span
class="math inline">\(x\)</span> 的个体域, <span
class="math inline">\(x\)</span> 现在就代表一个宽泛的全总个体域. 例如
<span class="math inline">\(H(x): 0 \leqslant x \leqslant 5\)</span>,
那么上面的例子又可以改写为</p>
<ul>
<li><span class="math inline">\((\forall x)(H(x)\to P(x))\)</span></li>
<li><span class="math inline">\((\exists x)(H(x)\land
P(x))\)</span></li>
</ul>
<p>注意全程量词和存在量词在添加特性谓词的方式是不同的.
<em>全称量词是析取, 存在量词是合取.</em></p>
<figure>
<img src="/images/pic13.png" alt="含量词的基本等价公式" />
<figcaption aria-hidden="true">含量词的基本等价公式</figcaption>
</figure>
<p><em>Remark 1</em>: 注意量词否定需要转换.</p>
<p><em>Remark 2</em>: 析取没有全称量词下的分配律,
合取没有存在量词下的分配律. 这很好理解, 因为所指不是同一个变量,
量词的<em>辖域</em>(影响的 <span class="math inline">\(x\)</span>
的范围)很重要:</p>
<p><span class="math display">\[(\exists x)H(x)\land (\exists
x)P(x)=(\exists x)H(x) \land (\exists y)P(y)\]</span></p>
<p><span class="math display">\[(\forall x)H(x)\to P(x)=\neg (\forall
x)H(x)\vee P(x)=(\exists x)(\neg H(x) \vee P(y))\]</span></p>
<figure>
<img src="/images/pic16.png" alt="量词的位置很重要" />
<figcaption aria-hidden="true">量词的位置很重要</figcaption>
</figure>
<h3 id="前束范式">前束范式</h3>
<p>前束范式是对含量词的范式的规范. 它的形式是:
所有谓词都处于公式的开头且不包含否定词,
它们的作用域延伸到整个公式的末尾.</p>
<p><span class="math display">\[ (\square x_1)(\square x_2)...(\square
x_n) M(x_1,x_2,...,x_n) \]</span></p>
<p><strong>定理</strong> 任意一个谓词公式均可化为与之等价的前束范式.</p>
<p>求前束范式的关键就是要记住量词辖域收缩与扩张等值式.</p>
<h3 id="量化命题的推理规则">量化命题的推理规则</h3>
<ul>
<li>US(Universal Specify):
<ul>
<li><span class="math inline">\((\forall x )G(x)\Rightarrow
G(y)\)</span> (<span class="math inline">\(y\)</span> 为任意的个体变量,
不在 <span class="math inline">\(x\)</span> 中出现)</li>
<li><span class="math inline">\((\forall x )G(x)\Rightarrow
G(c)\)</span> (<span class="math inline">\(c\)</span>
为任意的个体常量)</li>
</ul></li>
<li>UG(Universal Generalize): <span
class="math inline">\(G(y)\Rightarrow (\forall x)G(x)\)</span></li>
<li>ES(Existential Specify): <span class="math inline">\((\exists
x)G(x)\Rightarrow G(c)\)</span> (<span class="math inline">\(c\)</span>
特定的个体常量)</li>
<li>EG(Existential Generalize):
<ul>
<li><span class="math inline">\(G(c)\Rightarrow (\exists
x)G(x)\)</span>: <span class="math inline">\(c\)</span>
为特定的个体常量, <span class="math inline">\(G(c)\)</span> 中无自由变元
<span class="math inline">\(x\)</span></li>
<li><span class="math inline">\(G(y)\Rightarrow (\exists
x)G(x)\)</span>: <span class="math inline">\(G(y)\)</span> 不含自由变元
<span class="math inline">\(x\)</span></li>
</ul></li>
</ul>
<p>四条规则仅对前束范式适用.</p>
<h3 id="参考资料">参考资料</h3>
<ol type="1">
<li>离散数学及应用 原书第五版, Kenneth H. Rosen, 机械工业出版社</li>
<li>离散数学及其应用(第三版), 傅彦等, 高等教育出版社</li>
<li>符号逻辑讲义, 徐明(图书馆五楼有!)</li>
<li><a
href="https://web.archive.org/web/20070926223055/http://www.cas.mcmaster.ca/~wmfarmer/SE-2F03-05/slides/02-prop-logic.pdf">Farmer,
W. M. Propositional logic</a></li>
<li>校内 PPT</li>
</ol>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>也称善意推定.<a href="#fnref1" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>也叫做合式公式, 问题是有什么公式是不合式的?<a
href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>是上文提到的文字(literal).<a href="#fnref3"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>感兴趣可以参考 <em>Logic in Computer Science</em>
一书.<a href="#fnref4" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
]]></content>
      <categories>
        <category>离散数学</category>
      </categories>
      <tags>
        <tag>离散数学</tag>
        <tag>数理逻辑</tag>
      </tags>
  </entry>
  <entry>
    <title>离散考前挣扎</title>
    <url>/2023/06/12/%E7%A6%BB%E6%95%A3%E8%80%83%E5%89%8D%E6%8C%A3%E6%89%8E/</url>
    <content><![CDATA[<p>考前的最后挣扎. 全是题目, 不再一五一十地复习基本概念了,
会做题和懂数学是两码事, 时间该留到平时钻研.</p>
<p>说实话这学期的离散学的内容还是太松散了. 数理逻辑, 关系代数, 图论,
然后没了. 我觉得这门课改成 Introduction to Discrete Mathematics
可能更合适. 隔壁 UESTC 同一本教材讲得明显比咱好, NJU
的佬问我问题一查大半天, 惭愧.</p>
<p>总结一下往年的试卷和作业试题. 总的来说还是很简单的.
其实我还有一个习题集, 但那个超纲很多, 说不定哪天合并一下.</p>
<span id="more"></span>
<h2 id="数理逻辑">数理逻辑</h2>
<h3 id="求主范式">求主范式</h3>
<p>求命题公式 <span class="math inline">\(G(P,Q,R)=\neg (\neg P
\rightarrow Q) \vee (Q \wedge R)\)</span> 的主合取范式和主析取范式,
求解结果用 <span class="math inline">\(m_i\)</span> 和 <span
class="math inline">\(M_i\)</span> 的编码形式表示.</p>
<p><strong>解</strong></p>
<p><span class="math display">\[\begin{aligned}
G(P,Q,R) &amp;= \neg (P \vee Q) \vee (Q \land R) \\
&amp;=(\neg P \land \neg Q) \vee (Q \land R) \\
&amp;=(\neg P \land \neg Q \land \neg R) \vee (\neg P \land \neg Q \land
R) \vee (\neg P \land Q \land R) \vee (P \land Q \land R)\\
&amp;= m_0\vee m_1 \vee m_3 \vee m_7 \\
&amp;=M_2 \wedge M_4 \wedge M_5 \wedge M_6\\
&amp;=(P \vee \neg Q \vee R) \wedge (\neg P \vee Q \vee R) \wedge (\neg
P \vee Q \vee \neg R) \wedge (\neg P \vee \neg Q \vee R)
\end{aligned}
\]</span></p>
<h3 id="求前束范式">求前束范式</h3>
<p>求谓词公式 <span class="math inline">\((\exists x)((\forall
y)(\exists z)P(x,y,z)\to(\exists z)(\forall t)(Q(x,z)\lor
R(x,t,z)))\)</span> 的前束范式.
其前束范式和原公式之间的关系满足什么性质?</p>
<p><strong>解</strong></p>
<p><span class="math display">\[
\begin{aligned}
&amp;(\exists x)((\forall y)(\exists z)P(x,y,z)\to(\exists z)(\forall
t)(Q(x,z)\lor R(x,t,z))) \\
&amp;=(\exists x)(\neg(\forall y)(\exists z)P(x,y,z)\lor(\exists
z)(\forall t)(Q(x,z)\lor R(x,t,z))) \\
&amp;=(\exists x)((\exists y)(\forall z)\neg P(x,y,z)\lor(\exists
z)(\forall t)(Q(x,z)\lor R(x,t,z))) \\
&amp;=(\exists x)((\exists y)(\forall z)\neg P(x,y,z)\lor(\exists
w)(\forall t)(Q(x,w)\lor R(x,t,w))) \\
&amp;=(\exists x)(\exists y)(\forall z)(\exists w)(\forall t)(\neg
P(x,y,z)\lor Q(x,w)\lor R(x,t,w))
\end{aligned}
\]</span></p>
<p>它们是等价关系.</p>
<h3 id="演绎证明">演绎证明</h3>
<p>用演绎法证明下述推理的有效性:</p>
<ol type="1">
<li><p>明天下午或者是天晴，或者是下雨；仅当我去登山，明天下午才是天晴；只有我不学习，我才去登山。因此，如果我在学习，则天在下雨。</p></li>
<li><p>每个喜欢吃肉的人都不喜欢吃汤圆；每个人或者喜欢吃饺子或者喜欢吃汤圆；有的人不喜欢饺子。因而有的人不喜欢吃肉。</p></li>
</ol>
<p><strong>解</strong> (1) 符号化:</p>
<ul>
<li>P: 明天下午天晴</li>
<li>Q: 明天下午下雨</li>
<li>R: 明天下午登山</li>
<li>S: 明天下午学习</li>
</ul>
<p>上述命题可以翻译为: <span class="math inline">\(P \oplus Q, P \to R,R
\to \neg S\Rightarrow S \to Q\)</span></p>
<p>下面是证明:</p>
<ol type="1">
<li><p><span class="math inline">\(S \qquad \qquad \quad
P(附加前提)\)</span></p></li>
<li><p><span class="math inline">\(R\to \neg S \qquad
P\)</span></p></li>
<li><p><span class="math inline">\(\neg R \qquad \qquad
T,1,2,I\)</span></p></li>
<li><p><span class="math inline">\(P\to R \qquad \quad
P\)</span></p></li>
<li><p><span class="math inline">\(\neg P \qquad \qquad
T,3,4,I\)</span></p></li>
<li><p><span class="math inline">\(P \oplus Q \qquad \qquad
P\)</span></p></li>
<li><p><span class="math inline">\(Q \qquad \qquad \quad
T,5,6,I\)</span></p></li>
<li><p><span class="math inline">\(S\to Q \qquad \quad
CP,1,7\)</span></p></li>
<li><p>符号化:</p></li>
</ol>
<ul>
<li><span class="math inline">\(H(x)\)</span>: <span
class="math inline">\(x\)</span> 是人</li>
<li><span class="math inline">\(P(x)\)</span>: <span
class="math inline">\(x\)</span> 喜欢吃汤圆</li>
<li><span class="math inline">\(Q(x)\)</span>: <span
class="math inline">\(x\)</span> 喜欢吃饺子</li>
<li><span class="math inline">\(R(x)\)</span>: <span
class="math inline">\(x\)</span> 喜欢吃肉</li>
</ul>
<p>翻译: <span class="math inline">\((\forall x)(H(x)\land R(x)\to \neg
P(x)), (\forall x)(H(x)\to P(x) \lor Q(x)),(\exists x)(H(x)\land \neg
Q(x))\Rightarrow (\exists x) (H(x)\land \neg R(x))\)</span></p>
<p>下面是证明:</p>
<ol type="1">
<li><span class="math inline">\((\exists x)(H(x)\land \neg Q(x)) \qquad
\qquad P\)</span></li>
<li><span class="math inline">\(H(c)\land \neg Q(c) \qquad \quad \qquad
\qquad ES, 1\)</span></li>
<li><span class="math inline">\(H(c) \quad \qquad \qquad \qquad \qquad
\qquad T,2,I\)</span></li>
<li><span class="math inline">\(\neg Q(c) \qquad \qquad \qquad \qquad
\qquad T,2,I\)</span></li>
<li><span class="math inline">\((\forall x)(H(x)\to P(x) \lor Q(x))
\qquad P\)</span></li>
<li><span class="math inline">\(H(c)\to P(c) \lor Q(c) \qquad \qquad
US,5\)</span></li>
<li><span class="math inline">\(P(c) \lor Q(c) \qquad \qquad \qquad
\qquad T,3,6,I\)</span></li>
<li><span class="math inline">\(P(c) \qquad \quad \qquad \qquad
\qquad\qquad T,4,7,I\)</span></li>
<li><span class="math inline">\((\forall x)(H(x)\land R(x)\to \neg P(x))
\qquad P\)</span></li>
<li><span class="math inline">\(H(c)\land R(c)\to \neg P(c)\qquad \qquad
US,9\)</span></li>
<li><span class="math inline">\(\neg (H(c)\land R(c)) \qquad
\qquad\qquad T,8,10,I\)</span></li>
<li><span class="math inline">\(\neg H(c) \lor \neg R(c)
\qquad\qquad\qquad T,11,E\)</span></li>
<li><span class="math inline">\(\neg R(c) \qquad\qquad\qquad\qquad\qquad
T,3,12,I\)</span></li>
<li><span class="math inline">\(H(c)\land \neg R(c) \qquad\qquad\qquad
T,3,13,I\)</span></li>
<li><span class="math inline">\((\exists x) (H(x)\land \neg R(x))
\qquad\qquad EG, 14\)</span></li>
</ol>
<h2 id="关系代数">关系代数</h2>
<h3 id="证明关系">证明关系</h3>
<p>设 <span class="math inline">\(A=\{1,2,3,4\}\)</span>, 在 <span
class="math inline">\(P(A)\)</span> 上规定二元关系如下:</p>
<p><span class="math display">\[ R = \{ &lt;u,v&gt;|u,v\in P(A)
\land(|u|=|v|) \} \]</span></p>
<ol type="1">
<li>证明: <span class="math inline">\(R\)</span> 是 <span
class="math inline">\(P(A)\)</span> 上的等价关系.</li>
<li>写出商集 <span class="math inline">\(P(A) / R\)</span>.</li>
</ol>
<p><strong>解</strong> (1) 分别证明自反, 对称, 传递性.</p>
<ul>
<li>对于 <span class="math inline">\(\forall s \in P(A)\)</span>, <span
class="math inline">\(|s|=|s|\)</span>, 于是 <span
class="math inline">\(&lt;s,s&gt;\in R\)</span>, 自反性得证.</li>
<li>对于 <span class="math inline">\(\forall s, t \in P(A)\)</span>,
<span class="math inline">\(&lt;s,t&gt; \in R\)</span>, 显然 <span
class="math inline">\(|s|=|t|\)</span>, <span
class="math inline">\(|t|=|s|\)</span>, 于是 <span
class="math inline">\(&lt;s,t&gt;\in R, &lt;t,s&gt;\in R\)</span>,
对称性得证.</li>
<li>对于 <span class="math inline">\(\forall s,t,r\in P(A)\)</span>,
<span class="math inline">\(&lt;s,t&gt;\in R, &lt;t,r&gt;\in R\)</span>,
显然 <span class="math inline">\(|s|=|t|=|r|\)</span>, 于是有 <span
class="math inline">\(&lt;s,r&gt;\in R\)</span>, 传递性得证.</li>
</ul>
<p>因此 <span class="math inline">\(R\)</span> 是 <span
class="math inline">\(P(A)\)</span> 上的等价关系.</p>
<ol start="2" type="1">
<li><span class="math inline">\(P(A)=\{\{\varnothing
\},\{1\},\{1,2\},\{1,2,3\},\{1,2,3,4\}\}\)</span></li>
</ol>
<h3 id="闭包运算">闭包运算</h3>
<p>设 <span class="math inline">\(A = \{a, b, w+1,
\varnothing\}\)</span>, 定义 <span class="math inline">\(A\)</span>
上的二元关系</p>
<p><span class="math display">\[
R=\{&lt;a,b&gt;,&lt;b,w+1&gt;,&lt;w+1,\varnothing&gt;,&lt;\varnothing,a&gt;\}
\]</span></p>
<p>求: <span class="math inline">\(r(R), s(R)\)</span> 以及 <span
class="math inline">\(t(R)\)</span>.</p>
<p><strong>解</strong></p>
<p><span
class="math display">\[r(R)=\{&lt;a,b&gt;,&lt;b,w+1&gt;,&lt;w+1,\varnothing&gt;,&lt;\varnothing,a&gt;,&lt;a,a&gt;,&lt;b,b&gt;,&lt;w+1,w+1&gt;,&lt;\varnothing,\varnothing&gt;\}\]</span></p>
<p><span class="math display">\[
s(R)=\{&lt;a,b&gt;,&lt;b,w+1&gt;,&lt;w+1,\varnothing&gt;,&lt;\varnothing,a&gt;,
&lt;b,a&gt;, &lt;w+1,b&gt;, &lt;\varnothing,
w+1&gt;,&lt;a,\varnothing&gt;\} \]</span></p>
<p><span class="math inline">\(R\)</span> 的关系矩阵 <span
class="math inline">\(M_1=\begin{pmatrix}0&amp;1&amp;0&amp;0\\
0&amp;0&amp;1&amp;0\\ 0&amp;0&amp;0&amp;1\\
1&amp;0&amp;0&amp;0\end{pmatrix}\)</span></p>
<p><span class="math inline">\(t(R)\)</span> 的关系矩阵为 <span
class="math inline">\(M=M_1\vee M_2\vee M_3\vee
M_4=\begin{pmatrix}1&amp;1&amp;1&amp;1\\ 1&amp;1&amp;1&amp;1\\
1&amp;1&amp;1&amp;1\\ 1&amp;1&amp;1&amp;1\end{pmatrix}\)</span>, 于是
<span class="math inline">\(t(R)\)</span> 即为 <span
class="math inline">\(A\times A\)</span>.</p>
<h2 id="图论">图论</h2>
<h3 id="距离和连通性">距离和连通性</h3>
<p>设有向图 <span class="math inline">\(G=&lt;V,E&gt;\)</span>, <span
class="math inline">\(V=\{v_1,v_2,v_3, v_4\}\)</span>, 如下图所示,
回答:</p>
<figure>
<img src="/images/pic15.png" alt="图 G" />
<figcaption aria-hidden="true">图 G</figcaption>
</figure>
<ol type="1">
<li>长度为 <span class="math inline">\(3\)</span> 的路一共有几条?
其中回路有几条?</li>
<li>图论中, 哪类图的可达性矩阵一定是对称的? 计算 <span
class="math inline">\(G\)</span> 的可达性矩阵,
判断其是否是对称矩阵.</li>
</ol>
<p><strong>解</strong> (1) 图 <span class="math inline">\(G\)</span>
的邻接矩阵为</p>
<p><span
class="math display">\[\text{A}=\begin{pmatrix}1&amp;2&amp;0&amp;0\\
0&amp;0&amp;1&amp;0\\ 1&amp;0&amp;0&amp;1\\
0&amp;0&amp;1&amp;0\end{pmatrix}\]</span></p>
<p><span class="math display">\[A^2=\begin{pmatrix}1&amp;2&amp;2&amp;0\\
1&amp;0&amp;0&amp;1\\ 1&amp;2&amp;1&amp;0\\
1&amp;0&amp;0&amp;1\end{pmatrix}\mathrm{A}^3=\begin{pmatrix}3&amp;2&amp;2&amp;2\\
1&amp;2&amp;1&amp;0\\ 2&amp;2&amp;2&amp;1\\
1&amp;2&amp;1&amp;0\end{pmatrix},\mathrm{A}^4=\begin{pmatrix}5&amp;6&amp;4&amp;2\\
2&amp;2&amp;2&amp;1\\ 4&amp;4&amp;3&amp;2\\
2&amp;2&amp;2&amp;1\end{pmatrix}\]</span></p>
<p>于是 <span class="math inline">\(G\)</span> 中长度为 3 的通路有 24
条, 有 7 条回路.</p>
<ol start="2" type="1">
<li><span class="math inline">\(G\)</span> 可达矩阵为 <span
class="math inline">\(P=\begin{pmatrix}1&amp;1&amp;1&amp;1\\
1&amp;1&amp;1&amp;1\\ 1&amp;1&amp;1&amp;1\\
1&amp;1&amp;1&amp;1\end{pmatrix}\)</span>, 是一个对称矩阵.</li>
</ol>
<h3 id="证明题">证明题</h3>
<p>设 <span class="math inline">\(G\)</span> 是具有 <span
class="math inline">\(k (k \geqslant 2)\)</span> 个连通分支的平面图,
证明:</p>
<p><span class="math display">\[ n - m + r = k + 1 \]</span></p>
<p>其中 <span class="math inline">\(n,m,r\)</span> 分别为 <span
class="math inline">\(G\)</span> 的结点数, 边数和面数.</p>
]]></content>
      <categories>
        <category>离散数学</category>
      </categories>
      <tags>
        <tag>离散数学</tag>
        <tag>证明</tag>
      </tags>
  </entry>
  <entry>
    <title>杭电暑期训练</title>
    <url>/2023/07/19/%E6%9D%AD%E7%94%B5%E6%9A%91%E6%9C%9F%E8%AE%AD%E7%BB%83/</url>
    <content><![CDATA[<p>补点杭电暑期训练营的题目.</p>
<p>菜比不如去补点 CF 上的思维模拟题, 或者跟着闫总做题去. 给自己的任务:
做出签到题就是胜利. 银牌题怕是这辈子也做不出了. 8.22 就是 CCPC 的网络赛,
估计到时候要被川内其他学校薄纱.</p>
<span id="more"></span>
<h1 id="contest-1">Contest 1</h1>
<h2 id="assertion">1009 Assertion</h2>
<h3 id="题解">题解</h3>
<p>标签: 思维</p>
<p>签到题. 好像是鸽笼原理, 但不懂也能做.</p>
<h3 id="代码">代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, d;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; d;</span><br><span class="line">    <span class="type">int</span> res = (m - <span class="number">1</span>) / n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (res &gt;= d)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="cyclically-isomorphic">1005 Cyclically Isomorphic</h2>
<h3 id="题解-1">题解</h3>
<p>标签: 字符串哈希 双指针</p>
<p>题意: 给定 <span class="math inline">\(n\)</span> 个字符串 <span
class="math inline">\(s_i\)</span> (长度为 <span
class="math inline">\(m\)</span>, 且 <span
class="math inline">\(1\leqslant n\cdot m \leqslant 10^5\)</span>),
然后给出查询 <span class="math inline">\((x,y)\)</span>, 问 <span
class="math inline">\(s_x\)</span> 是否可以经过循环右移 (字符串旋转)
得到 <span class="math inline">\(s_y\)</span>.</p>
<p>字符串旋转的一个小技巧: 复制字符串</p>
<p>例如 <code>aab</code> 的全部旋转得到的对象
<code>aab, baa, aba</code>, 其实都是 <code>aabaab</code> 的字串.
同时一个好的性质是它们复制得到的新串经过hash映射结果是一样的.</p>
<p>计算 hash: 单 hash</p>
<p>这道题 KMP 和后缀数组也可以做.</p>
<h3 id="代码-1">代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">666623333</span>, N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> T, a[N];</span><br><span class="line"><span class="type">char</span> s[<span class="number">2</span> * N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, Q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; (s + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// Duplicate</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m + <span class="number">1</span>; j &lt;= m + m; j++)</span><br><span class="line">            s[j] = s[j - m];</span><br><span class="line">        <span class="type">int</span> I, J;</span><br><span class="line">        <span class="keyword">for</span> (I = <span class="number">1</span>, J = <span class="number">2</span>; J &lt;= m; J++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; m; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[I + k] &lt; s[J + k]) &#123;</span><br><span class="line">                    J += k;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (s[I + k] &gt; s[J + k]) &#123;</span><br><span class="line">                    <span class="type">int</span> tmp = I;</span><br><span class="line">                    I = J;</span><br><span class="line">                    J = <span class="built_in">max</span>(J, tmp + k);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算 Hash</span></span><br><span class="line">        a[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">            a[i] = (<span class="number">31ll</span> * a[i] + s[I + j] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; Q;</span><br><span class="line">    <span class="keyword">while</span> (Q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span> (a[x] == a[y])</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="city-upgrading">1002 City Upgrading</h2>
<h3 id="题解-2">题解</h3>
<p>标签: 树形dp</p>
<p>坑点: 数据有 <span class="math inline">\(n=1\)</span> 的情形,
但是题目里没讲...</p>
<p>题意: 给定一棵 <span class="math inline">\(n\)</span> 个节点的有权树,
选择一个节点可以覆盖其子节点, 问覆盖整棵树方案需要花费的最小值.</p>
<ul>
<li>状态表示:
<ul>
<li><span class="math inline">\(f(i,0)\)</span> 表示 <span
class="math inline">\(i\)</span> 节点未选择, <span
class="math inline">\(i\)</span> 也不被覆盖, 且 <span
class="math inline">\(i\)</span> 的子孙都被覆盖.</li>
<li><span class="math inline">\(f(i,1)\)</span> 表示 <span
class="math inline">\(i\)</span> 节点选择, 且 <span
class="math inline">\(i\)</span> 的子孙都被覆盖.</li>
<li><span class="math inline">\(f(i,2)\)</span> 表示 <span
class="math inline">\(i\)</span> 节点未选择, 但被它的子孙覆盖, 且 <span
class="math inline">\(i\)</span> 的子孙都被覆盖.</li>
</ul></li>
<li>属性: 最小代价</li>
<li>状态转移:
<ul>
<li><span class="math inline">\(F\)</span>: 考虑到子节点 <span
class="math inline">\(k\)</span> 更新后的 dp 值</li>
<li><span class="math inline">\(F(i,0)=f(i,0)+f(i,2)\)</span></li>
<li><span class="math inline">\(F(i,1)=\min \{f(i,0), f(k,1),
f(k,2)\}\)</span></li>
<li><span class="math inline">\(F(i,2)=\min
\{f(i,2)+\min\{f(k,1),f(k,2)\}, f(i,0)+f(k,1)\}\)</span></li>
</ul></li>
</ul>
<h3 id="代码-2">代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 1000005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 100000000000000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">E</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> to, nx;</span><br><span class="line">&#125; edge[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> tot, head[M];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Addedge</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[++tot].to = b;</span><br><span class="line">    edge[tot].nx = head[a];</span><br><span class="line">    head[a] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> dp[M][<span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> fa[M];</span><br><span class="line"><span class="type">int</span> A[M];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">long</span> <span class="type">long</span> &amp;x, <span class="type">long</span> <span class="type">long</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x += y;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= INF)</span><br><span class="line">        x = INF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dp[now][<span class="number">0</span>] = dp[now][<span class="number">1</span>] = dp[now][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[now][<span class="number">1</span>] = A[now];</span><br><span class="line">    dp[now][<span class="number">2</span>] = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[now]; i; i = edge[i].nx)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> nxt = edge[i].to;</span><br><span class="line">        <span class="keyword">if</span> (nxt == fa[now])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        fa[nxt] = now;</span><br><span class="line">        <span class="built_in">dfs</span>(nxt);</span><br><span class="line">        dp[now][<span class="number">2</span>] = <span class="built_in">min</span>(dp[now][<span class="number">2</span>] + <span class="built_in">min</span>(dp[nxt][<span class="number">1</span>], dp[nxt][<span class="number">2</span>]), dp[now][<span class="number">0</span>] + dp[nxt][<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">Add</span>(dp[now][<span class="number">1</span>], <span class="built_in">min</span>(dp[nxt][<span class="number">0</span>], <span class="built_in">min</span>(dp[nxt][<span class="number">1</span>], dp[nxt][<span class="number">2</span>])));</span><br><span class="line">        <span class="built_in">Add</span>(dp[now][<span class="number">0</span>], dp[nxt][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line">        tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            head[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;A[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a, b;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">            <span class="built_in">Addedge</span>(a, b);</span><br><span class="line">            <span class="built_in">Addedge</span>(b, a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="built_in">min</span>(dp[<span class="number">1</span>][<span class="number">1</span>], dp[<span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="easy-problem-i">1010 Easy problem I</h2>
<p>先吐槽下标题, 一点也不easy</p>
<p>标签: 线段树维护</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Max 200005</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree</span></span><br><span class="line">&#123;</span><br><span class="line">    ll lazy1, lazy2, lazy3, cnt, minn, sum1, sum2;</span><br><span class="line">&#125; st[Max * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> T, n, m, a[Max];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Tree <span class="title">up</span><span class="params">(Tree ls, Tree rs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Tree ans;</span><br><span class="line">    ans.lazy1 = ans.lazy3 = <span class="number">0</span>;</span><br><span class="line">    ans.lazy2 = <span class="number">1</span>;</span><br><span class="line">    ans.minn = <span class="built_in">min</span>(ls.minn, rs.minn);</span><br><span class="line">    ans.sum1 = ls.sum1 + rs.sum1;</span><br><span class="line">    ans.sum2 = ls.sum2 + rs.sum2;</span><br><span class="line">    ans.cnt = ls.cnt + rs.cnt;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> L, <span class="type">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ls = node &lt;&lt; <span class="number">1</span>, rs = node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    st[ls].lazy3 += st[node].lazy3;</span><br><span class="line">    st[rs].lazy3 += st[node].lazy3;</span><br><span class="line">    st[ls].sum1 -= st[node].lazy3 * st[ls].cnt;</span><br><span class="line">    st[rs].sum1 -= st[node].lazy3 * st[rs].cnt;</span><br><span class="line">    st[ls].minn -= st[node].lazy3;</span><br><span class="line">    st[rs].minn -= st[node].lazy3;</span><br><span class="line"></span><br><span class="line">    st[ls].lazy1 = st[node].lazy1 + st[ls].lazy1 * st[node].lazy2;</span><br><span class="line">    st[rs].lazy1 = st[node].lazy1 + st[rs].lazy1 * st[node].lazy2;</span><br><span class="line">    st[ls].lazy2 *= st[node].lazy2;</span><br><span class="line">    st[rs].lazy2 *= st[node].lazy2;</span><br><span class="line">    st[ls].sum2 = st[node].lazy1 * (mid - L + <span class="number">1</span> - st[ls].cnt) + st[ls].sum2 * st[node].lazy2;</span><br><span class="line">    st[rs].sum2 = st[node].lazy1 * (R - mid - st[rs].cnt) + st[rs].sum2 * st[node].lazy2;</span><br><span class="line">    st[node].lazy1 = st[node].lazy3 = <span class="number">0</span>;</span><br><span class="line">    st[node].lazy2 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> L, <span class="type">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R)</span><br><span class="line">    &#123;</span><br><span class="line">        st[node].lazy1 = st[node].lazy3 = <span class="number">0</span>;</span><br><span class="line">        st[node].lazy2 = <span class="number">1</span>;</span><br><span class="line">        st[node].minn = st[node].sum1 = a[L];</span><br><span class="line">        st[node].sum2 = <span class="number">0</span>;</span><br><span class="line">        st[node].cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(node &lt;&lt; <span class="number">1</span>, L, mid);</span><br><span class="line">    <span class="built_in">build</span>(node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, R);</span><br><span class="line">    st[node] = <span class="built_in">up</span>(st[node &lt;&lt; <span class="number">1</span>], st[node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &gt;= l &amp;&amp; R &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (st[node].cnt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (L == R)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (st[node].sum1 &lt; k)</span><br><span class="line">                &#123;</span><br><span class="line">                    st[node].sum2 = k - st[node].sum1;</span><br><span class="line">                    st[node].sum1 = st[node].cnt = <span class="number">0</span>;</span><br><span class="line">                    st[node].minn = <span class="number">1e18</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    st[node].minn = st[node].sum1 = st[node].sum1 - k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (st[node].minn &lt; k)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">down</span>(node, L, R);</span><br><span class="line">                    <span class="type">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                    <span class="built_in">change</span>(node &lt;&lt; <span class="number">1</span>, l, r, L, mid, k);</span><br><span class="line">                    <span class="built_in">change</span>(node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, mid + <span class="number">1</span>, R, k);</span><br><span class="line">                    st[node] = <span class="built_in">up</span>(st[node &lt;&lt; <span class="number">1</span>], st[node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    st[node].lazy3 += k;</span><br><span class="line">                    st[node].minn -= k;</span><br><span class="line">                    st[node].sum1 -= <span class="number">1ll</span> * k * st[node].cnt;</span><br><span class="line">                    st[node].lazy1 = k - st[node].lazy1;</span><br><span class="line">                    st[node].lazy2 *= <span class="number">-1</span>;</span><br><span class="line">                    st[node].sum2 = <span class="number">1ll</span> * k * (R - L + <span class="number">1</span> - st[node].cnt) - st[node].sum2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            st[node].lazy1 = k - st[node].lazy1;</span><br><span class="line">            st[node].lazy2 *= <span class="number">-1</span>;</span><br><span class="line">            st[node].sum2 = <span class="number">1ll</span> * k * (R - L + <span class="number">1</span>) - st[node].sum2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//        cout&lt;&lt;L&lt;&lt;&quot; &quot;&lt;&lt;R&lt;&lt;&quot; &quot;&lt;&lt;st[node].sum1&lt;&lt;&quot; &quot;&lt;&lt;st[node].sum2&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">down</span>(node, L, R);</span><br><span class="line">    <span class="type">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid)</span><br><span class="line">        <span class="built_in">change</span>(node &lt;&lt; <span class="number">1</span>, l, r, L, mid, k);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid)</span><br><span class="line">        <span class="built_in">change</span>(node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, mid + <span class="number">1</span>, R, k);</span><br><span class="line">    st[node] = <span class="built_in">up</span>(st[node &lt;&lt; <span class="number">1</span>], st[node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Tree <span class="title">query</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &gt;= l &amp;&amp; R &lt;= r)</span><br><span class="line">        <span class="keyword">return</span> st[node];</span><br><span class="line">    <span class="built_in">down</span>(node, L, R);</span><br><span class="line">    <span class="type">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (r &lt;= mid)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(node &lt;&lt; <span class="number">1</span>, l, r, L, mid);</span><br><span class="line">    <span class="keyword">if</span> (l &gt; mid)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, mid + <span class="number">1</span>, R);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">up</span>(<span class="built_in">query</span>(node &lt;&lt; <span class="number">1</span>, l, r, L, mid), <span class="built_in">query</span>(node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, mid + <span class="number">1</span>, R));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> opt;</span><br><span class="line">            cin &gt;&gt; opt;</span><br><span class="line">            <span class="keyword">if</span> (opt == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> l, r, x;</span><br><span class="line">                cin &gt;&gt; l &gt;&gt; r &gt;&gt; x;</span><br><span class="line">                <span class="built_in">change</span>(<span class="number">1</span>, l, r, <span class="number">1</span>, n, x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> l, r;</span><br><span class="line">                cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">                Tree ans = <span class="built_in">query</span>(<span class="number">1</span>, l, r, <span class="number">1</span>, n);</span><br><span class="line">                cout &lt;&lt; ans.sum1 + ans.sum2 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="contest-2">Contest 2</h1>
<p>只切了一道数学题.</p>
<p>做不动了. 立即推放弃</p>
<h2 id="string-problem">1009 String Problem</h2>
<p>题面: 多例输入, 给定 <span class="math inline">\(n\)</span>
长的字符串 <span class="math inline">\(s\)</span>, 选择 <span
class="math inline">\(k\)</span> 个非空, 互文, 不相交字串 <span
class="math inline">\(s_i\)</span>, <span
class="math inline">\(s_i\)</span> 包含至多一种字符, 求 <span
class="math inline">\(\max \{\sum
\operatorname{len}(s_i)-k\}\)</span>.</p>
<p>样例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">etxabaxtezwkdwokdbbb</span><br><span class="line">aaaaa</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<h3 id="题解-3">题解</h3>
<p>签到题, 队友切了</p>
<p>将字符串拆成尽可能少的段, 每段只包含一种字符, 每段对答案贡献减一</p>
<h3 id="代码-3">代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">666623333</span>, N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    vector&lt;pair&lt;<span class="type">char</span>, <span class="type">int</span>&gt;&gt; v;</span><br><span class="line">    v.<span class="built_in">push_back</span>(&#123;s[<span class="number">1</span>], <span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == v.<span class="built_in">back</span>().first)</span><br><span class="line">            ++v.<span class="built_in">back</span>().second;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            v.<span class="built_in">push_back</span>(&#123;s[i], <span class="number">1</span>&#125;);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [x, y] : v)</span><br><span class="line">        ans += y - <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="contest-3">Contest 3</h1>
<p>坐牢</p>
<h2 id="bit-zoom">1011 8-bit Zoom</h2>
<p>标签: 模拟</p>
<p>题意: 给定一个 <span class="math inline">\(n\times n\)</span> (<span
class="math inline">\(1\leqslant n\leqslant 50\)</span>)的图像,
用字符串模拟, 输出放大 <span class="math inline">\(Z \%\)</span>(<span
class="math inline">\(100\leqslant Z\leqslant 200\)</span>, <span
class="math inline">\(Z \bmod 25 = 0\)</span>) 倍. 最终图像的大小为
<span
class="math inline">\(\frac{nZ}{100}\times\frac{nZ}{100}\)</span>.</p>
<p>图像在以下两种情况下不能放大:</p>
<ul>
<li>当 <span class="math inline">\(\frac{nZ}{100}\)</span>
不为整数时</li>
<li>图像放大后, 有些像素点无法确定.
如果至少有两个不同的颜色映射到同一个像素点,
那么这个像素点的颜色就无法确定.</li>
</ul>
<p>多例输入, 第一行包含 <span class="math inline">\(n\)</span> 和 <span
class="math inline">\(Z\)</span>, 然后 <span
class="math inline">\(n\)</span> 行, 每一行是长度为 <span
class="math inline">\(n\)</span> 的字符串, 每个字符都是英文小写字符, 第
<span class="math inline">\(i\)</span> 行的第 <span
class="math inline">\(j\)</span> 个字符表示原图像中的 <span
class="math inline">\((i,j)\)</span> 像素点的颜色.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">2 100</span><br><span class="line">ab</span><br><span class="line">cd</span><br><span class="line">2 200</span><br><span class="line">ab</span><br><span class="line">cd</span><br><span class="line">2 125</span><br><span class="line">aa</span><br><span class="line">aa</span><br><span class="line">4 125</span><br><span class="line">aaab</span><br><span class="line">aaaa</span><br><span class="line">aaaa</span><br><span class="line">aaaa</span><br><span class="line">4 125</span><br><span class="line">aaaa</span><br><span class="line">aaaa</span><br><span class="line">aaaa</span><br><span class="line">aaaa</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ab</span><br><span class="line">cd</span><br><span class="line">aabb</span><br><span class="line">aabb</span><br><span class="line">ccdd</span><br><span class="line">ccdd</span><br><span class="line">error</span><br><span class="line">error</span><br><span class="line">aaaaa</span><br><span class="line">aaaaa</span><br><span class="line">aaaaa</span><br><span class="line">aaaaa</span><br><span class="line">aaaaa</span><br></pre></td></tr></table></figure>
<h3 id="题解-4">题解</h3>
<p>主要是放大的逻辑不太好写. 例如 aaab 放大 1.25 倍的这个案例.
主要恶心的是这个小数.</p>
<p>避免小数的出现, 我们把图像放大到 <span class="math inline">\(Z /
25\)</span> 倍, 然后以 <span class="math inline">\(4\)</span>
为步长去读取即可.</p>
<p>例如 a 放大两倍就变成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aaaaaaaa</span><br><span class="line">aaaaaaaa</span><br><span class="line">...</span><br><span class="line">aaaaaaaa</span><br></pre></td></tr></table></figure>
<p>以4为步长, 那么</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aa</span><br><span class="line">aa</span><br></pre></td></tr></table></figure>
<p>怎么判断放大后某一个像素点存在至少两个不同的颜色?</p>
<p>例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aaab</span><br><span class="line">aaaa</span><br></pre></td></tr></table></figure>
<p>放大倍率为 125%, 它就不合法. 为什么(?)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aaaa aaaa aaaa aaab bbbb</span><br><span class="line">aaaa aaaa aaaa aaab bbbb</span><br><span class="line">aaaa aaaa aaaa aaab bbbb</span><br><span class="line">aaaa aaaa aaaa aaab bbbb</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>步长为 4 读取, a a a a b, 你会发现第四个像素点有两种颜色!
我们要做的就是把这种情况作为异常处理.</p>
<h3 id="代码-4">代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">55</span>;</span><br><span class="line"><span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> a[N][N], b[N * <span class="number">8</span>][N * <span class="number">8</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, Z;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;Z);</span><br><span class="line">    <span class="keyword">if</span> (n * Z / <span class="number">25</span> % <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, a[i]);</span><br><span class="line">        <span class="type">int</span> rate = Z / <span class="number">25</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> xl = i * rate, xr = xl + rate;</span><br><span class="line">                <span class="type">int</span> yl = j * rate, yr = yl + rate;</span><br><span class="line">                <span class="type">char</span> w = a[i][j];</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> A = xl; A &lt; xr; A++)</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> B = yl; B &lt; yr; B++)</span><br><span class="line">                        b[A][B] = w;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> m = n * rate;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i += <span class="number">4</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j += <span class="number">4</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">char</span> w = b[i][j];</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> A = i; A &lt; i + <span class="number">4</span>; A++)</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> B = j; B &lt; j + <span class="number">4</span>; B++)</span><br><span class="line">                        <span class="keyword">if</span> (b[A][B] != w)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="built_in">puts</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i += <span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j += <span class="number">4</span>)</span><br><span class="line">                <span class="built_in">putchar</span>(b[i][j]);</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="out-of-control">1005 Out of Control</h2>
<p>标签: 排序 前缀和 离散化</p>
<p>挺有实际意义的一个问题</p>
<p>题意: 多例输入 <span class="math inline">\(T\leqslant 100\)</span>,
<span class="math inline">\(n\)</span> 个($ 1n $)整数 <span
class="math inline">\(x_i(1\leqslant x_i \leqslant 10^9)\)</span>,
维护栈单调递增, 输出栈长固定时所有单调栈的数量, 结果对 <span
class="math inline">\(10^9+7\)</span> 取模.</p>
<p>样例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">1 2 3</span><br><span class="line">3</span><br><span class="line">2 3 3</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">5</span><br><span class="line">5</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<h3 id="题解-5">题解</h3>
<h3 id="代码-5">代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>, N = <span class="number">3e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ans, sum;</span><br><span class="line"><span class="type">int</span> a[N], b[N], f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a = (a + b &lt; MOD) ? a + b : a + b - MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        b[i] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(b + <span class="number">1</span>, b + n + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">1</span> || b[i] &gt; b[i - <span class="number">1</span>])</span><br><span class="line">            b[++m] = b[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        a[i] = <span class="built_in">lower_bound</span>(b + <span class="number">1</span>, b + m + <span class="number">1</span>, a[i]) - b;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        f[i] = <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; m &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum = ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = a[i - <span class="number">1</span>]; j &lt; a[i]; j++)</span><br><span class="line">            <span class="built_in">up</span>(sum, f[j]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = a[i]; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">up</span>(sum, f[j]);</span><br><span class="line">            f[j] = sum;</span><br><span class="line">            <span class="built_in">up</span>(ans, sum);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="contest-4">Contest 4</h1>
<p>只做了两题. 罚时有点狠的.</p>
<h2 id="a-b-problem">1012 a-b Problem</h2>
<p>标签: 思维</p>
<p>题面: Alice 和 Bob 轮流取石子, Alice 先手, 石头有 <span
class="math inline">\(A_i\)</span> 和 <span
class="math inline">\(B_i\)</span> 的分数, 分别对应两个人取石子的加分.
两个人都想赢, 同时想要让分差最大. 求最后俩人的分差.</p>
<p>多例输入, 每个例子中, 第一行是 <span
class="math inline">\(n\)</span>, 接下来 <span
class="math inline">\(n\)</span> 行每一行是 <span
class="math inline">\(A_i, B_i\)</span>.</p>
<p>取石子是不需要按石子的顺序取的.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">230</span><br><span class="line">2</span><br><span class="line">1 2</span><br><span class="line">3 3</span><br><span class="line">31</span><br><span class="line">0</span><br><span class="line">2 3</span><br><span class="line">0 4</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">-1</span><br></pre></td></tr></table></figure>
<h3 id="题解-6">题解</h3>
<p>如果贪心取最大这是有问题的, 因为你还需要博弈考虑 Bob 的取法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 0</span><br><span class="line">1 10000</span><br></pre></td></tr></table></figure>
<p>我们可以考虑转换问题. 假如一开始石子都在 Bob 手里, 那么 Alice 取石子,
它可以获得 <span class="math inline">\(A_i + B_i\)</span> 的分数差. 对于
Bob 来说, 他要做的是把这些可以拉大分差的石子藏起来.
这样和原问题是等价的.</p>
<p>于是逻辑就很简单了: 对 <span class="math inline">\(A_i + B_i\)</span>
排序下然后按顺序取就完了.</p>
<h3 id="代码-6">代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Z</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="type">int</span> <span class="keyword">operator</span>&lt;(Z o) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b &gt; o.a + o.b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Z z[<span class="number">100001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;z[i].a, &amp;z[i].b);</span><br><span class="line">        std::<span class="built_in">sort</span>(z, z + n);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &amp; <span class="number">1</span>)</span><br><span class="line">                sum -= z[i].b;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                sum += z[i].a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="contest-5">Contest 5</h1>
<p>没空打</p>
<h2 id="counting-stars">1012 Counting Stars</h2>
<p>题意: 定义 <span class="math inline">\(k\)</span> 星为 <span
class="math inline">\(k+1\)</span> 个顶点和 <span
class="math inline">\(k\)</span> 条边的连通无向图, 满足 <span
class="math inline">\(k\)</span> 条边连接着同一个点. 问: 给定一个无向图
<span class="math inline">\(n\)</span> 顶点和 <span
class="math inline">\(m\)</span> 条边, 输出所有 <span
class="math inline">\(k\)</span> 星图(<span
class="math inline">\(\forall k\in[2,n-1]\)</span>)的数量.</p>
<p>答案很大, 每次得到的 <span class="math inline">\(k\)</span> 星数量
<span class="math inline">\(cnt_{i}\)</span> 需要先对 <span
class="math inline">\(10^9+7\)</span> 取模, 然后求 <span
class="math inline">\(cnt_2 \oplus cnt_3 \dots \oplus
cnt_k\)</span>.</p>
<h3 id="题解-7">题解</h3>
<p>计算每个节点的度, 显然 <span class="math inline">\(n\)</span> 度的
<span class="math inline">\(k\)</span> 星有 <span
class="math inline">\(\binom{n}{k}\)</span> 个. 我们计算每个节点对 <span
class="math inline">\(k\)</span> 图的贡献.</p>
<p>组合数要优先预处理. 阶乘打表. 组合数要怎么生成?</p>
<p>我们知道</p>
<p><span class="math display">\[\binom{n}{m} =
\frac{n!}{(n-m)!m!}\]</span></p>
<p>数字大了以后不考虑除法. 因为我们已经对阶乘取过模了. 所以,
这里需要计算的是阶乘逆元. 计算逆元可以用快速幂(费马小定理).
当然你可以只计算最后一个, 之前的可以递推</p>
<p><span class="math display">\[(n-1)! n \cdot x \equiv 1 \qquad (x =
(n!)^{-1})\]</span></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>保研, 相亲, 找工作——背后的稳定匹配问题</title>
    <url>/2023/02/06/%E7%A8%B3%E5%AE%9A%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98%E5%8F%8AGale-Shapley%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p><strong>稳定匹配问题</strong>(Stable Matching Problem)最早出自 D.Gale
和 L.S.Sharpley
1962年发表在美国数学月刊上的一篇关于<em>大学录取和婚姻稳定</em>的文章<a
href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a>. 解决这个问题的算法出奇地简单,
甚至是<strong>自我执行</strong>(self-forcing)的——换言之,
不需要系统的调度, 就能获得令人满意的结果!</p>
<p>本文重点陈述算法的正确性——作为离散数学中<em>逻辑命题与证明</em>的简单应用.</p>
<span id="more"></span>
<h2 id="问题描述">问题描述</h2>
<p>问题描述: 考虑你经营一家雇佣系统, 任务将 <span
class="math inline">\(n\)</span> 个职位和 <span
class="math inline">\(n\)</span> 名候选人匹配起来. 每项工作对 <span
class="math inline">\(n\)</span> 名候选人有一排序的倾向表,
每位候选人也有类似的表.</p>
<p>例如, 考虑 <span class="math inline">\(n=3\)</span>, 为简化,
我们假设候选人为 A, B, C, 岗位为 1, 2, 3. 对于 A, 他的倾向表为 2, 1, 3,
表示最希望分配到2, 1次之, 3最后. 同样的, 岗位1选人的倾向表为 A, C, B,
表示最希望招到 A, C次之, B最后.</p>
<p>我们的目标是: 最大化总满足度, 最大化每个人的第一选择,
以及减少倾向排名的差距</p>
<p>Gale-Shapley 算法 (a.k.a. The Propose-and-Reject Algorithm)</p>
<p>对于每一天:</p>
<ul>
<li>每个职位向它列表上最希望的候选人发offer.</li>
<li>每个候选人都可以拒绝非自己最期望的offer.
已得的offer会置于一个string上.</li>
<li>被拒绝的职位会在表上划去拒绝人的名字.</li>
</ul>
<p>当每个人都拿到offer的时候, 程序停止.</p>
<figure>
<img src="/images/anim1.gif" alt="例子" />
<figcaption aria-hidden="true">例子</figcaption>
</figure>
<h2 id="before-符号定义">Before: 符号定义</h2>
<p><strong>定义 1</strong> 包含 <span class="math inline">\(n\)</span>
对 pair 的不交集, 称为<strong>匹配</strong> <span
class="math inline">\(S\)</span>.</p>
<p>例如: <span class="math inline">\(S = \{(1, A), (2, B), (3,
C)\}\)</span> 就是一个包含 <span class="math inline">\(3\)</span> 对
pair 的匹配.</p>
<p><strong>定义 2</strong> 如果 <span class="math inline">\(b\)</span>
比起 <span class="math inline">\(g\)</span> 更喜欢 <span
class="math inline">\(g^{*}\)</span>, 记 <span
class="math inline">\(g^{*} &gt; g\)</span>. 特别地, 如果 <span
class="math inline">\(b\)</span> 认为 <span
class="math inline">\(g^{*}\)</span> 至少和 <span
class="math inline">\(g\)</span> 一样好, 记 <span
class="math inline">\(g^{*} \geqslant g\)</span>, 当且仅当 <span
class="math inline">\(g^{*} = g\)</span> 取等.</p>
<p><strong>定义 3</strong> 对于匹配 <span
class="math inline">\(S\)</span> 中的元素 <span class="math inline">\(b,
g^{*}\)</span>: 如果 <span class="math inline">\(b, g^{*}\)</span>
是比当前 partner 更优的一对, 则称 <span class="math inline">\(b,
g^{*}\)</span> 为一对<strong>rouge couple</strong>.</p>
<p>例如: 假设对 <span class="math inline">\(1\)</span> 有 <span
class="math inline">\(C&gt;B\)</span>, <span
class="math inline">\(C\)</span> 认为 <span
class="math inline">\(1&gt;2\)</span>, 那么匹配 <span
class="math inline">\(S = \{(1, B), (2, C)\}\)</span> 中存在 rouge
couple <span class="math inline">\(1, C\)</span>.</p>
<p><strong>定义 4</strong> 不存在 rouge couple 的匹配 <span
class="math inline">\(S\)</span> 称为<strong>稳定匹配</strong>.
否则则为不稳定匹配.</p>
<p>在上面的例子中: 因为 <span class="math inline">\(1\)</span> 可以追求
<span class="math inline">\(C\)</span>, 同时 <span
class="math inline">\(C\)</span> 也会欣然接受 <span
class="math inline">\(1\)</span>, <span
class="math inline">\((1,B)\)</span> 及 <span
class="math inline">\((2,C)\)</span> 都有决裂的可能, 因此 <span
class="math inline">\(S\)</span> 是一个不稳定匹配.</p>
<h2 id="证明">证明</h2>
<h3 id="总能停下">总能停下</h3>
<p><strong>引理 1</strong> 算法总能停下.</p>
<p><strong>证明</strong> 算法尚未停止时,
每一天结束至少有一家公司将应聘者的人名从列表上划去. 因为列表有 <span
class="math inline">\(n\)</span> 份, 每份上有 <span
class="math inline">\(n\)</span> 个元素, 因此算法至多在 <span
class="math inline">\(n^2\)</span> 的迭代(天)下终止.</p>
<h3 id="进步引理">进步引理</h3>
<p><strong>引理 2</strong> 对于第 <span class="math inline">\(t\)</span>
天, 候选人 <span class="math inline">\(g\)</span> 手上有职位 <span
class="math inline">\(b\)</span>, 那么第 <span
class="math inline">\(t&#39;\)</span> 天结束, 他手上的 <span
class="math inline">\(\forall b&#39;\)</span> 至少和 <span
class="math inline">\(b\)</span> 一样好, 其中 <span
class="math inline">\(t&#39; &gt; t\)</span>.</p>
<p><strong>证明</strong> 我们对天数 <span
class="math inline">\(i\geqslant k\)</span> 归纳.</p>
<p>当 <span class="math inline">\(i = k\)</span>, <span
class="math inline">\(C\)</span> <em>可以</em>收到至少一份offer(来自
<span class="math inline">\(J\)</span>). 在第 <span
class="math inline">\(k\)</span> 天结束, <span
class="math inline">\(C\)</span> 手上至少会有 <span
class="math inline">\(J\)</span> 或者比 <span
class="math inline">\(J\)</span> 更好的offer(他可以自行选择).</p>
<p>对于 <span class="math inline">\(\forall i \geqslant k\)</span>
的情况, 假设命题成立, 只需归纳证明对 <span
class="math inline">\(i+1\)</span> 命题同样成立.</p>
<p>根据我们的假设, 第 <span class="math inline">\(i\)</span> 天 <span
class="math inline">\(C\)</span> 获得了 <span
class="math inline">\(J&#39;\geqslant J\)</span>, 根据算法, <span
class="math inline">\(J&#39;\)</span> 在第 <span
class="math inline">\(i+1\)</span> 天依然会向 <span
class="math inline">\(C\)</span> 给出offer(因为 <span
class="math inline">\(C\)</span> 在第 <span
class="math inline">\(i\)</span> 天没理由拒绝或者 <span
class="math inline">\(J&#39;\)</span> 凭空消失). 因此当第 <span
class="math inline">\(i+1\)</span> 天结束, <span
class="math inline">\(C\)</span> 手上要么是 <span
class="math inline">\(J&#39;\)</span>, 要么是比 <span
class="math inline">\(J&#39;\)</span> 更好的offer; 两种情况都 <span
class="math inline">\(\geqslant J\)</span>, 因此结论对第 <span
class="math inline">\(i+1\)</span> 天成立.</p>
<h3 id="正确性">正确性</h3>
<p><strong>引理 3</strong> Gale-Sharpley算法得出的匹配不存在rouge
couple.</p>
<p><strong>证明</strong> 反证法. 假设存在 <span
class="math inline">\((b,g^{*})\)</span>, 且当前匹配为 <span
class="math inline">\((b,g),(b^{*},g^{*})\)</span>. <span
class="math inline">\(b\)</span> 比起 <span
class="math inline">\(g\)</span> 更喜欢 <span
class="math inline">\(g*\)</span>, 在给 <span
class="math inline">\(g\)</span> 发出offer之前先给 <span
class="math inline">\(g^{*}\)</span> 发出了offer, 而 <span
class="math inline">\(g^{*}\)</span> 拒绝了 <span
class="math inline">\(b\)</span>, 由引理 2, 知 <span
class="math inline">\(g^{*}\)</span> 比起 <span
class="math inline">\(b^{*}\)</span> 更喜欢 <span
class="math inline">\(b\)</span>, 与条件矛盾.</p>
<p><strong>定理 1</strong> Gale-Sharpley 算法是一种稳定的匹配算法.</p>
<p><strong>证明</strong> 由引理 1 和引理 3 可知其正确.</p>
<h3 id="最优性-对谁更有利">最优性: 对谁更有利?</h3>
<p><strong>定义 5</strong> 如果 <span class="math inline">\(x\)</span>
的 partner 在任何稳定匹配下皆为它的最佳 partner, 称匹配为 <span
class="math inline">\(x\)</span> 最优的.</p>
<p>同样可以给出 <span class="math inline">\(x\)</span> 最劣的定义.</p>
<p><strong>定义 6</strong> 如果对全部工作/候选人 <span
class="math inline">\(x\)</span> 都是 <span
class="math inline">\(x\)</span> 最优的, 称匹配为工作/候选人最优.</p>
<p>例子: A:1,2 B:2,1 1:A,B 2:A,B</p>
<p>S: (A,1) (B,2) T: (A,2) (B,1)</p>
<p>S, T 都是稳定的. 但 S 是对 A,B 最优, T 对 1,2 最优.</p>
<p><strong>定理 2</strong> Gale-Sharpley算法是工作最优匹配.</p>
<p><strong>证明</strong> 假设匹配对工作不是最优的: 存在 <span
class="math inline">\(b\)</span> 得不到最优候选人 <span
class="math inline">\(g\)</span>. 存在稳定匹配 <span
class="math inline">\(S\)</span> 存在 <span
class="math inline">\((b,g)\)</span> 匹配. 令 <span
class="math inline">\(t\)</span> 为 <span
class="math inline">\(b\)</span> 被 <span
class="math inline">\(g\)</span> 拒绝的第一天, 那么在第 <span
class="math inline">\(t\)</span> 日有 <span
class="math inline">\(b^{*}\)</span> 与 <span
class="math inline">\(g\)</span> 匹配, 也就意味着 <span
class="math inline">\(g\)</span> 比起 <span
class="math inline">\(b\)</span> 更喜欢 <span
class="math inline">\(b^{*}\)</span>. <span
class="math inline">\(b^{*}\)</span> 至少也会将 <span
class="math inline">\(g\)</span> 作为它的最优候选人看待, 也就推出了"
<span class="math inline">\(b^{*}\)</span> 比起他在 <span
class="math inline">\(S\)</span> 中的 partner <span
class="math inline">\(g^{*}\)</span> 更喜欢 <span
class="math inline">\(g\)</span> "的结论, 而 <span
class="math inline">\(b,g^{*}\)</span> 是一对rogue couple, 也即 <span
class="math inline">\(S\)</span> 是不稳定的, 也就发生了矛盾.</p>
<h2 id="后记">后记</h2>
<p>TODO List:</p>
<ul>
<li>Talk is cheap, show me the code!
<ul>
<li>哪天写一个示例程序</li>
</ul></li>
<li>可读性很烂, 加上纯数更难理解了.
<ul>
<li>哪天重构下段落和语句</li>
</ul></li>
<li>想把证明方法背后的数学原理介绍给各位
<ul>
<li>例如反证法在数理逻辑上为什么是正确的</li>
</ul></li>
<li>现在还只停留在介绍的阶段.
<ul>
<li>推荐读物里有本书, 哪天有空去找找看, 提取一些有意思的内容</li>
<li>多些深度和应用</li>
</ul></li>
</ul>
<h2 id="拓展阅读">拓展阅读</h2>
<p>[1]. <a href="https://www.eecs70.org/assets/pdf/notes/n4.pdf">UCB
CS70 Note 4: Stable Matching Problem</a></p>
<p>[2]. D. Gale and L.S. Shapley, “College Admissions and the Stability
of Marriage,” <em>American Mathematical Monthly</em> <strong>69</strong>
(1962), pp. 9–14.</p>
<p>[3]. D. Gusfield and R.W. Irving, <em>The Stable Marriage Problem:
Structure and Algorithms</em>, MIT Press, 1989.</p>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>Matching领域的开山文章, 算法分析的伟大成就之一, 顺带一提
Sharpley 也是<a
href="https://news.yahoo.com/2-americans-win-nobel-economics-prize-111239568--finance.html">2012年诺贝尔经济学奖</a>的得主.
题外话: 在文章的最后, 作者提到希望借此文章改变大众对数学/数学家的认知:
我们真的不是只懂"一堆公式", 不说人话的家伙;
还希望数学老师也能启发启发学生 :)<a href="#fnref1" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>离散数学</tag>
      </tags>
  </entry>
  <entry>
    <title>新冠生存手册</title>
    <url>/2022/12/22/%E6%96%B0%E5%86%A0%E7%94%9F%E5%AD%98%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<p>感染新冠快成每日打卡项目了. 每天都能刷到同学感染的信息,
"今天又发了39度的烧"——然而这并不是值得炫耀的一件事. 二阳化碳, 三阳开泰,
四阳方尊, 五阳电动车, 六阳魁首, 七阳化二锰, 八阳化二硫, 九阳豆浆机
如果能在全员感染的范围内存活下来, 那么你就是大赢.
我不相信染病后没有后遗症, 就算苟我也要撑到群体免疫快结束的时候.
提心吊胆地过着放开后的日子, 保持身处末世一般的警惕,
做好保护自己生命的职责.</p>
<p>更新: 12.28 阳了 估计是舍友交叉感染的 Q:
有个一声不吭的舍友是怎样的一种感受? 被害惨了.</p>
<span id="more"></span>
<p><a href="https://zhuanlan.zhihu.com/p/579970078">知乎回答</a></p>
<p>气溶胶传染主要是通过呼吸道, 病毒接触皮肤表面只要不接触口鼻眼,
之后消毒或清洁就行</p>
<h2 id="防护方式">防护方式</h2>
<p>谨防交叉感染! 自己防护做全了,
也要<strong>确保</strong>家里人/舍友能够执行.</p>
<p>回答来源于<a
href="https://www.zhihu.com/question/570483700/answer/2796072947">知乎</a>:</p>
<p>下水道消毒: 加盖加水防止气溶胶产生</p>
<p>衣服消毒: 衣用消毒剂 紫外线灯 酒精喷雾</p>
<p>室外消毒: 消毒凝胶 酒精喷雾随身携带</p>
<p>口罩: 能不摘就不摘 医用4小时一换 N95/FFP2一天一换+备用 不放在口袋
不要吝啬</p>
<p>吃饭: 明确堂食必G</p>
<p>头发消毒: 洗头洗澡</p>
<p>外出装备: N95戴+备用 塑料面罩(防疫人员戴的) 装有消毒液的小喷壶</p>
<h3 id="戴口罩的误区">戴口罩的误区</h3>
<p><a
href="https://www.zhihu.com/question/573023186/answer/2814221461">知乎:为什么全国人民都佩戴N95口罩后，新冠病毒还能爆发式传播？</a></p>
<h2 id="感染后的感觉">感染后的感觉</h2>
<p>感染前一天晚上: 好热 不太好睡 喉咙好干 半夜爬下去喝水</p>
<p>第一天: 早上高数考试 考完感觉人没啥力气 联想到舍友咳嗽的事情
中午吃完饭就去校医院 测了体温38.3度 抗原检测一开始看不到T线
过了几分钟看到浅浅的一条线 G了 开了退烧药和银黄颗粒
回了一趟寝室叫室友去校医院治治咳嗽 但他好像已经阳康了😅
下午开始就在床上度过了极为痛苦的一天 乏力 体温不均 晚上测了体温39度
吃了退烧药 稍微好些 这一晚非常痛苦 一开始冷的睡不着 套上了几件衣服
半夜又被热醒了</p>
<p>第二天: 依然乏力 体温依然是39度 疯狂喝水 一天去了不知道多少次厕所
吃了退烧药 今天比昨天好很多 但依然很难受 晚上买了饭 结果一口也吃不下去
鸡蛋是苦的 萝卜是苦的 啥都是苦的 10块钱浪费了 这一天解决了论文框架</p>
<p>第三天: 今天退烧了 开始有能力在电脑前产出了 今天把论文写完了
但喉咙巨难受 所谓的口吞刀片 腊八 吃了免费的腊八粥 晚饭吃原汤抄手
事实上这几天只适合吃这些</p>
<p>第四天: 今天也没发烧 但喉咙依然很痛 胃口已经要比前几天好了
生产力基本恢复正常 今天ddl 改完论文提交了 该接着复习考试了</p>
<p>第五天开始: 基本上正常 除了喉咙痛 吃不了辣 基本上啥都能干了</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>简单的数据结构</title>
    <url>/2023/02/25/%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>做一个数据结构的小小总结. 其实数据结构和算法是不分家的, 例如
<code>1+1=2</code> 是一个加法算法, 用到了整型的数据结构 <a href="#fn1"
class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>.
你就说是不是吧.</p>
<p>DSA课程/书本上更注重实现. 手搓一个泛型结构, 实现 <code>std</code>
里头的一堆方法, 这不劝退谁劝退. 实现是为了更好理解原理.
不要被复杂的构造带偏了学习的方向! 我们实现的标准是: ANSI C 也能做到!</p>
<p>剩下的内容: 怎么用STL来解决使用到特定数据结构的题目, i.e. 会做题.
但我们也懂原理!</p>
<span id="more"></span>
<h2 id="链表">链表</h2>
<h3 id="静态链表">静态链表</h3>
<p>我们用数组模拟链表. 动态链表谁不会啊?</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    Node *next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Node</span>(); <span class="comment">// TOO SLOW! 除非你用内存池优化</span></span><br></pre></td></tr></table></figure>
<p>数组模拟单链表: 效率高 最大用处是<strong>邻接表</strong>
邻接表能拿来储存图/树.</p>
<p>储存方式: 区别于动态链表, 每个值对应一个地址,
静态链表采用编号的形式.</p>
<p>略过头节点, 第一个节点编号为 0, 然后是 1, 直到下一个节点不存在,
这个next节点编号为-1. 编号和下标关联起来, 通过访问编号,
也就访问了相应的元素值.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> head, e[N], ne[N], idx;</span><br></pre></td></tr></table></figure>
<p>把 <code>x</code> 插到链表第 <code>k</code> 个元素之后,
要考虑插入的位置. 如果 <code>k = 0</code>,
那么就把新节点设置为头节点即可:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">newNode-&gt;data = data;</span><br><span class="line">newNode-&gt;next = head;</span><br><span class="line">head = newNode;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 找到第 k 个节点</span></span><br><span class="line">Node* current = head;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; k &amp;&amp; current != <span class="literal">NULL</span>; i++) &#123;</span><br><span class="line">    current = current-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 然后插入新节点</span></span><br><span class="line">newNode-&gt;data = data;</span><br><span class="line">newNode-&gt;next = current-&gt;next;</span><br><span class="line">current-&gt;next = newNode;</span><br></pre></td></tr></table></figure>
<p>作为对比, 我们来关注下静态链表的实现:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 头节点插入 x</span></span><br><span class="line">e[idx] = x;</span><br><span class="line">ne[idx] = head;</span><br><span class="line">head = idx++;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// x 插入到下标为 k 的后面</span></span><br><span class="line">e[idx] = x;</span><br><span class="line">ne[idx] = ne[k];</span><br><span class="line">ne[k] = idx++;</span><br></pre></td></tr></table></figure>
<p>静态链表表示的含义基本上和动态链表无异.
唯一的区别就是最后要手动更新下标idx. 此外, 这种规定下,
第一个节点的下标为0, 实际操作可能要对下标偏移一位. 例如
<code>insert(k - 1, x)</code> 表示在第 <code>k</code> 个节点后插入
<code>x</code>. 当然你也可以将 <code>idx</code> 初始化为 1.
你会发现静态链表实际上有空间换时间的做法. 因为多了一个 <code>ne</code>
数组, 我们访问下标要比动态链表遍历找到第 <code>k</code>
个元素快的多.</p>
<p>删除操作, 实际上就是当原节点不存在, 并没有真正地在内存上把它抹除:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ne[k] = ne[ne[k]];</span><br></pre></td></tr></table></figure>
<h3 id="双链表">双链表</h3>
<p>双链表多了一个 <code>prev</code>(前驱指针),
操作其实和单链表没多大区别.</p>
<p>我们规定 head: 0 (头节点) tail: 1 (尾节点) 这两个节点不储存值,
表示链表的头尾 怎么初始化? <code>ne[0] = 1</code>,
<code>prev[1] = 0</code>, idx 0 和 1 表示头和尾 然后 <code>idx</code>
就从 <code>2</code> 开始.</p>
<p>双链表新增的操作是往左边插入, 实际上就是
<code>add(prev[k + 1], x)</code>.</p>
<p>链表就像看图说话. 看着图就知道代码怎么写了.</p>
<p>双链表能优化某些问题.</p>
<h2 id="栈">栈</h2>
<p>先进后出</p>
<p>数组模拟: <code>stk[N], tt</code></p>
<p><code>push(x)</code> 就是 <code>stk[++tt] = x</code> (栈指针+1,
然后赋值) <code>pop(x)</code> 就是 <code>tt--</code> (栈指针-1)
<code>query()</code> 返回栈顶元素 <code>stk[tt]</code></p>
<p>很自然的实现方式. 理解以后就不难理解汇编的函数栈.</p>
<p>应用: 表达式求值</p>
<p>模拟样例: 计算 <code>2*(5-3)</code>, <code>2</code>, <code>*</code>,
<code>(</code>, <code>5</code>, <code>-</code>, <code>3</code> 依次入栈,
当读到 <code>)</code> 时开始出栈, 直到 <code>(</code> 停下, 也即
<code>3</code>, <code>-</code>, <code>5</code>, <code>(</code>
出栈并计算, 结果为 <code>2</code>, 入栈, 然后出栈 <code>2</code>,
<code>*</code>, <code>2</code> 并计算, 入栈 <code>4</code>,
然后打印栈顶元素.</p>
<h3 id="单调栈">单调栈</h3>
<p>要求: 输出每个数左边第一个比它小的数</p>
<p>暴力做法:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; a[j])</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; a[j] &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>优化: 所有逆序元素可以删掉 最后维护一个单调的栈 考虑
<code>3 2 4 7 5 6</code>, 对于 <code>4</code> 而言 <code>2</code>
是它的目标值, 而 <code>3</code> 之后再也不会用到了, 因为 <code>2</code>
比它更靠后, 且比它更小. 于是 <code>3</code> 可以删去, 并且不影响问题.
对于 <code>5</code> 而言, <code>4</code> 是它的目标值, 中间多插入了一个
<code>7</code>, 是逆序的, 因此 <code>7</code>(栈顶元素) 可以删去.</p>
<p>要判断的是 <code>stk[tt] &lt; a[i]</code>.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    <span class="keyword">while</span> (tt &amp;&amp; stk[tt] &gt;= x)</span><br><span class="line">        tt--;</span><br><span class="line">    <span class="keyword">if</span> (tt)</span><br><span class="line">        cout &lt;&lt; stk[tt] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    stk[++tt] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="队列">队列</h2>
<p>先进先出</p>
<p>模拟队列和模拟栈是类似的, 多了一个队尾</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    q[++tt] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hh++</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tt &gt;= hh) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回队头元素</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q[hh];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单调队列">单调队列</h3>
<p>比喻: 公司来了一个更年轻的新人, 如果他比一些老员工还要优秀,
那么这些老员工就会被立即淘汰(从队列中删除), 如果没有老员工优秀,
那么老员工会一直干到退休然后被淘汰(从滑动窗口中出去)</p>
<p>模板题: 长度为 <span class="math inline">\(n\)</span> 的序列当中,
求每个长度为 <span class="math inline">\(m\)</span> 的区间区间最值.
时间复杂度为 <span class="math inline">\(O(n)\)</span>.</p>
<figure>
<img src="/images/pic7.png" alt="单调队列" />
<figcaption aria-hidden="true">单调队列</figcaption>
</figure>
<p>假设我们求的是区间最大值. 实际上每个滑动窗口中的队列为:
<code>6,2</code> -&gt; <code>6,5</code> -&gt; <code>6,5,1</code> -&gt;
<code>7</code></p>
<p>队列中成员单调递减(或递增), 因此称这个队列为单调队列.</p>
<p>滑动窗口问题:</p>
<ul>
<li>普通队列怎么做</li>
<li>将队列中没有用的元素删掉(单调性)</li>
<li>取队头/队尾 O(1)</li>
</ul>
<p>本质上这是一个双端队列(deque).
用数组模拟可以这么实现(在队列的基础上拓展):</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>; <span class="comment">// 队列存储下标</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// i 是窗口的右端点 i-k+1 右端点</span></span><br><span class="line">    <span class="comment">// 如果队头元素在窗口内部</span></span><br><span class="line">    <span class="comment">// 那么就将队头元素后移</span></span><br><span class="line">    <span class="keyword">if</span> (hh &lt;= tt &amp;&amp; q[hh] &lt; i - k + <span class="number">1</span>)</span><br><span class="line">        hh++;</span><br><span class="line">    <span class="comment">// 保证队尾元素大于等于右端点的值</span></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i])</span><br><span class="line">        tt--;</span><br><span class="line">    <span class="comment">// 将 i 入队</span></span><br><span class="line">    q[++tt] = i;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>)</span><br><span class="line">        cout &lt;&lt; a[q[hh]] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用 STL 可以这么写(更符合抽象思维):</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">deque&lt;<span class="type">int</span>&gt; q; <span class="comment">// 存储的是编号</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!q.<span class="built_in">empty</span>() &amp;&amp; i - q.<span class="built_in">front</span>() &gt;= k)</span><br><span class="line">        q.<span class="built_in">pop_front</span>();</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>() &amp;&amp; v[q.<span class="built_in">back</span>()] &gt;= v[i])</span><br><span class="line">        q.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">    q.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>)</span><br><span class="line">        cout &lt;&lt; v[q.<span class="built_in">front</span>()] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>求最大值可以对称过去. 很容易处理.</p>
<p>单调队列可以优化部分dp问题.</p>
<h2 id="字符串">字符串</h2>
<h3 id="kmp">KMP</h3>
<p>见其它文章.</p>
<h3 id="trie树字典树">Trie树(字典树)</h3>
<p>高效存储字符串及查找.</p>
<figure>
<img src="/images/trie1.png" alt="Trie1" />
<figcaption aria-hidden="true">Trie1</figcaption>
</figure>
<p>每个节点存放它的编号.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> son[N][<span class="number">26</span>], cnt[N], idx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i] != <span class="string">&#x27;\0&#x27;</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u])</span><br><span class="line">            son[p][u] = ++idx;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应用: <a
href="https://www.acwing.com/problem/content/145/">最大异或值</a></p>
<p>用字典树存储一个树的二进制表示</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">30</span>; ~i; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> &amp;s = son[p][x &gt;&gt; i &amp; <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (!s)</span><br><span class="line">            s = ++idx;</span><br><span class="line">        p = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="并查集">并查集</h2>
<p>作用/功能:</p>
<ol type="1">
<li>将两个集合合并 近乎O(1) <a href="#fn2" class="footnote-ref"
id="fnref2" role="doc-noteref"><sup>2</sup></a></li>
<li>询问两个元素是否在同一个集合当中</li>
</ol>
<p>基本原理: 每个集合用一棵树来表示, 树根的编号就是整个集合的编号.
每一个节点存储它的父节点, <code>p[x]</code> 表示 <code>x</code>
的父节点.</p>
<figure>
<img src="/images/disjoint-set.svg" alt="并查集" />
<figcaption aria-hidden="true">并查集</figcaption>
</figure>
<p>初始化: 每个数位于单独的集合. 每个数的父节点都是它自己.
<code>std::iota(p.begin(), p.end(), 0)</code></p>
<p>问题1: 如何判断树根 <code>if(p[x] == x)</code></p>
<p>问题2: 如何求 <code>x</code> 的集合编号
<code>while(p[x] != x) x = p[x];</code> 这个可以写成递归的形式</p>
<p>问题3: 如何合并这两个集合 <code>p[x] = y</code>
让加入集合的根节点作为原集合根节点的儿子</p>
<p>*启发式合并:
选择哪棵树的根节点作为新树的根节点会影响未来操作的复杂度,
可以将节点较少或深度较小的树连到另一棵 当然这个是optional,
通常不采用启发式合并题目也能过的.</p>
<p>优化: 路径压缩 <del>按秩合并(不考虑)</del></p>
<p>保证树是双层的.</p>
<p>具体实现: <code>find(x)</code> 返回 <code>x</code> 的祖宗节点
如果是根节点就返回自己 递归实现 <code>p[find(x)] = find(y)</code>
实现合并操作. 注意对根节点进行 <code>find</code>
操作就等同于返回它自身.</p>
<p>难点:</p>
<ul>
<li>理解 <code>find</code> 函数里的递归</li>
<li>合并时的 <code>p[find(i)] = find(j)</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x)</span><br><span class="line">        p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        p[i] = i;</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; op &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;M&#x27;</span>)</span><br><span class="line">            p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b))</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经典题目: POJ1182 食物链</p>
<p><a href="https://vjudge.net/article/371">有生之年能做完的习题集
并查集</a></p>
<h2 id="图">图</h2>
<p>图 = 顶点+边 的集合</p>
<p>用 <span class="math inline">\(G(V,E)\)</span> 表示. G: Graph V:
Vertex E: Edge</p>
<p>边的方向: 有向图和无向图 带权和不带权: 边可以有权重,
可以表示诸如距离或者时间之类的量</p>
<p>可以用一个二维数组表示一个图, 这个数组又被称为邻接矩阵.</p>
<p><code>a[i][j]</code> 表示顶点 <code>i</code> 到 <code>j</code>
是否连通. 如果连通, 那么这个值为 <code>1</code>, 否则为 <code>0</code>.
在带权图中, 这个值为 <code>i</code> 到 <code>j</code>
所需要的边权值(如距离, 时间etc.) <code>+inf</code>
表示不连通(无法到达).</p>
<p>对于无向图, 邻接矩阵关于 0-0, 1-1, 2-2 这条对角线堆成. 对角线为
<code>0</code>, 表示某定点到自己的边长为 <code>0</code>.</p>
<p>我们也可以用链表来表示一个图, 这种方法也被称为图的邻接表.
表头是一个图的节点数组, 对应图的顶点. 每个节点后连接一个链表或指针数组,
存储与这个顶点相连的其他顶点的指针. 只要顶点A到顶点B之间有一条边,
则A对应的表头后就有一个顶点B的指针. 如果要存储带权的边,
在定义节点结构的时候可以附带存储一个变量.</p>
<p>我们一般使用邻接表来表示稀疏图, 邻接矩阵表示稠密图.</p>
<h3 id="二叉树">二叉树</h3>
<p>注: 本题的综合性比较高.</p>
<p>导航: <a
href="https://www.acwing.com/problem/content/description/1499/">1497.
树的遍历</a></p>
<p>这道题很classic. 怎么花式去遍历一棵树: 后序遍历 中序遍历 层序遍历</p>
<p>解释下什么意思:</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">     1</span><br><span class="line">   /   \</span><br><span class="line">  2     3</span><br><span class="line"> / \   / \</span><br><span class="line">4   5 6   7</span><br></pre></td></tr></table></figure>
<ol type="1">
<li>后序遍历: 4 -&gt; 5 -&gt; 2 -&gt; 6 -&gt; 7 -&gt; 3 -&gt; 1</li>
<li>中序遍历: 4 -&gt; 2 -&gt; 5 -&gt; 1 -&gt; 6 -&gt; 3 -&gt; 7</li>
<li>层序遍历: 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7</li>
</ol>
<p>输入后序遍历和中序遍历, 可以确定一棵二叉树.</p>
<p>通过后序遍历找到根的值,
然后再到中序序列里找到根的位置再将该树分为左子树与右子树(对应区间分割),
然后不断递归即可通过中序和后序重塑一棵树.</p>
<p>例如找到了后序遍历到了2, 那么在中序遍历中找到这个2, 2前后的两个元素,
即 4 和 5, 也就是一个 parent 2 和 left child 4 和 right child 5. parent
可以看成是一个树的 root.</p>
<p>一个难点是怎么确定 left child 和 right child 在后序遍历中的位置.
解决方案如下: 因为我们知道中序遍历的区间范围,
也即知道了左树和右树的大小, 而利用这个大小不会变我们可以反推:
<code>pr' = pl + (k - 1 - il)</code>(左树的情形),
<code>pl' = pl + (k + 1 - il) - 1</code>(右树)</p>
<blockquote>
<p>问题: 为什么要-1? 答案: 因为index从零开始取的</p>
</blockquote>
<p>因为存在在中序遍历搜索后序遍历里的值的过程,
因此中序遍历用一个hash表存放.</p>
<p>代码很精巧. 建议反复阅读orz</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">40</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> postorder[N], inorder[N];</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; l, r, pos;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> il, <span class="type">int</span> ir, <span class="type">int</span> pl, <span class="type">int</span> pr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> root = postorder[pr];</span><br><span class="line">    <span class="type">int</span> k = pos[root];</span><br><span class="line">    <span class="keyword">if</span> (il &lt; k)</span><br><span class="line">        l[root] = <span class="built_in">build</span>(il, k - <span class="number">1</span>, pl, pl + k - <span class="number">1</span> - il);</span><br><span class="line">    <span class="keyword">if</span> (ir &gt; k)</span><br><span class="line">        r[root] = <span class="built_in">build</span>(k + <span class="number">1</span>, ir, pl + k - il, pr - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        cout &lt;&lt; t &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (l.<span class="built_in">count</span>(t))</span><br><span class="line">            q.<span class="built_in">push</span>(l[t]);</span><br><span class="line">        <span class="keyword">if</span> (r.<span class="built_in">count</span>(t))</span><br><span class="line">            q.<span class="built_in">push</span>(r[t]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cin &gt;&gt; postorder[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; inorder[i];</span><br><span class="line">        pos[inorder[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> root = <span class="built_in">build</span>(<span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">bfs</span>(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="桶">桶</h2>
<p>应用:</p>
<ul>
<li>桶排序</li>
<li>计数器数组</li>
</ul>
<p>例如计算字符串中两个相同字符之间的距离, 可以这么写</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> cnt[N];</span><br><span class="line"><span class="built_in">memset</span>(cnt, <span class="number">-1</span>, <span class="keyword">sizeof</span> cnt);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(cnt[s[i]] != <span class="number">-1</span>)</span><br><span class="line">        cout &lt;&lt; s[i] - i &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cnt[s[i]] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="哈希表散列表">哈希表(散列表)</h2>
<figure>
<img src="/images/hashtable.svg" alt="哈希表" />
<figcaption aria-hidden="true">哈希表</figcaption>
</figure>
<p>key-value 式的数据结构, 有 key 就能查询到 value, 实际上是一种映射.
这个 key 可以是 <code>int</code>, <code>string</code>, 甚至结构体.
可以把哈希表理解成一种高级的数组, 下标就是 key, key
对应值在内存的位置.</p>
<p>通过一个哈希函数 <code>h(x)</code> 假设我们用数组 <code>a</code>
存放数据, 那么 <code>(key, value)</code> 就应该放在
<code>a[h(key)]</code> 上.</p>
<p>一个应用: 数据量 <code>N 0~1e9</code> 中的数字映射到
<code>0~1e5</code> 哈希函数怎么取? <code>h(x) = x mod M</code>
<code>M</code> 是一个大质数</p>
<p><em>Remark</em>: 离散化是一种及其特殊的哈希(离散化是保序的)</p>
<ul>
<li><span class="math inline">\(x \bmod 10^5\)</span></li>
<li>哈希冲突怎么办? (两个不同数据, 但哈希值相同)</li>
<li>抽屉原理告诉我们这是不可避的.
<ul>
<li>拉链法/开散列表(open hashing): 储存当前槽上存储的数(类似邻接表)
<ul>
<li>查询的时候扫描链表就行.</li>
</ul></li>
<li>开放寻址法/闭散列法: 如果插入数据的位置上已经有数据,
就插入到下一个空余位置(比喻: 上厕所)
<ul>
<li>有线性探测, 二次探测, 双重散列(双哈希)等方法...</li>
<li>OI 里一般用的是拉链法.</li>
</ul></li>
</ul></li>
</ul>
<p>实现操作: 比赛里(一般)只会有添加和查找两个操作</p>
<p>MD5, SHA-1 背后原理都是 hash.</p>
<h3 id="std-库的哈希表">std 库的哈希表</h3>
<p><code>unordered_map</code> 或者 <code>unordered_set</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line"><span class="comment">// 添加操作</span></span><br><span class="line">mp[x]++;</span><br><span class="line"><span class="comment">// 查询操作</span></span><br><span class="line"><span class="keyword">if</span>(mp[t] &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// code</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">unordered_set&lt;<span class="type">int</span>&gt; hashmap;</span><br><span class="line"><span class="comment">// 插入操作</span></span><br><span class="line">hashmap.<span class="built_in">insert</span>(x);</span><br><span class="line"><span class="comment">// 查询操作</span></span><br><span class="line"><span class="keyword">if</span>(hashmap.<span class="built_in">count</span>(t))</span><br><span class="line">    <span class="comment">// code</span></span><br></pre></td></tr></table></figure>
<h3 id="字符串哈希">字符串哈希</h3>
<p>比较重要的哈希方式 一些字符串问题不一定需要KMP 字符串前缀哈希法
<code>h[i]</code> 表示前缀字符串对应的哈希值</p>
<p>问题: 如何定义某一前缀字符串的哈希值?</p>
<p>我们采用多项式 Hash 的方法.</p>
<p>字符串P进制下的 "ABCD"-&gt; A B C D -&gt; 1 2 3 4 -&gt; 十进制数
<span class="math inline">\(1\cdot p^3 + 2 \cdot p^2 + 3 \cdot p^1 + 4
\cdot p^0\)</span> 最后对整个数取模 <span
class="math inline">\(q\)</span> 字符串就映射到了 <code>0~q-1</code></p>
<p>公式化: 对于一个长度 <span class="math inline">\(l\)</span> 的字符串
<span class="math inline">\(s\)</span>, 那么它对应的哈希函数值为</p>
<p><span class="math display">\[f(s) =
\sum^{l}_{i=1}s[i]p^{l-i}\]</span></p>
<p>不能映射成 0 (A 0 那么 AA 也是 0) 字符串的哈希方法不考虑冲突的情况
经验值 <code>p = 131</code> 或 <code>p = 13331</code>
<code>q = 2^64</code> 在一般情况假定不会出现冲突(冲突概率约为 <span
class="math inline">\(|s|-1/q\)</span>)</p>
<p>用 <code>unsigned long long</code> 可以省去
<code>mod 2^64</code>(因为溢出就等同于取模, 见CSAPP Chapter 2)</p>
<p>类似前缀和, 如果想求 <code>L</code> 到 <code>R</code> 这一段的hash,
那么可以按照下面的方式</p>
<p><span class="math display">\[h_R - h_{L-1} \cdot
p^{R-L+1}\]</span></p>
<p>你可以手动代入计算这个是否正确.</p>
<p>应用: 字符串匹配.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, P = <span class="number">131</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line">ULL h[N], p[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; (str + <span class="number">1</span>);</span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = p[i - <span class="number">1</span>] * P;</span><br><span class="line">        h[i] = h[i - <span class="number">1</span>] * P + str[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l1, r1, l2, r2;</span><br><span class="line">        cin &gt;&gt; l1 &gt;&gt; r1 &gt;&gt; l2 &gt;&gt; r2;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">get</span>(l1, r1) == <span class="built_in">get</span>(l2, r2))</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="堆">堆</h2>
<h3 id="堆实现">堆实现</h3>
<p>STL里的数据结构为 <code>priority_queue</code> 优先队列实现堆
基本功能:</p>
<ul>
<li>插入一个数</li>
<li>求集合中的最小值</li>
<li>删除最小值</li>
<li>删除任意一个元素(STL无)</li>
<li>修改任意一个元素(STL无)</li>
</ul>
<p>堆是一棵完全二叉树.</p>
<p>小根堆: 每个点都小于它的左右child, 那么根节点就是最小值</p>
<p>堆的存储: 一维数组,
下标从<code>1</code>开始.(因为<code>0</code>的左child也是<code>0</code>,
不方便) 下标 <code>x</code> 的左child: 下标 <code>2x</code> 右child:
<code>2x+1</code></p>
<p><code>down(x)</code>: 让一个节点往下移动 <code>up(x)</code>:
往上移动</p>
<p>所有操作可以用这两个基本操作实现:</p>
<p>插入: 原堆大小为 <code>size</code> 那么
<code>heap[++size] = x;</code> <code>up(size)</code> 即可. 最小值:
<code>heap[1]</code> 删除第一个元素:
用堆里最后一个元素覆盖掉第一个元素<code>heap[1] = heap[size]</code>,
然后<code>size--</code>, 维护根节点 <code>down(1)</code> 删除任意元素:
<code>heap[k] = heap[size]</code>, <code>size--</code>,
<code>down(k)</code>,
<code>up(k)</code>(只会执行一步<code>up/down</code>操作). 修改任意元素:
<code>heap[k] = x</code>, <code>down[k]</code>, <code>up[k]</code></p>
<p>利用二叉堆实现堆排序. 只用实现<code>down</code>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = k;</span><br><span class="line">    <span class="keyword">if</span> (k * <span class="number">2</span> &lt;= s &amp;&amp; heap[k * <span class="number">2</span>] &lt; heap[t])</span><br><span class="line">        t = k * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (k * <span class="number">2</span> + <span class="number">1</span> &lt;= s &amp;&amp; heap[k * <span class="number">2</span> + <span class="number">1</span>] &lt; heap[t])</span><br><span class="line">        t = k * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (k != t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(heap[k], heap[t]);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后不断向堆插入元素即可.</p>
<h3 id="std-库里的堆">std 库里的堆</h3>
<p>用优先队列
<code>priority_queue&lt;T, vector&lt;T&gt;, ...&gt;</code></p>
<p>最后一个可以填 <code>greater&lt;T&gt;</code>, 表示小根堆;
<code>less&lt;T&gt;</code> 表示大根堆.</p>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>严格来说这不算是一个"结构", 而是简单的类型.
只要你懂我意思就行 :)<a href="#fnref1" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>关于时间复杂度的证明, 可以看这篇<a
href="https://oi-wiki.org/ds/dsu-complexity/">文章</a>.<a href="#fnref2"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>随感录</title>
    <url>/2023/01/28/%E9%9A%8F%E6%84%9F%E5%BD%95/</url>
    <content><![CDATA[<p>记录不时的奇思妙想. 奇怪的梦, 无垠的呓语, 似非的感悟.
忙碌后的凝思会带给人宁静, 或许人的创作欲此刻迸发. 胡诌数句,
想想还是删去罢了.</p>
<span id="more"></span>
<h2 id="鬼话">鬼话</h2>
<p>记录下一年来想说的鬼话(吐槽)和看到的鬼话.</p>
<h3 id="feb">Feb</h3>
<p>你见到的每个人都随身携带着粪便.</p>
<p>坐电车说了句"尼玛难挤", 旁边日本人说了句"一起挤".</p>
<p>心情愉快, 对谁都会抱有特殊的热情与善意.</p>
<p>编程和学车: 编程纯死记硬背模板和学车纯死记点位一样,
不懂原理最后的结果就是实战一团糟.</p>
<p>呆在家里越久, 越容易恋家. 保证自己的独立性.</p>
<p>只有你亲妈才能秒发现你今天毛衣穿反了.</p>
<h3 id="mar">Mar</h3>
<p>中国邮政一生黑. 寄个信用卡寄回老家去了,
一看地址是四川省成都市的浙江省, 你在干什么.</p>
<p>代码出现了四层嵌套, 要么这个算法出现了三层循环你优化不了,
要么就是代码的抽象逻辑太烂, 总之——u suck.</p>
<p>军队训练的时候一架直升机掉到山区了, 司令找到当地土著老太太.</p>
<ul>
<li>“有没看到一只铁鸟掉下来”.</li>
<li>“铁鸟没看见，但昨天有一架阿帕奇AHMK1改RTM322涡轮发动机掉到山那边了。”</li>
</ul>
<h3 id="apr">Apr</h3>
<p>越看越觉得自己是菜鸡. 不过自己开心才最重要.</p>
<p>梦到自己不知道吃了啥反正饿醒了. 差点能写到我的绮梦里去.
看来我也是美食猎人.</p>
<p>有点想在自己的博客里GHS, 思来索去, 想想还是要点脸.
或者说我将来是想要把网站给备案的.</p>
<p>下半个年的 TODO List:</p>
<ul>
<li>想设计一个自动关灯小器械. 当然不是何同学那种类型.
<ul>
<li>因为宿舍熄灯实际上是断电. 要是开关忘了关,
次日六点来电比闹钟还管用.</li>
<li>网上看到有宿舍关灯神器的相关视频, 感觉可行性非常强.</li>
<li>到时候搞一个单片机试试水. 开坑!</li>
</ul></li>
<li>想写一个 auto-grader, 就像 CS61 A 的 <code>ok</code> 一样好用.
<ul>
<li>学校没有 oj, 作业纯靠教师/助教一眼鉴定.</li>
<li>想和学校一起维护. 自动化万岁! 最后流芳百世(</li>
</ul></li>
</ul>
<p>第一次感受到内推的强大. 进学校实验室了. 好耶!</p>
<p>有些人就是把内心独白怼脸上, 敏感, 纠缠. 是我这种随意天性的克星,
不果断一点真不行. 反思下自己, 我的处事可能有些令人无语. 优柔寡断,
有时还有些神经质.</p>
<p>突然想起来今天是自己的19岁生日. 希望新的一岁能有新的突破.
当然春节也是这么说的. 感觉自己好老了, 下一秒就要工作养家糊口的感觉.
但内心其实还是小孩子.</p>
<p>GPLT捞了个省三. 好耶! 感觉自己不适合打算法, 主要还是没那个兴致,
半学期都摸了, 结果确实好不到哪里去.</p>
<h3 id="may">May</h3>
<p>学完 Flask 打算之后搞一个文件管理项目. 管理什么,
当然是...不告诉你.</p>
<ul>
<li>核心技术: Flask + Electron</li>
</ul>
<p>5.1 宅寝室打游戏了. 崩铁挺有意思. 以后发疯文学的文笔可以参考参考.</p>
<p>本来是想去漫展的, 但想想一个人太孤独又其实不是很想去.
下次cos波奇酱吧.</p>
<p>天选3的网卡一直被人吐槽. 这次算是体会到了. 三天蓝屏4次, 我无语了.
重装了驱动现在总算能用了.</p>
<p>我发现白日梦通常是奇幻的. 而且真实. 流的我一身汗.</p>
<ul>
<li>能梦到 T 大联合培养的方案,
进了机房和一个没听过的专业(我问到了)的同学坐一起,
主持人讲了一堆高中应试的提优, 看到了高中的年级主任, 发了试卷,
我可怜的在那里招手想要一份资料, 但没有一个人理我. 最后我退课了.</li>
</ul>
<p>天选3的无线网卡驱动又出毛病了. 这回是直接蓝屏. 重装了几次都有问题,
寄了. 一怒之下遂买了 Intel 的 ax210 和一个1T的致态SSD.
后来发现重装的时候选择英文就可以解决所以网卡又白买了.(?)</p>
<p>这一周又有考试, 又有论文选题, 还有实验室的项目, 各种due, 各种要命
QAQ</p>
<p>本来想做听力的, 一看周日晚7点due, 瞬间没了兴致.</p>
<p>5.20 了, 又见一群人秀恩爱, 甚至杯子打折, 笑死.
感觉自己还是有点精神洁癖, 不是说谈不了恋爱, 就是接受不了廉价的恋爱,
估计自己还是会走上相亲的道路.</p>
<p>秒转生成工具的作者停止维护了. 希望人安好. 我的账号开了会员现在用不了,
创了一个新号还是用不了, 依然404, 无语.</p>
<p>update: 回滚历史版本+长链可用. 开源精神, 薪火相传.</p>
<p>8.30 update: 笑死, 寄完了. 资源死了一大批.</p>
<h3 id="jun">Jun</h3>
<p>6.1 儿童节快乐!</p>
<p>"决定人生方向的事常常发生在夏季 我想沿着人生的路高歌猛进
却总是在这个看似明亮的季节里束手无策"</p>
<p>高考让人忽略重要而不紧急的事情. 人格培养, 学科素养,
在指标化的成绩面前不值一提.</p>
<p>今天去游泳, 回来发现自己柜子里少了一只袜子.
我寻思拿错了为什么不是全拿走啊?</p>
<p>期末英语考了一个blunder的句子翻译, 句子我都还记得</p>
<blockquote>
<p>"It was seen as blunder", he said. This move turned out to be
foresighted.</p>
</blockquote>
<p>当时人直接愣住了. 从后文推测, 可惜最后猜错了. 然后复习六级的时候发现,
我TM曾经记过这个单词:</p>
<figure>
<img src="/images/blunder.png" alt="笑死, 根本记不住" />
<figcaption aria-hidden="true">笑死, 根本记不住</figcaption>
</figure>
<p>离散考试感觉寄了. 一堆伪证, 还有定义不清的胡乱猜测,
五阶邻接矩阵的幂次感觉算错了, 总之就是太失败了.</p>
<p>update: 四舍五入有个八十分. 顺便感谢罗老师狠狠地捞了.</p>
<p>Don't be best. Be the only.</p>
<p>没有独立的人格, 积累起来的美德都是不稳定的, 毫无依据的,
是被灌输的(instilled).</p>
<p>Trust me: There's no "them".</p>
<p>没有必要去记忆现成的东西. 去记忆自己消化了的东西.</p>
<p>CET 6 感觉就这. 600以上大二就考虑过掉GRE.</p>
<p>民之从事, 常于几成而败之.</p>
<p>把 <code>~/.bashrc</code> 写成了 <code>~./bashrc</code> 硬是没看出来.
笑死.</p>
<p>wsl 的 gdb 炸了, 我怀疑是什么链接问题, 现在连 hello world run
一下就炸.</p>
<h3 id="jul">Jul</h3>
<p>买了个麦克风, 结果发现是卡农口的没法用, 于是又花钱买了个声卡,
合计500+, 我白花花的银子就这么去了.</p>
<p>转到 AI 实验班了, 也算是符合我最初对自己的预期,
主要财经院校的CS真没什么竞争力, 不如走 interdisciplinary, 反正 CS
可以自学.</p>
<p>面试真水. 问的问题也是云里雾里的, 问中国 AI 掐脖子, 和外国的 AI
差距啥的, 这都是</p>
<p>理解不了所谓的余兴活动, 一个陌生人在一群陌生人面前唱跳,
看起来就像小圈子人的自娱自乐.</p>
<p>成就达成 「初めでの配信」</p>
<p>梦到一个类FC的游戏, 能够攻击NPC, 然后全员就会冲过来杀你, 死亡 log
显示"为了妻子复仇", 被这种 meta 元素有点吓到了(这不是我们七日死吗),
导致我今天五点钟就醒了.</p>
<p>暑期累死大半个人, 白天做菜, 午间比赛, 下午写文档, 晚上练车(市中心练),
还有实习, 工作一点没干, 受不了了, 我要直接投降.</p>
<p><a
href="https://singularity-backend.gitbook.io/backend-online-doc/before/readme">文档链接</a>,
感兴趣的可以观摩下.</p>
<p>原神 FES 本来很想去的. 第一次抢票没注意,
第二次放票一看八点四十已经缺货了. 捡漏反正也比不过那些开脚本的,
最后放弃了. 本来还是小小期待上海之旅的, 之前BW也是还在军训,
这下啥都错过了. 不过自己本来也没钱, 去了还要高消费, 也就算了.</p>
<p>回老家见见老人. 不得不说身体很重要,
晚年手术开刀可是拖累全家的事情.</p>
<p>驾照到手不到一年上了高速, 当然是有人陪同, 感觉也没有当初想象那么吓人,
速度控制在100码左右, 保持一个直线行驶, 变道注意来车, 别走错车道就差不多,
在开多一些, 学些危机应对技巧, 就可以自驾出去玩了.</p>
<p>最近事情堆的很多. 按照象限划分就是重要但不紧急的事情堆满了.
都不知道先做哪件. 拖延, 于是摸了. 以后我还怎么工作啊?</p>
<h3 id="aug">Aug</h3>
<ul>
<li><span class="math inline">\(\forall \mathbf A \in
\mathbb{R}^{m\times n}\)</span>, <span
class="math inline">\(\nabla_{\mathbf{x}}\mathbf{A}\mathbf{x}=\mathbf{A}^{T}\)</span></li>
</ul>
<p><strong>证明</strong> 设 <span class="math inline">\((A)_{m\times n}
= (\alpha_1, \alpha_2,\dots,\alpha_n)\)</span>, 其中 <span
class="math inline">\(\alpha_i\)</span> 为 <span
class="math inline">\(m\)</span> 维列向量(按列分块). 于是</p>
<p><span class="math display">\[
\begin{aligned}
\nabla_{\mathbf{x}}\mathbf{A}\mathbf{x}&amp;=\left[\frac{\partial
\alpha_1 x_1}{\partial x_1},\frac{\partial \alpha_2 x_2}{\partial
x_2},\ldots,\frac{\partial \alpha_n x_n}{\partial x_n}\right]^T\\
&amp;=[\alpha_1, \alpha_2,\dots,\alpha_n]^T=\mathbf{A}^{T}
\end{aligned}
\]</span></p>
<ul>
<li><span class="math inline">\(\forall \mathbf A \in
\mathbb{R}^{n\times m}\)</span>, <span
class="math inline">\(\nabla_{\mathbf{x}}\mathbf{x}^T\mathbf{A}=\mathbf{A}\)</span></li>
</ul>
<p>考虑 <span
class="math inline">\((\mathbf{x}^T\mathbf{A})^T=\mathbf{x}\mathbf{A}^T\)</span>,
之后就和上面一样了.</p>
<ul>
<li><span class="math inline">\(\forall \mathbf A \in
\mathbb{R}^{n\times n}\)</span>, <span
class="math inline">\(\nabla_{\mathbf{x}}\mathbf{x}^T\mathbf{A}\mathbf{x}=(\mathbf{A}+\mathbf{A}^T)\mathbf{x}\)</span></li>
</ul>
<p>vscode UI 是又改版了吗, 搜索栏放到最顶上有点不适应了,
也没空看七月的更新日记了.</p>
<p>今天好像又梦到什么奇怪的东西.
但是到晚上回忆的时候却是一点也想不起来了.</p>
<p>卡拉比丘真好玩, 这几天有点上头, 团队FPS都玩的少, TPS 还是初见,
挺新鲜的. 但自己枪法太马老是垫底说实在话还是没有玩明白,
目前的游戏理解局限于看到人就射, 结果对枪一直对不过,
还要被人跳脸一刀劈死.</p>
<p>ブルアカ 的游戏性真的有人能坚持那么久吗.
回合制游戏的策略都要比这玩意儿强, 纯纯堆数值和卖卡养成, 开自动都嫌麻烦.
日厂二游是不是除了卖美术以外就很难找出别的东西啊?</p>
<p>ps: 开发 NEXON 是韩国公司. 这本地化味太冲了.</p>
<p>深有体会。我4岁之前，这个世界上从来就没有“苹果”这种物品。然而自从我三姨姥姥带着苹果来过我家后，因为我的观测，宇宙才打了个补丁，让苹果的存在深入人心。自此之后，各种有关苹果的内容就出现了。什么“一日一苹果，医生远离我”“牛顿被苹果砸了发现三定律”“乔布斯创建苹果公司”等等。可以说我为经典力学大厦的构建以及人类社会的发展做出了不可磨灭的贡献。</p>
<p>玩游戏一上头声音就会太大, 被人提醒了才意识到. 哎, 我反思.
敲键盘声音太大, 又突然大叫, 实在是不好意思. 以后还是干点安静的事.</p>
<p>If you cannot be a poet, be the poem. 做不了李白, 就活成明月.</p>
<p>梦到一个奇怪的科技: 细胞弦化</p>
<p>在亲戚家, 耳机盒和 Type-C 的转接口都不见了. 哎,
自己的东西还得自己好好放着,
不然哪天被别人当成垃圾扔掉了也是云里雾里的.</p>
<p>いたいいたいのどっちだ</p>
<p>善加修饰的文字总能调起人的情欲, 一个噱头的标题至少能有 UC
标题的冲击力, 反正我是 get baited.</p>
<p>看了高寒的一个访谈视频有感: 做饭要考虑别人的想法吗? fvck it.
不要你觉得, 要我觉得. 我从食客那里得不到可用的信息.
就算我对我自己的作品不够满意, 他们依然处于一种客套的礼貌, yum yum, this
is good, 这不就是冗余信息么. 反过来, 如果我觉得这道菜的出品还可以,
至少我觉得挺好吃, i don't give a shit about your opinions. 你觉得好吃,
那就是我们俩人共鸣了, 我们在某些事上存在共同点,
但我凭什么要强求你和我相同? 你觉得不好吃, 那就心里自己嘀咕,
到最后还不是你来掏腰包付钱, 不存在所谓拍屁股走人的情况.
听起来是一种自闭式做法, 但是这样, 我对烹饪的 mental pressure 就会少很多,
足以支持我继续做下去了.</p>
<p>如果我作为老师, 我假期绝对不会布置讨人厌的作业.
就算明面上要把"快乐过暑假"布置下去, 我也会附带答案地布置下去.
但我也不希望自己的学生荒废掉整个假期. 怎样才能让他们有学习的动力呢?
学期初安排考试. 这样假期的学习清单会更有价值.</p>
<p>一口气把「推しの子」的前 11 集看完了. 第一集封神,
剧场版的长度可不多见, 高桥李依配的爱可真不错呀,
剩下的剧集就感觉高开低走了, 总感觉一股辉夜大小姐的味道,
该说不愧是赤坂明吗. 主线应该是 aqua 为爱复仇, 但感觉都快 THE END
了还停留在一开始演艺圈出道, 不会也要出 2, 3 季把...</p>
<p>推しの子这个标题也玩了个双关.</p>
<ul>
<li>我推的偶像</li>
<li>我推的(人)孩子</li>
</ul>
<p>第一集我看下来非常爽. 铺垫足够, 那些雷点倒也真不是完全想不到.
爱为什么婚前先孕, 我猜测大概率也和缺爱的成长环境相关,
想要「他人を愛する」, 孩子就是在这种念头之下得来的.
不过父亲这个坑我觉得真不好填, 因为这个角色也太矛盾了(?)
除非作者花大笔的篇幅去介绍爱的过去, 不然真的, 孩子是演艺圈几个金主的,
这种本子一样的展开我也会相信.</p>
<p>其实茜的那段还挺戳人的. 一介普通人没甚个性, 给人的印象只有努力,
认真... 无论事大事小都会掏出笔记记下, 真面目過ぎる,
但最后还是作为默默无闻的女孩存在. 给不了事务所应有的成果,
努力也只是一种"假努力"罢了, 甚至还要被日本特产炎上整出心里阴影.</p>
<p>但下集转瞬就是另一个人嘛. 喜欢刑侦故事, 有这天赋还要去当演员吗,
对爱的解读一个比一个准; 演技也是直接把爱给复刻了, 这是一个晚上的成果?
有这能力当初演出的时候怎么会被埋没. :(</p>
<figure>
<img src="/images/daisuki.png" alt="daisuki" />
<figcaption aria-hidden="true">daisuki</figcaption>
</figure>
<h3 id="sept">Sept</h3>
<p>快开学了. 趁着假期的余波再呆在家里无所事事玩点游戏, 看看番剧.</p>
<p>开学之后就要打ICPC的比赛了. 自己就是一个纯纯搭便车的家伙.
或许再挣扎些许也好, 但电子竞技菜是原罪:
自己学到的东西和别人相比真是天壤之别.</p>
<p>邦邦要火! It's MyGo!!!!! 真好看. soyo 这个角色真棒啊 (至福)</p>
<p>这个学期后端学习内容:</p>
<ul>
<li>登录: 基于 session 的 flask_login, Werkzeug, 实现cookie, RESTful
风格的 token 方式, 第三方认证(微信, Github 账号等)</li>
<li>单元测试: 学会写unit test</li>
</ul>
<p>いつか蝶がとまるような　あまいあまいあまい人に</p>
<p>鉴定为红橙黄绿蓝紫，没有青吗？</p>
<p>ICPC 第一场打完了. 签到完, 然后就是队友的附庸了, G 题我们 T 了一万年,
K 的积分不会积(根号不会拆).</p>
<p>今年有可能要和队友跑外地比赛了. orz</p>
<p>这种轻飘飘的感觉好像轻轻一跳就不会与地面再有任何联系</p>
<h2 id="彷徨者的独白">彷徨者的独白</h2>
<p>总感觉自己是个冷漠的人. 心里总是回荡着默尔索的那句自白.</p>
<p>父亲生日, 忘记发一句祝福了. 让父亲等到下午才见姗姗来迟的道歉.
酝酿许久后语音发出去的.</p>
<p>好久没和奶奶联系了, 家里人让我打个视频通话. 我不愿意, 但还是打了.
尴尬地杵在那里. 要好好学习啊. 点头, 傻笑, 结束.
明明我才是会话的发起人.</p>
<p>同学要送我礼物, 说是以表感谢. 谢谢你帮了我那么多. 我只觉得麻烦.
问我什么时候送好. 随时都好.</p>
<p>或许换位思考很重要. 我知道爷爷去的早,
父亲不过是想在特殊的一天多体验些未曾感受的父爱而已; 奶奶也是寡居无事,
想多获取些温暖而已; 同学的礼物很用心, 一片真心相待换来我的冷眼.</p>
<p><strong>我把很多事情都归结为无意义的社会令词, 无甚所谓的嘘寒问暖.
把生命中遇见的人, 都看得无足轻重.</strong></p>
<p>可能真的印证了大学里我班长的一句话. 那天他刚打完辩论赛,
依稀记得那天的辩题是: 爱情里有无必要说他/她想听的.</p>
<p>我想我没真正去爱过, 也没有真正学会所谓"责任".</p>
<p>"<strong>能有一个为之付出, 珍视的人, 是多么幸福啊.</strong>"</p>
<p>我想这就是爱情的意义吧. 学会责任. 说什么灵魂交互.
你的真命天人还在梦里. 理想就和风干的厕纸一样脆弱.</p>
<p>相遇就是一种缘. 缘和因果结下了不解之缘.
要是信禅宗我也不会纠缠在此喋喋不休.</p>
<p><strong>所以. 珍惜人生的一切相遇吧. 因为相遇的结局便是分离, 永别.
趁着结局到来之前, 让自己不留缺憾.</strong></p>
<p>自己热情发出的一点光热, 总会或多或少影响到他人.</p>
<p>我很钦佩小王子, 因为我缺乏他身上的那份热情, 勇敢, 为责任付出的行动力.
要让我挑自己的毛病可以说一天.</p>
<p>不过至少这一次, 会不一样. 好歹让我不再彷徨.</p>
<p>仔细想了想, 这个消息还是可能太突兀了.
不过我已经尽我最大可能在思考发送什么了. 啊. 应该再个性化一些吗?
群发还是太狡猾了. 最后还要敷衍各位真是对不起. 全键盘打字果然没九宫格快.
点击发送. 我人生最重要的时刻怎么总是出差错.</p>
<p>不管怎的, 现在我也去呵护我的玫瑰了.</p>
<p>希望收到这最后一条消息的你能舒心.</p>
<p>"各位, 晚安"</p>
<p>(完)</p>
<h2 id="回到你的过去">回到你的过去</h2>
<p>留坑.</p>
<h2 id="绮梦-一">绮梦 (一)</h2>
<p>大纲: 大学的出国交流项目, 结果来到了一个高度独裁的世界.
鲜活的生命被人拖出去, 用残忍的方式处决了.(枪决, 火刑) 小孩子在一旁叫好,
充满了对受刑者的怨恨, "畜生", "叛徒".
出去交流的这些学生每天必须出去观察行刑现场. 每一天都好像是上一天的重复.
总有人被杀, 无可避免. 现场的人越来越少, 一天,
在场的人员只剩下这些出国的大学生, 但是今天的受刑者还没出现.
他泡了一杯杯面, 杯里只剩下泡软的拉面. 人也不见了踪影. 就在这时,
一个女性出现, 看了看这群因为紧张而站得笔直的大学生,
然后宣布了一个惊人的消息: 今天要死的人是你们这群人之一. 接下来,
她让大学生们每个人一一报了一个数字.
第一个人(也就是自己)不知道为什么报了1(如果这是死的顺序那可太行了),
剩下的人有报7, 4, 2, ...(一共6人) 然后女性宣布:
今天死的人的编号就是你们刚刚自己报的数字, 这个编号会通过一个公式得出.
然后对面的墙壁突然退出, 随即而来的是一面装满装饰品的橱柜, 上面标有10,
20, 50等数字, 还有恶趣味的等级 C, B, S...就像是抽卡一样.
一会儿的计算数据会从这面墙得来. 这个女的还宣布了一个事情,
假如一个人能猜出来谁会被杀, 那么今天就没人会死. 但假如猜错了,
他就会替那个人去死. 你们接着可以向我提出两个问题,
但是回答我只能保证一个真一个假. 动用你的脑子,
看看今天是必然死一个人还是说, 会有大英雄拯救你们呢?</p>
<h2 id="绮梦-二">绮梦 (二)</h2>
<!-- ## 恋爱, 相亲, 然后是坟墓

小镇做题家不懂恋爱.

[陆蠡《嫁衣》](https://www.uuzuowen.com/kewaitushu/zhongguozuimeisanwen/14488.html) -->
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
        <tag>小说</tag>
      </tags>
  </entry>
  <entry>
    <title>综合算法题</title>
    <url>/2023/03/04/%E7%BB%BC%E5%90%88%E7%AE%97%E6%B3%95%E9%A2%98/</url>
    <content><![CDATA[<p>收录一些平时做的比较综合的题目. 考察的知识点不止一点,
各种优化方式简直使出毕生所学.</p>
<p>大概是蓝桥杯国赛, ACM银, 提高组以上难度, 是比赛你不会轻易去碰的题目,
讲解起来也是额外麻烦. 虽然说比赛能保证签到题全对就已经很了不起了,
但这种题目就像高考数学的压轴题, 还是要有所接触才能有所突破嘛.</p>
<span id="more"></span>
<h2 id="裁剪序列">裁剪序列</h2>
<h3 id="题目">题目</h3>
<p>导航: <a
href="https://www.acwing.com/problem/content/description/301/">AcWing
299. 裁剪序列</a></p>
<h4 id="题目描述">题目描述</h4>
<p>给定一个长度为 <span class="math inline">\(N\)</span> 的序列 <span
class="math inline">\(A\)</span>，要求把该序列分成若干段，在满足“每段中所有数的和”不超过
<span class="math inline">\(M\)</span>
的前提下，让“每段中所有数的最大值”之和最小。</p>
<p>试计算这个最小值.</p>
<h4 id="输入格式">输入格式</h4>
<p>第一行包含两个整数 <span class="math inline">\(N\)</span> 和 <span
class="math inline">\(M\)</span>.</p>
<p>第二行包含 <span class="math inline">\(N\)</span>
个整数，表示完整的序列 <span class="math inline">\(A\)</span>.</p>
<h4 id="输出格式">输出格式</h4>
<p>输出一个整数，表示结果。</p>
<p>如果结果不存在，则输出-1。</p>
<h4 id="数据范围">数据范围</h4>
<p><span class="math display">\[0 \leqslant N \leqslant
10^5\]</span></p>
<p><span class="math display">\[0 \leqslant M \leqslant
10^{11}\]</span></p>
<p>序列 <span class="math inline">\(A\)</span> 中的数非负, 且不超过
<span class="math inline">\(10^6\)</span>.</p>
<p>输入样例:</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">8 17</span><br><span class="line">2 2 2 8 1 8 2 1</span><br></pre></td></tr></table></figure>
<p>输出样例:</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">12</span><br></pre></td></tr></table></figure>
<p>样例解释:</p>
<figure>
<img src="/images/pic6.png" alt="样例解释" />
<figcaption aria-hidden="true">样例解释</figcaption>
</figure>
<p>按照如此分组, 第一组中的最大值为2, 第二组中的最大值为8,
第三组的最大值为2, 总和 2+8+2=12, 为最小值.</p>
<h3 id="题解">题解</h3>
<p>TAG: DP 双指针 贪心 单调队列 堆 STL Multiset</p>
<h4 id="朴素dp">朴素DP</h4>
<p>本题可以考虑区间DP的处理方式:</p>
<ul>
<li>状态表示:
<ul>
<li>集合: <code>f[i]</code> 表示前 <code>i</code>
个数中所有的划分区间中的最大值之和.</li>
<li>状态: <code>min</code></li>
</ul></li>
<li>状态计算:
<ul>
<li>划分区间: <code>1~j</code> 和 <code>j+1~i</code>
<ul>
<li><code>1~j</code> 不管</li>
<li>第二段的和要不超过 <code>M</code></li>
</ul></li>
<li>前一段区间很好表示: <code>f[j]</code></li>
<li>后一段区间: 是 <code>j+1~i</code> 这一段区间上的最大值</li>
<li><code>f[i] = min(f[j] + max A[k]), k in [j+1, i]</code></li>
<li><code>f[n]</code> 就是答案.</li>
</ul></li>
</ul>
<figure>
<img src="/images/pic8.png" alt="模拟样例" />
<figcaption aria-hidden="true">模拟样例</figcaption>
</figure>
<p>例如 <code>i = 6</code>, 可能的分组有 <code>2 2 2 8 1</code>
<code>8</code>, <code>2 2 2 8</code> <code>1 8</code>,
<code>2 2 2</code> <code>8 1 8</code>...而 <code>f[i]</code>
是这些方案中的最小值, 也即 <code>2 2 2</code> <code>8 1 8</code>
分组下的 <code>10</code>.</p>
<p>枚举 <code>i</code>, 再枚举 <code>j</code>, 还要枚举
<code>j+1~i</code> 这段上的 <code>k</code>, 这种方法的时间复杂度是
<code>O(n^3)</code>. 必定会TLE. 所以得考虑优化.
如果想不出优化方式过几个数据就作罢.</p>
<p>注: 在进一步优化之前请务必理解DP计算的正确性.</p>
<h4 id="优化">优化</h4>
<p><code>j</code> 可以从小到大枚举, 开一个变量就可以存最大的
<code>a[k]</code>, 这样复杂度能压到 <code>O(n^2)</code>. 但还是会
TLE.</p>
<p><strong>定理 1</strong> 如果 <code>j</code> 能够成为
<code>f[i]</code> 的唯一最优解, 那么 <code>j</code>
必须满足以下条件之一:</p>
<ul>
<li><code>A[j] = max(A[j], A[j+1], ..., A[i])</code></li>
<li><code>A[j] + ... + A[i] &gt; M</code> 且
<code>A[j+1] + ... + A[i] &lt;= M</code></li>
</ul>
<p><strong>证明</strong> 考虑反证法. 假设 <span
class="math inline">\(j\)</span> 上述两个条件都不满足. 对于决策
<code>j-1</code>:</p>
<ul>
<li><code>A[j] + ... + A[i] &lt;= M</code>, 考虑两种情况:
<ol type="1">
<li><code>A[j-1] + ... + A[i] &gt; M</code>, 此时 <code>j-1</code>
满足上述条件之一.</li>
<li><code>A[j-1] + ... + A[i] &lt;= M</code>:</li>
</ol>
<ul>
<li><code>f[i]</code> 单调递增.</li>
<li>同时 <code>A[j]</code> 不是 <code>A[j...i]</code> 中的最大值.
<ul>
<li>那么
<code>f[j-1] + max A[j...i] &lt;= f[j] + max A[j+1...i]</code></li>
</ul></li>
</ul></li>
<li><code>j-1</code> 是一个优于 <code>j</code> 或和 <code>j</code>
一样优的方案.</li>
</ul>
<p>由假设可知不成立. 因此 <code>j</code> 必须满足上面条件之一. <span
class="math inline">\(\Box\)</span></p>
<p>那么我们的问题就转换为: 对于一个 <code>i</code>,
找到一个满足上述条件的 <code>j</code>, 且 <code>j</code> 距离
<code>i</code> 最远. <code>i</code> 和 <code>j</code> 是随同变化的,
用双指针就可以压到一维.</p>
<p>不过使用双指针之前还要验证单调性, 也就是移动 <code>i</code>,
<code>j</code> 也会相应向后移动(无回溯). 不过这不是什么大的问题,
我们给出一个简单的证明:</p>
<p><strong>定理 2</strong> <code>j</code> 在 <code>i</code>
变大的过程中同步增大.</p>
<p><strong>证明</strong> 考虑反证法: 如果 <code>i</code> 移动到
<code>i'</code> 而 <code>j</code> 不往后移动, 因为 <code>j</code> 是满足
<code>A[j+1] + ... + A[i] &lt;= M</code> 最小的一个点, 必然有
<code>A[j+1] + ... + A[i'] &gt; M</code> 不满足条件, 因此 <code>j</code>
必须往后移动, 即 <code>j' &gt; j</code>. <span
class="math inline">\(\Box\)</span></p>
<p>有了这一点, 我们又得到一个性质: <code>[j, i]</code>
这段区间实际上是一个<strong>滑动区间</strong>, 尽管长度不定,
但最主要的是, <code>i</code> 和 <code>j</code> 都是单调的. 并且,
我们实现的核心,
是在这个区间内寻找<strong>区间最值</strong>——本质上这就是一个单调队列!
也即, 我们可以用一个单调队列来维护滑动窗口中出现的最大值,
并使得这段区间的总和小于 <code>m</code>.</p>
<p>同时我们需要维护一个方案的集合, 使得集合能够动态求最小值, 添加一个数,
删除一个数(头节点和尾节点). 你可能会想到使用堆存储,
但堆不太方便同时存储头节点和尾节点, 最好用一个平衡树来维护,
C++STL里可以用 <code>multiset</code>.</p>
<h4 id="代码">代码</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">LL m;</span><br><span class="line"><span class="type">int</span> w[N], q[N];</span><br><span class="line">LL f[N];</span><br><span class="line">multiset&lt;LL&gt; S;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不用 S.remove 是因为他会把所有的 x 全删掉</span></span><br><span class="line"><span class="comment">// 我们只要删去重复的一个即可</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(LL x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = S.<span class="built_in">find</span>(x);</span><br><span class="line">    S.<span class="built_in">erase</span>(it);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line">        <span class="keyword">if</span> (w[i] &gt; m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    LL sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// i 是滑动窗口的右端点 j 是左端点</span></span><br><span class="line">    <span class="comment">// 单调队列维护的是 a_max 的下标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += w[i];</span><br><span class="line">        <span class="keyword">while</span> (sum &gt; m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 减去滑动窗口的左端点</span></span><br><span class="line">            sum -= w[j++];</span><br><span class="line">            <span class="keyword">if</span> (hh &lt;= tt &amp;&amp; q[hh] &lt; j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (hh &lt; tt)</span><br><span class="line">                    <span class="built_in">remove</span>(f[q[hh]] + w[q[hh] + <span class="number">1</span>]);</span><br><span class="line">                hh++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; w[q[tt]] &lt;= w[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (hh &lt; tt)</span><br><span class="line">                <span class="built_in">remove</span>(f[q[tt] - <span class="number">1</span>] + w[q[tt]]);</span><br><span class="line">            tt--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        q[++tt] = i;</span><br><span class="line">        <span class="keyword">if</span> (hh &lt; tt)</span><br><span class="line">            S.<span class="built_in">insert</span>(f[q[tt] - <span class="number">1</span>] + w[q[tt]]);</span><br><span class="line">        f[i] = f[j - <span class="number">1</span>] + w[q[hh]];</span><br><span class="line">        <span class="keyword">if</span> (S.<span class="built_in">size</span>())</span><br><span class="line">            f[i] = <span class="built_in">min</span>(f[i], *S.<span class="built_in">begin</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, f[n]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="送信">送信</h2>
<p>导航: <a href="https://ac.nowcoder.com/acm/contest/54484/B">B
送信</a></p>
<h3 id="题目描述-1">题目描述</h3>
<p>某人写了 <span class="math inline">\(n\)</span> 封信和 <span
class="math inline">\(n\)</span>
个信封，如果所有的信都装错了信封。求所有信都装错信封共有多少种不同情况。</p>
<h4 id="输入描述">输入描述</h4>
<p>一行一个 <span class="math inline">\(n\)</span>. <span
class="math inline">\(n \leqslant 10^9\)</span>.</p>
<h4 id="输出描述">输出描述</h4>
<p>输出方案数对 <span class="math inline">\(10^9+7\)</span> 取模.</p>
<h4 id="样例-1">样例 1</h4>
<p>输入</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>
<h3 id="样例-2">样例 2</h3>
<p>输入</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">114514</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">977005016</span><br></pre></td></tr></table></figure>
<h3 id="题解-1">题解</h3>
<p>TAG: 组合数学 DP优化 分段打表</p>
<h4 id="朴素做法">朴素做法</h4>
<p>经典的错排问题.</p>
<p><a
href="https://www.luogu.com.cn/blog/P6174/post-cuo-pai?tdsourcetag=s_pcqq_aiomsg">小学生都能看懂的错排问题解析</a></p>
<p>打表程序:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">ULL D[<span class="number">3</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        D[<span class="number">2</span>] = (i - <span class="number">1</span>) * (D[<span class="number">1</span>] + D[<span class="number">0</span>]);</span><br><span class="line">        D[<span class="number">0</span>] = D[<span class="number">1</span>];</span><br><span class="line">        D[<span class="number">2</span>] %= MOD;</span><br><span class="line">        D[<span class="number">1</span>] = D[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; D[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接交 TLE. <span class="math inline">\(O(n)\)</span> 的复杂度,
但是常数还是挺大的, 1s 跑不完 1e9 的数据. 显然我们要用打表优化.</p>
<h4 id="分块打表">分块打表</h4>
<p>关键是 <code>n</code> 离谱的大, 朴素打表不适用, 只能用分段打表,
大体思路是: 把数据范围分成多份, 预处理每一块的信息,
不满一块就暴力计算.</p>
<p>我们把 1e9 的数据分成 10 份 1e8 的块. 如果你有力气, 可以分块成 1000
份 1e6 的块, 然后打表. 预处理之后, 要计算例如 <code>3e8 + 3</code>,
那么直接从表里找到 <code>3e8 + 1</code> 和
<code>3e8 + 2</code>(你也可以写 10 个 elif), 然后按公式计算即可.</p>
<p>这题还有个坑: 考场上有一个样例 <code>n = 0</code>, 这不欺负人嘛.</p>
<h4 id="代码-1">代码</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> P = <span class="number">1e8</span>, MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">ULL dp[<span class="number">3</span>];</span><br><span class="line"><span class="type">const</span> ULL scr[] = &#123;</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line"><span class="comment">// 1e8 + 1, 1e8 + 2</span></span><br><span class="line">    <span class="number">696682031</span>,</span><br><span class="line">    <span class="number">5686635</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">314470659</span>,</span><br><span class="line">    <span class="number">988682402</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">41451389</span>,</span><br><span class="line">    <span class="number">695854867</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">451755479</span>,</span><br><span class="line">    <span class="number">238595622</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">827750738</span>,</span><br><span class="line">    <span class="number">758373908</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">269882629</span>,</span><br><span class="line">    <span class="number">806258227</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">398578002</span>,</span><br><span class="line">    <span class="number">244123805</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">365715120</span>,</span><br><span class="line">    <span class="number">683425583</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">639014656</span>,</span><br><span class="line">    <span class="number">652237004</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">586902194</span>,</span><br><span class="line">    <span class="number">65489052</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> x = n / P;</span><br><span class="line">    <span class="keyword">if</span> (n % P == <span class="number">0</span>)</span><br><span class="line">        x --;</span><br><span class="line">    dp[<span class="number">0</span>] = scr[<span class="number">2</span> * x];</span><br><span class="line">    dp[<span class="number">1</span>] = scr[<span class="number">2</span> * x + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x * P + <span class="number">3</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[<span class="number">2</span>] = (i - <span class="number">1</span>) * (dp[<span class="number">0</span>] + dp[<span class="number">1</span>]);</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">2</span>] %= MOD;</span><br><span class="line">        dp[<span class="number">1</span>] = dp[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n % P == <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">2</span>] = scr[<span class="number">2</span> * x];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n % P == <span class="number">2</span>)</span><br><span class="line">        dp[<span class="number">2</span>] = scr[<span class="number">2</span> * x + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; dp[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>日常刷题</title>
    <url>/2023/08/31/%E6%97%A5%E5%B8%B8%E5%88%B7%E9%A2%98/</url>
    <content><![CDATA[<p>要开学了, 挣扎下. 17 号就要打 ICPC 的网络赛了,
到时候为了不太难看(队伍里有佬带飞qwq)就稍微做点题目.</p>
<p>如果进了区域赛, 那就得狠狠地锻炼了...</p>
<span id="more"></span>
<h2 id="重复局面">重复局面</h2>
<p><a href="https://www.acwing.com/problem/content/5084/">出处</a></p>
<p>题意: n 个 8*8 的象棋棋盘, 统计每种局面的出现次数.</p>
<p>例如 ABA, 那么输出 1 1 2. 其中 A 代表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">********</span><br><span class="line">******pk</span><br><span class="line">*****r*p</span><br><span class="line">p*pQ****</span><br><span class="line">********</span><br><span class="line">**b*B*PP</span><br><span class="line">****qP**</span><br><span class="line">**R***K*</span><br></pre></td></tr></table></figure>
<p>这样的一个模拟棋盘.</p>
<p>题解: 统计出现次数, 用一个简单的 Hash 解决. 一个棋盘就是一个
<code>string</code>(新的一行直接字符串拼接就行), 那么
<code>unordered_map&lt;string, int&gt;</code> 解决战斗.</p>
<h2 id="垦田计划">垦田计划</h2>
<p><a href="https://www.acwing.com/problem/content/5020/">导航</a></p>
<p>题意: 求 <span class="math inline">\(t_{总}=\max \{t_1, t_2, \dots,
t_n\}\)</span> 的最小值, 其中 <span class="math inline">\(t_i\)</span>
可投入 <span class="math inline">\(p \cdot c_i\)</span> 份的资源减少
<span class="math inline">\(p\)</span> 时间(总资源有 <span
class="math inline">\(m\)</span> 份), 但是缩减后的时间必须 <span
class="math inline">\(t_i&#39; \geqslant k\)</span>, 其中 <span
class="math inline">\(0 &lt; k \leqslant \min \{t_1, t_2, \dots,
t_n\}\)</span>.</p>
<p>题解: 水桶效应. 对时间枚举, 让最大值变成第二大, 一直到 <span
class="math inline">\(k\)</span>. 每次判断剩余是否足够. 如果有盈余就输出
<span class="math inline">\(k\)</span>.</p>
<p>二分做法: 对答案时间枚举. 符合单调性: <span class="math inline">\(l =
k, r= t_{max}\)</span>, 每次 check 答案所需资源是否大于 <span
class="math inline">\(m\)</span>.</p>
<h3 id="复习下二分板子">复习下二分板子</h3>
<p>lower_bound:</p>
<p>[l, r] --&gt; [l, mid] + [mid + 1, r]</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (l &lt; r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check</span>(mid))</span><br><span class="line">        r = mid;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>upper_bound:</p>
<p>[l, r] ---&gt; [l, mid - 1] + [mid, r]</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (l &lt; r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check</span>(mid))</span><br><span class="line">        l = mid;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ccc单词搜索">CCC单词搜索</h2>
<p>题意: 给定一个 <span class="math inline">\(R\times C\)</span>
的字符矩阵, 搜索目标单词 <span class="math inline">\(W\)</span>,
合法的单词出现:</p>
<ul>
<li>出现在一条直线上, 可以水平或者竖直.
<ul>
<li>可以正向, 可以反向.</li>
<li>还可以出现在斜45度线段中.</li>
</ul></li>
<li>单词出现在两条相互垂直且存在公共端点的线段上.</li>
</ul>
<p>数据量: <span class="math inline">\(2\leqslant|W|\leqslant
6\)</span>, <span class="math inline">\(1 \leqslant R, C \leqslant
100\)</span></p>
<p>样例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NATURE</span><br><span class="line">6</span><br><span class="line">9</span><br><span class="line">N A T S F E G Q N</span><br><span class="line">S A I B M R H F A</span><br><span class="line">C F T J C U C L T</span><br><span class="line">K B H U P T A N U</span><br><span class="line">D P R R R J D I R</span><br><span class="line">I E E K M E G B E</span><br></pre></td></tr></table></figure>
<figure>
<img src="/images/sample1.png" alt="示例" />
<figcaption aria-hidden="true">示例</figcaption>
</figure>
<p>题解: DFS + 位运算</p>
<p>搜索方向, 用 <code>dx</code>, <code>dy</code> 两个数组存放偏移量.</p>
<figure>
<img src="/images/pic17.png" alt="偏移量" />
<figcaption aria-hidden="true">偏移量</figcaption>
</figure>
<p>旋转操作可以用一个位运算的小技巧, 例如编号为 <code>0</code>
的方向旋转后的两个方向是 <code>2</code> (010) 和 <code>6</code> (110),
对应 <code>0 ^ 2</code> 以及 <code>0 ^ 2 ^ 4</code>.</p>
<p>实际上就是 0 + 2, 0 + 2 + 4, 但是对于例如 7 这样的数字会上溢,
位运算就免去了这个烦恼. 当然取模是可以获得相同的结果的.</p>
<p>枚举量: <span class="math inline">\(10000 \times 8 \times (5 \times 2
+ 1)\)</span> 大概是 1e6 的运算. 不用考虑 dp 优化.</p>
<p>我一直觉得 DFS 的代码很美观.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e2</span> + <span class="number">5</span>, M = <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> g[N][N], s[M];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dx[<span class="number">8</span>] = &#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[<span class="number">8</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> r, c, len, res;</span><br><span class="line"></span><br><span class="line"><span class="comment">// x, y: 坐标</span></span><br><span class="line"><span class="comment">// d: 方向编号</span></span><br><span class="line"><span class="comment">// u: 深度</span></span><br><span class="line"><span class="comment">// cnt: 旋转次数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> d, <span class="type">int</span> u, <span class="type">int</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x &gt;= r || y &gt;= c || g[x][y] != s[u])</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (u == len - <span class="number">1</span>)</span><br><span class="line">        res ++;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(x + dx[d], y + dy[d], d, u + <span class="number">1</span>, cnt);</span><br><span class="line">        <span class="keyword">if</span> (!cnt &amp;&amp; u)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(x, y, d ^ <span class="number">2</span>, u, cnt + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">dfs</span>(x, y, d ^ <span class="number">2</span> ^ <span class="number">4</span>, u, cnt + <span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; s &gt;&gt; r &gt;&gt; c;</span><br><span class="line">    len = <span class="built_in">strlen</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; r; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; c; j++)</span><br><span class="line">            cin &gt;&gt; g[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; r; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; c; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; k++)</span><br><span class="line">                <span class="built_in">dfs</span>(i, j, k, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// cin &gt;&gt; T;</span></span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对称山脉">对称山脉</h2>
<p><a href="https://www.luogu.com.cn/problem/P9325">传送</a></p>
<p>题意: <span class="math inline">\(n\)</span> 座山, 每座山有 <span
class="math inline">\(h_i\)</span>, 考虑一段连续区间 <span
class="math inline">\([l, r]\)</span>, 定义不对称值 <span
class="math inline">\(\displaystyle\sum_{0\leq i\leq\frac{r-l}2}\lvert
h_{l+i}-h_{r-i}\rvert\)</span>, 求在某一区间长度下,
不对称值的最小值.</p>
<p>不对称值可以理解为: 连续区间对称位置之间的差值之和.</p>
<p>例如 1 2 3 4 5 这个例子, 当区间长为 3 时, 需要枚举 123 234 345.</p>
<ul>
<li>123 的例子: <span
class="math inline">\(|h_1-h_3|+|h_2-h_2|=2\)</span></li>
<li>234 的例子: <span
class="math inline">\(|h_2-h_4|+|h_3-h_3|=2\)</span></li>
<li>...</li>
</ul>
<p>所以当区间长为 3 时最小值为 2.</p>
<p>数据范围: <span class="math inline">\(n\leqslant 5000\)</span></p>
<p>题解: 按照例子里的方法暴力枚举, 枚举区间长度, 枚举区间起点/终点,
计算差值求和, 时间复杂度为 <span class="math inline">\(O(n^3)\)</span>,
算上数据量是 1e11, 会爆. 需要优化为 <span
class="math inline">\(O(n^2)\)</span>.</p>
<p>观察:</p>
<ul>
<li>计算大区间的不对称值, 一部分已经在小区间里计算了.
<ul>
<li>例如 12345, 显然 234 已经在区间长为 3 的的时候过了计算了.</li>
<li>它们的中心点都是 3.</li>
</ul></li>
<li>考虑枚举中心点, 然后逐层往外循环枚举.
<ul>
<li>状态转移就是 <span class="math inline">\(f = f&#39; + |h_l -
h_r|\)</span></li>
</ul></li>
<li>答案取不对称值的最小值.</li>
<li>奇偶分开讨论.</li>
</ul>
<p>代码实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N], f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cin &gt;&gt; h[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> l = i, r = i, s = <span class="number">0</span>; l &gt;= <span class="number">0</span> &amp;&amp; r &lt; n; l--, r++)</span><br><span class="line">        &#123;</span><br><span class="line">            s += <span class="built_in">abs</span>(h[l] - h[r]);</span><br><span class="line">            f[r - l + <span class="number">1</span>] = <span class="built_in">min</span>(f[r - l + <span class="number">1</span>], s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> l = i, r = i + <span class="number">1</span>, s = <span class="number">0</span>; l &gt;= <span class="number">0</span> &amp;&amp; r &lt; n; l--, r++)</span><br><span class="line">        &#123;</span><br><span class="line">            s += <span class="built_in">abs</span>(h[l] - h[r]);</span><br><span class="line">            f[r - l + <span class="number">1</span>] = <span class="built_in">min</span>(f[r - l + <span class="number">1</span>], s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cout &lt;&lt; f[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// cin &gt;&gt; T;</span></span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二进制">二进制</h2>
<p><a
href="https://cemc.uwaterloo.ca/contests/computing/past_ccc_contests/2023/cco/day1.pdf">出处</a></p>
<p><a href="https://www.acwing.com/problem/content/5173/">题意</a></p>
<p>题解: 简易版扫雷. 给的 k 字串数字和序列类似于扫雷里雷的数字.
因为给的序列是连续的滑动区间, 相邻最多差 1, 根据这个数字可以确定 1
在二进制串中出现的位置.</p>
<p>例如样例的 3 2 2 2, [1, 4] 中有 3 个 1, [2, 5] 有 2 个 1, [2, 4]
是公共部分, 1 的个数是相同的, 而 [1, 4] 多一个 1, 说明第一个位置是 1,
第五个位置是 0.</p>
<p>对于 [3, 6], 可以确定位置 6 和位置 2 是相同的. 最终可以确定二进制串是
<code>1xyz0xy</code>, 要确定的只有第一个区间里的 3 个位置, 还需要 2 个
1, 因此方案数为 <span class="math inline">\(\binom{2}{3}=3\)</span>
个.</p>
<p>归纳可知</p>
<ul>
<li><code>a[i] == a[i+1]</code>: <code>s[i] = s[i+k]</code></li>
<li><code>a[i] &gt; a[i+1]</code>: <code>s[i] = 1</code>,
<code>s[i+k] = 0</code></li>
<li><code>a[i] &lt; a[i+1]</code>: <code>s[i] = 0</code>,
<code>s[i+k] = 1</code></li>
</ul>
<p>方案数 <span
class="math inline">\(\binom{k-c_1-c_0}{a[0]-c_1}\)</span>, 其中 <span
class="math inline">\(c_1\)</span> 是第一个区间 1 的个数, <span
class="math inline">\(c_0\)</span> 是第一个区间 0 的个数.</p>
<p>相同值的位置可以用一个并查集维护.</p>
<p>代码:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e6</span> + <span class="number">3</span>, N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a ^ b mod p</span></span><br><span class="line"><span class="function">LL <span class="title">q_pow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            res = res * a % MOD;</span><br><span class="line">        a = (LL) a * a % MOD;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL fa = <span class="number">1</span>, fb = <span class="number">1</span>, fab = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 只用算一次所以不用开 frac 数组了</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= a; i++)</span><br><span class="line">        fa = fa * i % MOD;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= b; i++)</span><br><span class="line">        fb = fb * i % MOD;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= a - b; i++)</span><br><span class="line">        fab = fab * i % MOD;</span><br><span class="line">    <span class="keyword">return</span> fa * <span class="built_in">q_pow</span>(fb, MOD - <span class="number">2</span>) % MOD * <span class="built_in">q_pow</span>(fab, MOD - <span class="number">2</span>) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// p: 并查集 父节点</span></span><br><span class="line"><span class="comment">// v: 值</span></span><br><span class="line"><span class="type">int</span> a[N], p[N], v[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x)</span><br><span class="line">        p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - k + <span class="number">1</span>; i++)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        p[i] = i, v[i] = <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = k; j &lt; n; i++, j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] == a[i + <span class="number">1</span>])</span><br><span class="line">            p[<span class="built_in">find</span>(i)] = <span class="built_in">find</span>(j);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[i] &lt; a[i + <span class="number">1</span>])</span><br><span class="line">            v[<span class="built_in">find</span>(i)] = <span class="number">0</span>, v[<span class="built_in">find</span>(j)] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            v[<span class="built_in">find</span>(i)] = <span class="number">1</span>, v[<span class="built_in">find</span>(j)] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> c0 = <span class="number">0</span>, c1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (v[<span class="built_in">find</span>(i)] == <span class="number">1</span>)</span><br><span class="line">            c1 ++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (v[<span class="built_in">find</span>(i)] == <span class="number">0</span>)</span><br><span class="line">            c0 ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; c0 &lt;&lt; &#x27; &#x27; &lt;&lt; c1 &lt;&lt; endl;</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">C</span>(k - c1 - c0, a[<span class="number">0</span>] - c1) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// cin &gt;&gt; T;</span></span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="并查集数学板子">并查集/数学板子</h3>
<p>并查集: 路径压缩</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x)</span><br><span class="line">        p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">equal</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find</span>(a) == <span class="built_in">find</span>(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>快速幂:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a^b mod p</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fpow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            res = (LL) res * a % p;</span><br><span class="line">        a = (LL) a * a % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>求阶乘: 逆元求法</p>
<p>原理</p>
<p><span class="math display">\[\binom{n}{m} =
\frac{m!}{n!(n-m)!}\]</span></p>
<p>在模 <span class="math inline">\(p\)</span> 意义下, 那么</p>
<p><span class="math display">\[\binom{n}{m} \equiv
m!(n!)^{-1}((n-m)!)^{-1} (\bmod p)\]</span></p>
<p>那么我们只用计算阶乘的乘法逆元即可.</p>
<p><span
class="math display">\[(n!)^{-1}=((n-1)!n)^{-1}=((n-1)!)^{-1}n^{-1}
(\bmod p)\]</span></p>
<p><span class="math inline">\(p\)</span> 是大质数, 利用费马小定理</p>
<p><span class="math display">\[n\equiv n^{p} (\bmod p)\Rightarrow
n^{-1}\equiv n^{p-2} (\bmod p)\]</span></p>
<p>于是</p>
<p><span class="math display">\[(n!)^{-1}=((n-1)!)^{-1}\cdot
n^{p-2}\]</span></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fpow</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> t = mod - <span class="number">2</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; t; t &gt;&gt;= <span class="number">1</span>, x = <span class="number">1ll</span> * x * x % mod)</span><br><span class="line">        <span class="keyword">if</span> (t &amp; <span class="number">1</span>) res = <span class="number">1ll</span> * res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fac[N], ifac[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span> * fac[n] * ifac[m] % mod * ifac[n - m] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = ifac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; ++i) fac[i] = <span class="number">1ll</span> * fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    ifac[N - <span class="number">1</span>] = <span class="built_in">fpow</span>(fac[N - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = N - <span class="number">2</span>; i; --i) ifac[i] = <span class="number">1ll</span> * ifac[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="所有三角形">所有三角形</h2>
<p><a href="https://www.acwing.com/problem/content/5167/">导航</a></p>
<p>模拟铺瓷砖. 每一个三角形对答案贡献 3, 但是有相连的情况对答案贡献 -2,
注意上下相连的情况如果是顶点相接则不会有影响.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; w[i][j];</span><br><span class="line">            <span class="keyword">if</span> (w[i][j])</span><br><span class="line">                res += <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">if</span> (j &amp;&amp; w[i][j] &amp;&amp; w[i][j - <span class="number">1</span>])</span><br><span class="line">                res -= <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &amp;&amp; j % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; w[i - <span class="number">1</span>][j])</span><br><span class="line">                res -= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分组">分组</h2>
<p><a href="https://www.acwing.com/problem/content/5182/">导航</a></p>
<p>题意: 有 <span class="math inline">\(x\)</span> 对人希望分在同一组,
<span class="math inline">\(y\)</span> 对人希望分在不同组, 现在有 <span
class="math inline">\(3G\)</span> 个人分成 <span
class="math inline">\(G\)</span> 组, 判断有多少意愿没有被满足.</p>
<p>题解: 哈希表存放 名字-&gt;组 的一个映射, 然后逐个判断每个意愿即可.
例如希望同组的, 就判断 <code>mp[a] != mp[b]</code>,
同理希望不同组的判断是否相同即可. 时间复杂度为 <span
class="math inline">\(O(n)\)</span>.</p>
<p>注意记得关闭 cin 同步或者采用 scanf.</p>
<h2 id="正方形泳池">正方形泳池</h2>
<p><a href="https://www.acwing.com/problem/content/5183/">导航</a></p>
<p>题意: <span class="math inline">\(N \times N\)</span> 的矩阵, 有
<span class="math inline">\(T\)</span> 棵树,
找到一个最大边长的正方形子矩阵, 使得内部不包含树.</p>
<p>题解: <span class="math inline">\(N\)</span> 太大, 转而枚举树,
理论上把 <span class="math inline">\(\binom{4}{t}\)</span>
的方案全部枚举, 然后求上下边界和左右边界距离的最小值即可. 复杂度是 <span
class="math inline">\(O(T^4)\)</span>.</p>
<p>如果问题变为 hard version, 也就是 T 的范围变到 <span
class="math inline">\(10^3\)</span> 那就不好办了. 这时候考虑优化.</p>
<p>我们考虑只枚举左右边界, 然后逐步缩小上下边界, 求出一个 <span
class="math inline">\(d\)</span>. 然后再枚举上下边界, 缩小左右边界得到
<span class="math inline">\(d&#39;\)</span>. 那么答案是 <span
class="math inline">\(\max\{d, d&#39;\}\)</span>.</p>
<figure>
<img src="/images/trees.png" alt="上下边界和右边树的位置相关" />
<figcaption aria-hidden="true">上下边界和右边树的位置相关</figcaption>
</figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">105</span>;</span><br><span class="line"><span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, t;</span><br><span class="line"></span><br><span class="line">PII tr[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sort</span>(tr, tr + t);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; t; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> up = n + <span class="number">1</span>, down = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; t; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (tr[i].x == tr[j].x)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (tr[j].x - tr[i].x &gt; up - down)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            res = <span class="built_in">max</span>(res, tr[j].x - tr[i].x - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (tr[j].y &gt;= tr[i].y)</span><br><span class="line">                up = <span class="built_in">min</span>(up, tr[j].y);</span><br><span class="line">            <span class="keyword">if</span> (tr[j].y &lt;= tr[i].y)</span><br><span class="line">                down = <span class="built_in">max</span>(down, tr[j].y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; t; i++)</span><br><span class="line">        cin &gt;&gt; tr[i].x &gt;&gt; tr[i].y;</span><br><span class="line"></span><br><span class="line">    tr[t++] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    tr[t++] = &#123;<span class="number">0</span>, n + <span class="number">1</span>&#125;;</span><br><span class="line">    tr[t++] = &#123;n + <span class="number">1</span>, n + <span class="number">1</span>&#125;;</span><br><span class="line">    tr[t++] = &#123;n + <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="built_in">work</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; t; i++)</span><br><span class="line">        <span class="built_in">swap</span>(tr[i].x, tr[i].y);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(ans, <span class="built_in">work</span>()) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// cin &gt;&gt; T;</span></span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="好四和好五">好四和好五</h2>
<p><a href="https://www.acwing.com/problem/content/5184/">来源</a></p>
<p>题意: 求 <span class="math inline">\(4x+5y=N\)</span>
的所有解的数量.</p>
<p>题解: 不定方程的一个特解 <span class="math inline">\(x_0=-N,
y_0=N\)</span>, 通解 <span class="math inline">\(x=x_0+5k\)</span>,
<span class="math inline">\(y=y_0-4k\)</span>, <span
class="math inline">\(k\)</span> 最小为 <span
class="math inline">\(\lfloor \frac{N}{5} \rfloor\)</span>, 最大 <span
class="math inline">\(\lceil \frac{N}{4} \rceil\)</span>.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> ans = n / <span class="number">4</span> - (n + <span class="number">4</span>) / <span class="number">5</span> + <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="街灯">街灯</h2>
<p><a href="https://www.acwing.com/problem/content/3727/">导航</a></p>
<h3 id="差分板子">差分板子</h3>
<p>差分: 给 [l, r] 区间的每个数加上 c</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[N], b[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[l] += c;</span><br><span class="line">    b[r + <span class="number">1</span>] -= c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="icpc-2022-网络赛-i">ICPC 2022 网络赛 I</h2>
<p><a
href="https://pintia.cn/market/item/1571156622976593920">出处</a></p>
<h3 id="c-delete-the-tree">C Delete the Tree</h3>
<p>题意: 删除一棵树, 有两种操作:</p>
<ul>
<li>删除: 选择一个点, 删除该节点以及它连着的边.</li>
<li>收缩: 选择一个度数为 2 的节点, 假设它是 <span
class="math inline">\(x\)</span>, 连着 <span
class="math inline">\(u,v\)</span>, 那么该操作将 <span
class="math inline">\(x, (u,x), (x,v)\)</span> 删去, 新建边 <span
class="math inline">\((u,v)\)</span>.</li>
</ul>
<p>求删除树的最小<strong>删除操作</strong>的次数.</p>
<p>题解: 观察到收缩操作可以将图中全部度数为 2 的节点删除,
剩下的要么是叶子, 要么是内部度数大于 2 的节点.</p>
<p>对于度数大于 2 的节点, 可以考虑先将与它相连的叶子删去, 使其度数转为
2, 然后通过收缩操作将其删去.</p>
<p>要进行删除的点只有叶子, 也就是度数为 1 的节点.</p>
<p>坑点:</p>
<ul>
<li>记得特判 <span class="math inline">\(n = 1\)</span> 的情况.</li>
<li>为什么 memset 会 T.</li>
</ul>
<h3 id="d-find-the-number">D Find the Number</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1e9</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (__builtin_ctz(i) == __popcount(i))</span><br><span class="line">            ans ++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>暴力打表可知这样好的数的个数一共约有 5e5 个. 如果我们知道了这些数,
然后放到一个集合里, 二分判断每次的查询就行了.</p>
<p>当然你不能暴力求这个"好数"的集合, 肯定会 TLE 的.</p>
<p>考虑枚举尾导零的个数, 例如 4, 最后五位是 10000, 剩下的 32 - 5
位就全排列, 这个可以用 <code>next_permutation</code> 枚举出来,
近似常数的.</p>
<p>这道题还可以数位DP + DFS 做, 但我不会.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">set&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">to_bit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; aa = a;</span><br><span class="line">    <span class="built_in">reverse</span>(aa.<span class="built_in">begin</span>(), aa.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; aa.<span class="built_in">size</span>(); j++)</span><br><span class="line">        res += (aa[j] &lt;&lt; j);</span><br><span class="line">    res &lt;&lt;= (i + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">    <span class="keyword">auto</span> it = st.<span class="built_in">lower_bound</span>(l);</span><br><span class="line">    <span class="keyword">if</span> (it == st.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x = *it;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= x &amp;&amp; x &lt;= r)</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 枚举尾导零的个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">15</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t.<span class="built_in">clear</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">30</span> - <span class="number">2</span> * i; j++)</span><br><span class="line">            a.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i - <span class="number">1</span>; j++)</span><br><span class="line">            a.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 全排列前面 30 - i - 1 个位置</span></span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> num = <span class="built_in">to_bit</span>(a, i) + (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            <span class="keyword">if</span> (num &lt;= M)</span><br><span class="line">                st.<span class="built_in">insert</span>(num);</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="a-01-sequence">A 01 Sequence</h3>
<p>题意: 给定 0-1 循环串(表示首位和末尾是相邻的), 可以进行两种操作</p>
<ul>
<li>删除: 如果 <span class="math inline">\(|S|\geqslant 3\)</span>,
那么选择 <span class="math inline">\(S_i = 1\)</span> 的第 <span
class="math inline">\(i\)</span> 位以及其相邻的位进行删除.</li>
<li>翻转: 将第 <span class="math inline">\(i\)</span> 位的 1 变为 0, 0
变为 1.</li>
</ul>
<p><strong>定义</strong> 如果 <span class="math inline">\(S\)</span>
可以通过删除操作置空, 则 <span class="math inline">\(S\)</span>
为好串.</p>
<p><strong>定义</strong> <span class="math inline">\(f(S)\)</span> 为令
<span class="math inline">\(S\)</span> 为好串的最小翻转操作数.</p>
<p>给定 0-1 串 <span class="math inline">\(a\)</span> 以及 <span
class="math inline">\(q\)</span> 个询问, 每个询问会给出 <span
class="math inline">\(l_i, r_i\)</span>, 任务是回答 0-1 串的一个字串
<span class="math inline">\(a_{l_i...r_i}\)</span> 的 <span
class="math inline">\(f(a_{l_i...r_i})\)</span>.</p>
<p>样例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">20 10</span><br><span class="line">00001000100000010000</span><br><span class="line">18 20</span><br><span class="line">14 16</span><br><span class="line">7 12</span><br><span class="line">2 10</span><br><span class="line">16 18</span><br><span class="line">6 20</span><br><span class="line">8 10</span><br><span class="line">13 15</span><br><span class="line">1 6</span><br><span class="line">1 12</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">3</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>前缀和 + 思维.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, s[N], suf[N], pre[N];</span><br><span class="line"><span class="type">char</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ll = l + pre[l], rr = r - suf[r];</span><br><span class="line">    <span class="keyword">if</span> (ll &gt;= rr)</span><br><span class="line">        <span class="keyword">return</span> (r - l + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> s[rr] - s[ll - <span class="number">1</span>] + (pre[l] + suf[r] + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">    <span class="type">int</span> len = r - l + <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(<span class="number">0</span>, len / <span class="number">3</span> - <span class="built_in">calc</span>(l, r)) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; T;</span><br><span class="line"></span><br><span class="line">    a[<span class="number">0</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    cin &gt;&gt; a + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 区间的个数</span></span><br><span class="line">    <span class="type">int</span> last = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (last != i - <span class="number">1</span>)</span><br><span class="line">                s[i] = <span class="number">1</span>, last = i;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                last = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s[i] += s[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左边数起 结尾为 i 连续 1 的个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">            suf[i] = suf[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            suf[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">            pre[i] = pre[i + <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Python OOP Cookbook</title>
    <url>/2023/09/25/Python-OOP/</url>
    <content><![CDATA[<p>学习数据结构一个重要的点是<strong>数据抽象</strong>,
也是计算机人毕生所追求的理念: 将现实世界的问题抽象成形式语言,
变为<em>计算机可读</em>的数据. 这种数据的组织结构,
在<em>面向对象编程</em>(<strong>O</strong>bject
<strong>O</strong>riented <strong>P</strong>rogramming)范式中,
被抽象成一个<strong>类</strong>, 这也是 OOP 的核心.</p>
<p>Python 的 OOP 和其它语言有些细微的差距, 但是 Python 本身作为一门 OOP
语言, 自然在机制的实现上不输他者. 正好这学期的 DSA 拿 Python 教学,
正好也想更系统地学习 OOP, 遂有了这篇文章的产生.</p>
<span id="more"></span>
<h2 id="before-作用域与命名空间">Before: 作用域与命名空间</h2>
<ul>
<li><code>namespace</code> 各位肯定不陌生.
命名空间表示<em>名称到对象的映射</em>.
<ul>
<li>是个标识符, 指向不同的内存区域.</li>
<li>有它, 两个不同模块就都可以定义例如 <code>max</code>, 且不会混淆
<code>A.max</code>, <code>B.max</code></li>
<li>命名空间是<em>隐式</em>创建的. Python 里莫得 <code>namespace</code>
关键字.</li>
</ul></li>
<li>点后面的名称称为<strong>属性</strong>(<em>attribute</em>).
<ul>
<li><code>math.sqrt</code> <code>math</code> 是模块对象,
<code>sqrt</code> 是模块的属性.</li>
</ul></li>
</ul>
<p>属性是可读可写的. 例如, 可以如下操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> my_module</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_module.answer</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> my_module.answer</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_module.answer</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: module <span class="string">&#x27;my_module&#x27;</span> has no attribute <span class="string">&#x27;answer&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>命名空间在不同时刻创建, 拥有不同的生命周期.
<ul>
<li><code>builtins</code> 的 namespace 就是 Python
解释器一打开就创建的.</li>
<li>模块的全局命名空间在读取模块定义时创建(合理).</li>
</ul></li>
<li>函数的局部命名空间: 函数调用时创建
<ul>
<li><code>return</code> / <code>raise ...Exception()</code>
之后就没了(或者说, 被"遗忘"了)</li>
</ul></li>
</ul>
<blockquote>
<p>大慈树王对小草神说: 把关于我的知识放到函数栈上.</p>
</blockquote>
<ul>
<li>命名空间的<strong>作用域</strong>(scope):
这个区域里<em>可以直接访问</em>该命名空间
<ul>
<li>可以直接访问?</li>
<li>把查找范围扩大到这个命名空间</li>
</ul></li>
<li>问题: 如果 count 在局部定义了一个, 全局定义了一个, 找的是谁
<ul>
<li>原则: <strong>从内向外</strong></li>
<li>内层(局部) -&gt; 外层闭包函数的作用域 -&gt; 全局 -&gt; builtins
namespace</li>
</ul></li>
<li><code>nonlocal</code> 关键字
<ul>
<li>很直接, 在外层作用域里重新绑定(总之不是局部变量, 往上层找)</li>
<li>也很好理解这个错误 SyntaxError: nonlocal declaration not allowed at
module level</li>
</ul></li>
<li><code>global</code> 关键字
<ul>
<li>表明某一变量在全局作用域</li>
</ul></li>
</ul>
<h3 id="实验-1-作用域一二事">实验 1: 作用域一二事</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">scope_test</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_local</span>():</span><br><span class="line">        spam = <span class="string">&quot;local spam&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_nonlocal</span>():</span><br><span class="line">        <span class="keyword">nonlocal</span> spam</span><br><span class="line">        spam = <span class="string">&quot;nonlocal spam&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_global</span>():</span><br><span class="line">        <span class="keyword">global</span> spam</span><br><span class="line">        spam = <span class="string">&quot;global spam&quot;</span></span><br><span class="line"></span><br><span class="line">    spam = <span class="string">&quot;test spam&quot;</span></span><br><span class="line">    do_local()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;After local assignment:&quot;</span>, spam)</span><br><span class="line">    do_nonlocal()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;After nonlocal assignment:&quot;</span>, spam)</span><br><span class="line">    do_global()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;After global assignment:&quot;</span>, spam)</span><br><span class="line"></span><br><span class="line">scope_test()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;In global scope:&quot;</span>, spam)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">After local assignment: test spam</span><br><span class="line">After nonlocal assignment: nonlocal spam</span><br><span class="line">After global assignment: nonlocal spam</span><br><span class="line">In global scope: global spam</span><br></pre></td></tr></table></figure>
<h2 id="类">类</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li>进入类会创建一个新的命名空间, 并将其作用于局部作用域</li>
<li>离开类定义, 将创建一个<em>类对象</em>.</li>
</ul>
<p>Python 类的定义很简单, 没有额外的关键字限定.</p>
<ul>
<li>类对象支持两种操作</li>
</ul>
<ol type="1">
<li><em>属性引用</em>: <code>obj.name</code></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    i = <span class="number">12345</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;a&#x27;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>A.i</span><br><span class="line"><span class="number">12345</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A.f</span><br><span class="line">&lt;function A.f at <span class="number">0x7fb863b1f9a0</span>&gt;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li><em>实例化</em>: <code>instance = ClassName()</code></li>
</ol>
<ul>
<li>构造函数 <code>__init__()</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, realpart, imagpart</span>):</span><br><span class="line">        self.r = realpart</span><br><span class="line">        self.i = imagpart</span><br><span class="line"></span><br><span class="line">x = Complex(<span class="number">3.0</span>, -<span class="number">4.5</span>)</span><br><span class="line">x.r, x.i</span><br></pre></td></tr></table></figure>
<h3 id="类实例变量">类/实例变量</h3>
<ul>
<li>类变量: 所有实例共享</li>
<li>实例变量: 单独实例唯一数据
<ul>
<li>如果同名, 优先是实例变量.</li>
</ul></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    x = <span class="number">10</span>  <span class="comment"># class variable</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):   <span class="comment"># instance variable</span></span><br><span class="line">        self.name = name</span><br></pre></td></tr></table></figure>
<h2 id="继承">继承</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedClass</span>(<span class="title class_ inherited__">BaseClass</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li>派生类如果找不到某一属性, 就递归式地查找基类</li>
<li>派生类里的方法自带 C++ 里面的 <code>virtual</code> 关键字,
也就都是虚函数</li>
<li>继承机制有用的两个内置函数:
<ul>
<li><code>isinstance</code>: 检查一个类的实例类型
<ul>
<li><code>isinstance(2, int)</code> <code>True</code></li>
</ul></li>
<li><code>issubclass</code>: 检查类的继承关系
<ul>
<li><code>issubclass(bool, int)</code> <code>True</code></li>
</ul></li>
</ul></li>
</ul>
<h3 id="多重继承">多重继承</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedClassName</span>(Base1, Base2, Base3):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li>搜索父类的顺序?
<ul>
<li>DFS, 从左往右?</li>
<li>万一搜索过程中遇到相同的父类怎么办...</li>
</ul></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">method</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;CommonA&quot;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">method</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;CommonC&quot;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>(B, C):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">D().method()</span><br></pre></td></tr></table></figure>
<ul>
<li>搜索顺序: D-&gt;B-&gt;A-&gt;C-&gt;A
<ul>
<li>A 在前, 所以输出的是 A 的 method.</li>
</ul></li>
<li>需要一套新的方法解析顺序(Method Resolution Order, MRO)算法
<ul>
<li>有重复, 只保留最后一个 <code>A</code>?</li>
<li>然而单调性不能保证...</li>
</ul></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Y</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(X, Y):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(Y, X):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(A, B):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>按照上面的遍历方式</p>
<ul>
<li><code>A-&gt;X-&gt;Y-&gt;object</code></li>
<li><code>B-&gt;Y-&gt;X-&gt;object</code></li>
<li><code>C-&gt;A-&gt;B-&gt;X-&gt;Y-&gt;object</code>
<ul>
<li>等等, B 怎么先去遍历 X 了...</li>
</ul></li>
</ul>
<p>Python 的 MRO 算法采用了一种 C3 方法, 它是一种很精巧的线性化算法.
在这里就不过多讨论了.</p>
<h2 id="封装与私有变量">封装与私有变量</h2>
<ul>
<li>没有 <code>private</code> 关键字</li>
<li>只有一套编码约定: 带一个下划线 <code>_x</code> API 的非共有部分
<ul>
<li>其实你是可以访问的, 不会报错</li>
<li>伪私有性</li>
</ul></li>
<li>名称改写机制(name mangling)
<ul>
<li>想让 <code>__init__</code> 调用的父类的 update, 但不被子类版本的
override</li>
<li>双下划线 <code>__x</code></li>
<li>最后会改名成 <code>_ClassName__x</code></li>
</ul></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mapping</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, iterable</span>):</span><br><span class="line">        self.items = []</span><br><span class="line">        self.__update(iterable)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, iterable</span>):</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> iterable:</span><br><span class="line">            self.items.append(item)</span><br><span class="line">    <span class="comment"># _Mapping__update</span></span><br><span class="line">    __update = update</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MappingSubclass</span>(<span class="title class_ inherited__">Mapping</span>):</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, keys, values</span>):</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">zip</span>(keys, values):</span><br><span class="line">            self.items.append(item)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>MappingSubclass._Mapping__update</span><br><span class="line">&lt;function Mapping.update at <span class="number">0x7ffa754cba30</span>&gt;</span><br></pre></td></tr></table></figure>
<h2 id="c-风格结构体">C 风格结构体</h2>
<ul>
<li>用 <code>dataclass</code> 的一个装饰器</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> dataclasses <span class="keyword">import</span> dataclass</span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span>:</span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    dept: <span class="built_in">str</span></span><br><span class="line">    salary: <span class="built_in">int</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>john = Employee(<span class="string">&#x27;john&#x27;</span>, <span class="string">&#x27;computer lab&#x27;</span>, <span class="number">1000</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>john.dept</span><br><span class="line"><span class="string">&#x27;computer lab&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="迭代器和生成器">迭代器和生成器</h3>
<h2 id="参考资料">参考资料</h2>
<ol type="1">
<li><a
href="https://docs.python.org/zh-cn/3/tutorial/classes.html">Python 文档
- 类</a></li>
<li><a href="https://www.python.org/download/releases/2.3/mro/">多重继承
C3 方法</a></li>
</ol>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>我的刷题日记</title>
    <url>/2023/09/25/%E4%B9%9D%E6%9C%88%E4%BD%A0%E5%88%B7%E9%A2%98%E4%BA%86%E5%90%97/</url>
    <content><![CDATA[<p>悲报: 要去CCPC桂林赛区坐牢了.</p>
<p>校赛被队友带飞了, 身不由己, 现在希望自己要打出点成绩不要太丢脸.
从今天开始高强度刷题. Codeforces Div 1/2 一题不落, Atcoder ABC 狠狠开刷,
区域赛的 vp 狠狠开打...</p>
<p>就看看我又没有恒心做到日更了, 不管怎的先开个究极大坑在这里.</p>
<span id="more"></span>
<h1 id="educational-codeforces-round-155-rated-for-div.-2">Educational
Codeforces Round 155 (Rated for Div. 2)</h1>
<p>9.25 补</p>
<h2 id="a.-rigged">A. Rigged!</h2>
<p>题意: <span class="math inline">\(n\)</span> 个人举重比赛, 每个人有
<span class="math inline">\(s\)</span> 和 <span
class="math inline">\(e\)</span>, 代表最大举重重量和举重次数, 确定一个
<span class="math inline">\(w&gt;0\)</span> 使得第一个人能赢. 反之输出
-1.</p>
<p>题解: 如果 <span class="math inline">\(s_i \geqslant s_0\)</span> 且
<span class="math inline">\(e_i \geqslant e_0\)</span> 无解,
如果有解答案不超过 <span class="math inline">\(s_0\)</span>.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, s1, e1;</span><br><span class="line">    <span class="type">bool</span> ok = <span class="literal">true</span>;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; s1 &gt;&gt; e1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> s, e;</span><br><span class="line">        cin &gt;&gt; s &gt;&gt; e;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= s1 &amp;&amp; e &gt;= e1)</span><br><span class="line">            ok = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; (ok ? s1 : <span class="number">-1</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="comment">// freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="b.-chips-on-the-board">B. Chips on the Board</h2>
<p>题意: 一个 <span class="math inline">\(n\times n\)</span> 的矩阵,
每一列或者每一行都要有一个 chip, 摆放 chip 需要 <span
class="math inline">\(a_i + b_j\)</span> 的代价, 求最小代价.</p>
<p>题解: 在同一列的话只要让那一行最小就可以, 反之亦然, 然后取一个 min
就可以了.</p>
<p>注意 a 求和会爆 int, 不过开 LL 应该是基操了.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    LL sa = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> mina = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        sa += a;</span><br><span class="line">        mina = <span class="built_in">min</span>(mina, a);</span><br><span class="line">    &#125;</span><br><span class="line">    LL sb = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> minb = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> b;</span><br><span class="line">        cin &gt;&gt; b;</span><br><span class="line">        sb += b;</span><br><span class="line">        minb = <span class="built_in">min</span>(minb, b);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">min</span>(sa + <span class="number">1LL</span> * minb * n, sb + <span class="number">1LL</span> * mina * n) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="comment">// freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="c.-make-it-alternating">C. Make it Alternating</h2>
<p>题意: 给定一个 01 字符串 <span class="math inline">\(s\)</span>,
可以删去 <span class="math inline">\(s_i\)</span>, 要求让相邻字符不同,
求最小操作数以及操作方案.</p>
<p>题解: 例如 <code>100001</code> -&gt; <code>101</code> 长度为 <span
class="math inline">\(n\)</span> 的连续区间要删去 <span
class="math inline">\(n - 1\)</span> 个字符, 方案数是 <span
class="math inline">\(\binom{n}{n-1}=n\)</span> 个,
方案数乘法原理累计起来, 排列一下删除字符的操作 <span
class="math inline">\(\text{ans}!\)</span> 就是方案数.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">998244353</span>, N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL ans = <span class="number">0</span>, ways = <span class="number">1</span>;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span> (j + <span class="number">1</span> &lt; n &amp;&amp; s[j + <span class="number">1</span>] == s[j])</span><br><span class="line">            j++;</span><br><span class="line">        <span class="type">int</span> len = j - i + <span class="number">1</span>;</span><br><span class="line">        ans += len - <span class="number">1</span>;</span><br><span class="line">        ways = ways * len % MOD;</span><br><span class="line">        i = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= ans; i++)</span><br><span class="line">        ways = ways * i % MOD;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; ways &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="comment">// freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="双指针算法复习">双指针算法复习</h3>
<p>求连续区间长度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j = i;</span><br><span class="line">    <span class="keyword">while</span> (j + <span class="number">1</span> &lt; n &amp;&amp; s[j + <span class="number">1</span>] == s[j])</span><br><span class="line">        j++;</span><br><span class="line">    <span class="type">int</span> len = j - i + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    i = j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>求最长连续不重复子区间长度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s[a[i]] ++;</span><br><span class="line">        <span class="keyword">while</span> (s[a[i]] &gt; <span class="number">1</span>)</span><br><span class="line">            s[a[j++]] --;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, i - j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="d.-sum-of-xor-functions">D. Sum of XOR Functions</h2>
<p>题意: 计算一个求和</p>
<p><span
class="math display">\[\sum_{l=1}^n\sum_{r=l}^nf(l,r)\cdot(r-l+1)\]</span></p>
<p>这里 <span class="math inline">\(f(l,r)=a_l\oplus
a_{l+1}\oplus\cdots\oplus a_{r-1}\oplus a_r\)</span> 表示一个异或和.</p>
<p>题解:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">const</span> <span class="type">int</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ModInt</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">static</span> <span class="type">int</span> mod = T;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">ModInt</span>(<span class="type">int</span> x = <span class="number">0</span>) : <span class="built_in">x</span>(x % mod) &#123;&#125;</span><br><span class="line">    <span class="built_in">ModInt</span>(<span class="type">long</span> <span class="type">long</span> x) : <span class="built_in">x</span>(<span class="built_in">int</span>(x % mod)) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">val</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">    ModInt <span class="keyword">operator</span>+(<span class="type">const</span> ModInt &amp;a) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x0 = x + a.x;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ModInt</span>(x0 &lt; mod ? x0 : x0 - mod);</span><br><span class="line">    &#125;</span><br><span class="line">    ModInt <span class="keyword">operator</span>-(<span class="type">const</span> ModInt &amp;a) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x0 = x - a.x;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ModInt</span>(x0 &lt; <span class="number">0</span> ? x0 + mod : x0);</span><br><span class="line">    &#125;</span><br><span class="line">    ModInt <span class="keyword">operator</span>*(<span class="type">const</span> ModInt &amp;a) <span class="type">const</span> &#123; <span class="keyword">return</span> <span class="built_in">ModInt</span>(<span class="number">1LL</span> * x * a.x % mod); &#125;</span><br><span class="line">    ModInt <span class="keyword">operator</span>/(<span class="type">const</span> ModInt &amp;a) <span class="type">const</span> &#123; <span class="keyword">return</span> *<span class="keyword">this</span> * a.<span class="built_in">inv</span>(); &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> ModInt &amp;a) <span class="type">const</span> &#123; <span class="keyword">return</span> x == a.x; &#125;;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> ModInt &amp;a) <span class="type">const</span> &#123; <span class="keyword">return</span> x != a.x; &#125;;</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span>+=(<span class="type">const</span> ModInt &amp;a)</span><br><span class="line">    &#123;</span><br><span class="line">        x += a.x;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= mod)</span><br><span class="line">            x -= mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span>-=(<span class="type">const</span> ModInt &amp;a)</span><br><span class="line">    &#123;</span><br><span class="line">        x -= a.x;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">            x += mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span>*=(<span class="type">const</span> ModInt &amp;a) &#123; x = <span class="number">1LL</span> * x * a.x % mod; &#125;</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span>/=(<span class="type">const</span> ModInt &amp;a) &#123; *<span class="keyword">this</span> = *<span class="keyword">this</span> / a; &#125;</span><br><span class="line">    <span class="keyword">friend</span> ModInt <span class="keyword">operator</span>+(<span class="type">int</span> y, <span class="type">const</span> ModInt &amp;a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x0 = y + a.x;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ModInt</span>(x0 &lt; mod ? x0 : x0 - mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> ModInt <span class="keyword">operator</span>-(<span class="type">int</span> y, <span class="type">const</span> ModInt &amp;a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x0 = y - a.x;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ModInt</span>(x0 &lt; <span class="number">0</span> ? x0 + mod : x0);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> ModInt <span class="keyword">operator</span>*(<span class="type">int</span> y, <span class="type">const</span> ModInt &amp;a) &#123; <span class="keyword">return</span> <span class="built_in">ModInt</span>(<span class="number">1LL</span> * y * a.x % mod); &#125;</span><br><span class="line">    <span class="keyword">friend</span> ModInt <span class="keyword">operator</span>/(<span class="type">int</span> y, <span class="type">const</span> ModInt &amp;a) &#123; <span class="keyword">return</span> <span class="built_in">ModInt</span>(y) / a; &#125;</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="type">const</span> ModInt &amp;a) &#123; <span class="keyword">return</span> os &lt;&lt; a.x; &#125;</span><br><span class="line">    <span class="keyword">friend</span> istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream &amp;is, ModInt &amp;t) &#123; <span class="keyword">return</span> is &gt;&gt; t.x; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ModInt <span class="title">pow</span><span class="params">(<span class="type">int64_t</span> n)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">ModInt <span class="title">res</span><span class="params">(<span class="number">1</span>)</span>, <span class="title">mul</span><span class="params">(x)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &amp; <span class="number">1</span>)</span><br><span class="line">                res *= mul;</span><br><span class="line">            mul *= mul;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ModInt <span class="title">inv</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> a = x, b = mod, u = <span class="number">1</span>, v = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = a / b;</span><br><span class="line">            a -= t * b;</span><br><span class="line">            <span class="built_in">swap</span>(a, b);</span><br><span class="line">            u -= t * v;</span><br><span class="line">            <span class="built_in">swap</span>(u, v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (u &lt; <span class="number">0</span>)</span><br><span class="line">            u += mod;</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">using</span> mint = ModInt&lt;<span class="number">998244353</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; s[i], s[i] ^= s[i - <span class="number">1</span>];</span><br><span class="line">    mint ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">30</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        mint cnt[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, sum[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> bit = (s[j] &gt;&gt; i &amp; <span class="number">1</span>);</span><br><span class="line">            ans += (j * cnt[bit ^ <span class="number">1</span>] - sum[bit ^ <span class="number">1</span>]) * (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            cnt[bit] += <span class="number">1</span>;</span><br><span class="line">            sum[bit] += j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="拆位技巧">拆位技巧</h3>
<p><a href="https://zhuanlan.zhihu.com/p/647165385">参考:
一类二进制拆位算贡献的题目</a></p>
<p>考虑每一位的贡献. 例如</p>
<p><span class="math display">\[\sum_{i=1}^n\sum_{j=1}^n(a_i\oplus
a_j)\]</span></p>
<p>考虑的是</p>
<p><span
class="math display">\[\sum_{k=0}^m2^k\times\sum_{j=1}^n[bit_{i,k}\neq
bit_{j,k}]\]</span></p>
<ul>
<li>如果 <span class="math inline">\(bit_{i,k}=0\)</span>, 考虑 <span
class="math inline">\(bit_{j,k_1} = 1\)</span> 的 <span
class="math inline">\(k_1\)</span> 个数, 答案就是 <span
class="math inline">\(2^k \cdot cnt_{k_1}\)</span>.</li>
<li>如果 <span class="math inline">\(bit_{i,k}=1\)</span>, 考虑 <span
class="math inline">\(bit_{j,k_1} = 0\)</span> 的 <span
class="math inline">\(k_0\)</span> 个数, 答案就是 <span
class="math inline">\(2^k \cdot cnt_{k_0}\)</span>.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="type">int</span> f[<span class="number">2</span>][<span class="number">35</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">30</span>; j++)</span><br><span class="line">            f[(a[i] &lt;&lt; j) &amp; <span class="number">1</span>][j] ++;</span><br><span class="line"></span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">30</span>; j++)</span><br><span class="line">            ans += f[((a[i] &lt;&lt; j) &amp; <span class="number">1</span>) ^ <span class="number">1</span>][j] * (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
