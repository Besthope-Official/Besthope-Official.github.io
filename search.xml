<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2022年终总结</title>
    <url>/2022/12/31/2022%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>你会用什么关键字概括2022年呢...... 各种意义上的Twist. 人生的转折,
政策的转折, 世界的转折. 年初的时候还祝福今年诸事皆顺,
不过心意到了抽签抽到凶也没办法.</p>
<span id="more"></span>
<h2 id="人生的转折">人生的转折</h2>
<h3 id="上半年">上半年</h3>
<p>年初还在高三上的课堂, 年末大一上快结束了. 弹指一瞬所谓如此.</p>
<p>今年的大事, 要说还是高考. 忍受了高中三年那非人的安排就为了一张文凭,
可有人还要把这个过程拉长到研究生阶段.
不过也没必要过分批判中学的应试教育. 虽然阴郁得让人抬不起头, 但回忆高中,
除了黑历史, 剩下快乐的也不少. 除此之外,
高中接受的通识教育是我受益最大的. 当我阳了以后,
那些学习的生物知识很庆幸还能用 (bushi</p>
<p>最终去向是某财经211的CS专业. 一开始还在思考怎么自救. 现在想想,
自己的赛道还算广阔. 至少学历坎越过双非, 择业方向可金融可CS,
但最重要的是, 专业是自己喜欢的.
一想到自己下一个志愿的专业是机械电子我就魂打颤.</p>
<h3 id="下半年">下半年</h3>
<p>总结一下自己大一学的知识:</p>
<ul>
<li>更深入地学习了C语言</li>
<li>学习了CMU CS15-213 CSAPP前3章+第五章 完成了data/bomb/attack lab
<ul>
<li>学习了数据的机器级表示</li>
<li>用 wsl 作为 Linux 的开发环境</li>
<li>比较全面地学习了x86-64的汇编 同时有逆向工程的一定能力</li>
</ul></li>
<li>学习了MIT Missing Semester
<ul>
<li>学习到了很多实用工具 Git GDB Docker</li>
</ul></li>
<li>加入了学校里一个组织的后端部
<ul>
<li>其实没干啥 (小声bb</li>
</ul></li>
<li>搭建了自己的博客 Hexo+NexT</li>
<li>初步学习了算法/数据结构</li>
<li>数学微积分上册</li>
</ul>
<p>挺内疚的, 来大学的一个月, 非常勤勉, 天天跑图书馆, Github每天更新,
然后越到后面越咸鱼. 11月12月好像就没去过图书馆(</p>
<p>剩下的学习时间大部分浪费在了那些通识基础课上. 没错, 说的就是你,
大学物理( 其实我的大一上还是比较悠闲的. 虽然每天早八,
但基本上下午没啥课. 下学期就不是这样了.</p>
<p>感觉学了挺多编程相关的内容. 不过, 自己的编程能力仍然有待提高.
依然处于不STFW就寸步难行的阶段.</p>
<h3 id="新年期许">新年期许</h3>
<p>给自己的学习计划. 看看下学期能实现多少: 大一寒假: ACWing 算法基础课 +
每日一题 顺便打游戏+过了科二 主要提高自己的算法基础+编程能力</p>
<p>大一下的学习计划: 这学期数学基础课比较多 多元微积分 离散数学
高等代数等 大概率学习时间会很压缩 程序课我选的 Python(另一个选项是JAVA)
对应 CS61A (Python) + SICP 狠狠地学 下学期顺便把 Berkeley 的 CS70
(Discrete Math) 刷完</p>
<p>1.31 Update 寒假每日一题基本上做完了 算法基础课才是大头 汗
拿了驾照了hh</p>
<h2 id="政策的转折">政策的转折</h2>
<p>今年政策风向的变动大家有目共睹. 如果可以, 不妨回顾这一年新闻的<a
href="https://www.bilibili.com/video/BV1QM411C7kd/">合订本</a>.</p>
<p>我们每个人都是疫情的亲历者.
武汉疫情爆发初期的寒假(2020年初)我待在温州,
没料想当时温州市区属于重灾区. 封在老家大概持续了3个月. 2021年的暑期,
常熟疫情, 线上网课. 2022年4月苏州疫情, 常熟的高中开始封校.
在学校隔绝学习了一个月, 第一次感到自己的压抑.
还记得五一还有各种节日自己窝在寝室里画画. 真的非常无聊的日子.
第一次学会玩象棋. 2022年8月, 四川高温限电, 我是月底到的程度,
此时限电基本结束. 9月, 成都疫情. 又封校了一个月. 2022年12月, 国家放开.
12月28日, 我感染了新冠, 近年来最难受的几天.</p>
<p>本来以为能这辈子不感染, 结果下一秒打脸 :(</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>前缀函数和KMP算法</title>
    <url>/2022/12/21/KMP%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>做期末大作业里面有个字符串匹配的问题, 用暴力算法做完觉得不够爽,
于是自找的麻烦.</p>
<p>想用最简明的方式去解释这个较为抽象的算法! 事实上明白了一个道理:
缺乏数学的算法都是玄学, 只有数学证明了才能让人心服口服......</p>
<span id="more"></span>
<p>问题: 在一个<strong>文本串</strong>(<code>s</code>,
也称主串)中找到一个<strong>匹配串</strong>(<code>p</code>),
返回它在文本串中的下标. 如果无法匹配返回<code>-1</code>.</p>
<h2 id="前言-暴力解决问题">前言: 暴力解决问题</h2>
<p>思路很明了: 用指针<code>i</code>遍历<code>s</code>,
<code>j</code>遍历<code>p</code>. 具体的遍历过程</p>
<ul>
<li><strong>指针移动</strong> <code>s[i]</code>是否匹配<code>p[j]</code>
<ol type="1">
<li>如果匹配, 则后移<code>j</code>指针,
比较<code>p</code>后继字符是否和<code>s</code>中的一致.</li>
<li>如果不匹配, 那么后移<code>i</code>指针,
并将<code>j</code>指针重新设置为<code>0</code>.</li>
</ol></li>
<li><strong>终止条件</strong>
当<code>j</code>指针指向<code>p</code>最后一个字符, 说明匹配完成.
这时候就可以输出<code>i - j</code>的值, 作为匹配串在文本串中的索引.</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bf</span><span class="params">(<span class="type">char</span> *s, <span class="type">char</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (s[i] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == p[j])</span><br><span class="line">            i++, j++;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            i -= j; i++; j = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p[j] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> i - j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度分析: 考虑最坏情况, $O(|P| (|S|+|P|-1)) = O(|P||S|) $,
也就是 <span class="math inline">\(O(nm)\)</span>.</p>
<h2 id="预备知识">预备知识</h2>
<h3 id="字符串基础">字符串基础</h3>
<p><strong>子串</strong>: 串中任意个连续的字符组成的子序列.</p>
<p><strong>字符串前缀</strong>:
一个字符串的<strong>全部头部组合</strong>,
但<strong>不包括自身</strong>.</p>
<blockquote>
<p>严格来说, KMP讨论的是字符串的真前缀.</p>
</blockquote>
<p>例子: <code>abcab</code> 的前缀(集合)为
<code>&#123;a, ab, abc, abca&#125;</code></p>
<p>同样的有<strong>字符串后缀</strong>, 按上面的例子, 后缀(集合)就应该为
<code>&#123;b, ab, cab, bcab&#125;</code>.</p>
<h3 id="前缀函数">前缀函数</h3>
<p>给定长度<code>n</code>的字符串<code>s</code>,
其<strong>前缀函数</strong>定义为长度为<code>n</code>的数组<span
class="math inline">\(\pi\)</span>, 其中<span
class="math inline">\(\pi[i]\)</span>是子串<code>s[0...i]</code><strong>最长的相等前缀和后缀长度</strong>.
具体来说:</p>
<ul>
<li><span class="math inline">\(\pi[0]\)</span> = 0.
因为此时无前缀及后缀.(对于部分实现可能会规定其为<code>-1</code>)</li>
<li>如果子串有一对相同的前后缀, 那么 <span
class="math inline">\(\pi[i]\)</span> 就等于这个前缀(或后缀)的长度.
如果存在多对, 那么就是它们中的最大值.</li>
</ul>
<p>例如, 对于<code>abcab</code>, <code>pi[0] = 0</code>,
<code>pi[1] = 0</code>, <code>pi[2] = 0</code>, <code>pi[3] = 1</code>,
<code>pi[4] = 2</code>. 那么它的前缀函数就为
<code>&#123;0, 0, 0, 1, 2&#125;</code>.</p>
<p>优雅求得一个字符串的前缀函数是件并不容易的事情.
我们会在下面接着讨论.</p>
<h2 id="kmp-算法就是状态机">KMP 算法就是状态机</h2>
<p>所谓算法, 就是把暴力穷举优化成聪明的枚举. 这句话对KMP算法同样适用:
利用<strong>匹配失败后的信息</strong>,
<strong>减少</strong>模式串和文本串的<strong>匹配次数</strong>.</p>
<p>在暴力算法中, 每当<code>s[i] != p[j]</code>, <code>j</code>
被重新设置为<code>0</code>, 而<code>i</code>回溯到匹配前的位置,
同时只自增<code>1</code>. 我们的目的是:
减少算法复杂度<code>O(nm)</code>中的<code>n</code>,
也即减少不必要的匹配次数, 换句话说, 要么动态增加<code>i</code>的步长;
要么不回溯<code>i</code>, 让<code>i</code>一直自增下去.</p>
<p>为了实现这一点, 我们需要利用一切匹配失败前获取的信息.
而在匹配失败之前, 有字符是匹配的:
<strong>文本串的一部分等于模式串的一段前缀</strong>.</p>
<p>如果我们能跳过不可能成功匹配的字段, 就可以有效减少匹配的次数.</p>
<figure>
<img src="/images/pic.png" alt="skip" />
<figcaption aria-hidden="true">skip</figcaption>
</figure>
<p>如图所示, 如果能够跳过中间标蓝的不必要的匹配(第一个字符都失败了,
明显不可能匹配成功), 就可以大幅减少我们的匹配次数.</p>
<p>我们要做的实际上就一件事:
<strong>让文本串的一段对上匹配串的一段前缀</strong>,
而且跳过越多不必要的匹配越好. 跳过的这个长度在我们匹配失败前就应确定,
根据已有的信息, 这个<strong>最优长度</strong>是
<strong><code>s</code>子串的后缀和<code>p</code>子串的前缀交集中最长元素的长度</strong>.
在上例中, 就是 <span class="math inline">\(\text{\{a,ab,abc,abca\}}\cap
\text{\{b, ab, cab, bcab\}} = \text{\{ab\}}\)</span> 的长度,
也就是<code>2</code>, 表示的含义也即:
让<code>p</code>的<code>ab</code>对上<code>s</code>的<code>ab</code>.</p>
<p>而且, 由于在匹配失败之前, 匹配都是成功的, 我们可以得到另外一个信息是
<strong><code>s</code>串的部分子串等同于<code>p</code>串的部分子串</strong>,
那么,
此时<code>s</code>子串的后缀和<code>p</code>子串的前缀交集中最长元素的长度,
就等同于 <strong><code>p</code>子串的最大前后缀长度</strong>,
也就是<code>p</code>串的<strong>前缀函数</strong>.</p>
<p>这是巨大的一步!
因为我们可以在<code>s</code>和<code>p</code>进行匹配之前就计算出<code>p</code>每一次向右移动的长度.</p>
<p>在KMP算法中, 我们记这个数组为<code>next</code>数组.</p>
<p>在下面的算法中,
我们依然用<code>i</code>表示指向<code>s</code>的字符下标,
<code>j</code>表示指向<code>p</code>的字符下标.</p>
<p>相较于暴力算法, 我们优化的点主要在于<code>j != 0</code>的情况:
让<code>i</code>不回溯, 只让<code>j</code>回溯. <code>i</code>不动,
让<code>p[next[j - 1]]</code>和<code>s</code>中方才匹配失败的字符<code>s[i]</code>进行比较.
假使这一步又失败了, 我们还是回溯<code>j</code>,
找<code>s[i] == p[j]</code>, 直到<code>j</code>为<code>0</code>,
也就意味着<code>s</code>和<code>p</code>没有交集了. 这时,
移动<code>i</code>, 进行新一轮的匹配. 注意, 这是KMP最差的情况:
<code>i++</code>, <code>j=0</code>, 这和暴力算法实际上没有多少区别.
但通过<code>j = next[j - 1]</code>的状态转移,
我们减少了大量的匹配次数!</p>
<p>一切操作,
只是简单地改变<code>i</code>和<code>j</code>状态——KMP算法本质上就是一个<strong>优化了的状态机</strong>!</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> next[N];</span><br><span class="line"><span class="type">int</span> <span class="title function_">kmp</span><span class="params">(<span class="type">char</span> *s, <span class="type">char</span> *p)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(s[i] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == p[j])</span><br><span class="line">            i++, j++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j)</span><br><span class="line">            j = next[j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span>(p[j] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> i - j;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于<code>next</code>数组, 我们其实也可以暴力解决:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">getNext</span><span class="params">(<span class="type">char</span> *p)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">strlen</span>(p);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="type">int</span> match = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; j; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p[k] != p[i - j + <span class="number">1</span> + k]) &#123;</span><br><span class="line">                    match = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (match) &#123;</span><br><span class="line">                next[i] = j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>暴力算法的时间复杂度是<code>O(n^3)</code>, 数据量大必爆,
而且非常丑陋, 这对KMP这样优雅的算法简直就是致命的. 下面,
我们就来看看怎么才能优雅地计算<code>next</code>数组.</p>
<h2 id="优雅计算前缀函数">优雅计算前缀函数</h2>
<p>就像动态规划<code>dp</code>找到状态转移方程,
找到前缀函数的递推公式将是我们解题的关键.</p>
<figure>
<img src="/images/pic2.png" alt="相邻的前缀函数值最大增加 1" />
<figcaption aria-hidden="true">相邻的前缀函数值最大增加 1</figcaption>
</figure>
<p>仔细观察前缀函数, 第一个重要性质就是:
<strong>相邻的前缀函数值最大增加 <code>1</code></strong>.</p>
<p>不要忘记我们对前缀函数的定义是:
<strong>最长的相等前缀和后缀长度</strong>.</p>
<p>那么, 这个性质可以这么思考: 要取一个尽可能大的<span
class="math inline">\(\pi[i]\)</span>, 必然要求新增的 <code>s[i]</code>
能和对应的字符匹配, 也即 <span class="math inline">\(s[i] =
s[\pi[i-1]]\)</span>, 此时 <span class="math inline">\(\pi[i] = \pi[i-1]
+ 1\)</span>. 例如: 上图中, <code>i = 5</code>的位置(<code>c</code>),
比较的是 <code>i = pi[4] = 2</code> 的位置(<code>c</code>),
即相等前缀的下一字符, 因为相等, 所以<code>pi[5] = pi[4] + 1</code>;
<code>i = 11</code>(c) 比较的是 <code>i = pi[10] = 5</code>(c),
相等所以加一.</p>
<figure>
<img src="/images/pic3.png" alt="假如不匹配怎么办?" />
<figcaption aria-hidden="true">假如不匹配怎么办?</figcaption>
</figure>
<p>下一步是考虑 <span class="math inline">\(s[i] \neq
s[\pi[i-1]]\)</span> 的情况. 如图所示, 我们期望,
当<code>s[i]</code>失配时, 对于子串<code>s[0...i-1]</code>,
依然能找到仅次于 <span class="math inline">\(\pi[i-1]\)</span>
的第二长度 <code>j</code>, 使得在位置 <code>i-1</code>
的前缀性质依然保持, 也即 <code>s[0...j-1] = s[i-j...i-1]</code>.</p>
<p>数学看上去有些抽象, 举个例子: 如图, <code>i = 11</code> 时失配了,
对于子串 <code>abcabdabcab</code>, 依然能找到比 <span
class="math inline">\(\pi[10] = 5\)</span> 小的<strong>第二长度</strong>
<code>j</code> (在这里是 <code>2</code>), 使得 <code>i = 10</code>
的前缀性质依然保持, 这里找到的公共前后缀为<code>ab</code>.</p>
<p>如果我们找到了这样的<code>j</code>,
那么就只需要比较<code>s[i]</code>和<code>s[j]</code>.</p>
<ul>
<li>如果它们相等, 就有 <span class="math inline">\(\pi[i] = j +
1\)</span>. 在上面的例子中, 因为 <code>s[11] = s[2]</code>, 因此 <span
class="math inline">\(\pi[11] = 3\)</span>.
此时最大前后缀为<code>abc</code>.</li>
<li>如果它们不相等, 假设本例中的 <code>s[11] = 'a'</code>,
根据上面的讨论, 我们需要再找到一个仅次于 <span
class="math inline">\(j\)</span> 的 <span
class="math inline">\(j^{(2)}\)</span>, 使得前缀性质得以保持. 此时 <span
class="math inline">\(j^{(2)}\)</span> 只能为<code>0</code>了,
因为<code>s[i] = s[0]</code>, 所以<code>pi[11] = 1</code>.</li>
</ul>
<p>以此类推, 按照数学归纳, 直到 <span class="math inline">\(j^{(n)} =
0\)</span> 时我们结束寻找第二长度, 并且我们可以知道, 如果 <span
class="math inline">\(s[i]\neq s[0]\)</span>, 那么 <span
class="math inline">\(\pi[i] = 0\)</span>,
正如本例中的<code>i = 5</code>(<code>d</code>不匹配任何一个字符).</p>
<p>前缀函数另一个重要的性质,
也就是<code>j</code>实际上<strong>等价于子串</strong><span
class="math inline">\(s[0...\pi[i - 1] -
1]\)</span>的<strong>前缀函数值</strong>, 也即</p>
<p><span class="math display">\[j = \pi[\pi[i - 1] - 1] \]</span></p>
<p>上例中, 也即<code>i = 5</code>处<code>pi</code>的值,
也就是我们已经求得的 <code>2</code>! 同理, <span
class="math inline">\(j^{(2)} = \pi[j-1]\)</span>, 那么归纳可得 <span
class="math inline">\(j^{(n)} = \pi[j^{(n-1)}-1]\)</span>.</p>
<p>于是我们就有了最终的代码:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> next[N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">getNext</span><span class="params">(<span class="type">char</span> *p)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p[i] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p[i] == p[j]) &#123;</span><br><span class="line">            next[i] = next[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            i++, j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(j)</span><br><span class="line">            j = next[j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            next[i] = <span class="number">0</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>各位可以揣读一下这段代码的精妙, 甚至框架和KMP搜索惊人的一致!
(都是改变状态实现)</p>
<h2 id="模板">模板</h2>
<p>正文部分给出的是C语言实现版本.
下面给出主流算法竞赛中使用的C++实现方式.</p>
<p>来源: <a href="https://oi-wiki.org/string/kmp/">OI-wiki
前缀函数和KMP算法</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">prefix_function</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = (<span class="type">int</span>)s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pi</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = pi[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j])</span><br><span class="line">            j = pi[j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (s[i] == s[j])</span><br><span class="line">            j++;</span><br><span class="line">        pi[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来源: <a
href="https://www.acwing.com/activity/content/problem/content/869/">AcWing
831.KMP字符串</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> p[N], s[N];</span><br><span class="line"><span class="type">int</span> ne[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; p &gt;&gt; m &gt;&gt; s;</span><br><span class="line">    ne[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">-1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; p[i] != p[j + <span class="number">1</span>])</span><br><span class="line">            j = ne[j];</span><br><span class="line">        <span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>])</span><br><span class="line">            j++;</span><br><span class="line">        ne[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">-1</span>; i &lt; m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; s[i] != p[j + <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            j = ne[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            j ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == n - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; i - j &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            j = ne[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<p>[1]. <a href="https://oi-wiki.org/string/kmp/">OI-wiki
前缀函数和KMP算法</a></p>
<p>[2]. 邓俊辉. <a
href="https://dsa.cs.tsinghua.edu.cn/~deng/ds/dsacpp/">数据结构(C++语言版)</a>.
北京: 清华大学出版社, 2013.09第三版. ISBN: 7-302-33064-6. P331.
KMP算法</p>
<p>[3]. 木子喵neko. <a
href="https://www.bilibili.com/video/BV1234y1y7pm/">【喵的算法课】KMP算法【7期】</a></p>
<p>[4]. calabash_boy (注: NJU final爷). <a
href="https://ac.nowcoder.com/acm/contest/28737">牛客竞赛字符串专题班Trie（字典树多模式匹配）</a>.
2022年1月15日.</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2023寒假每日一题</title>
    <url>/2023/01/14/%E5%AF%92%E5%81%87%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
    <content><![CDATA[<p>收录一些寒假做的题目. 题目来源: <a
href="https://www.acwing.com/activity/content/introduction/2712/">寒假每日一题2023</a>
我才不是水题大师呢, 因为蒟蒻所以只能做这些入门题,
但实际上更水的题目已经被我筛掉了 (</p>
<span id="more"></span>
<h2 id="孤独的照片">孤独的照片</h2>
<p>导航: <a
href="http://www.usaco.org/index.php?page=viewproblem2&amp;cpid=1155&amp;lang=zh">USACO
2021 December Contest, Bronze Problem 1. Lonely Photo</a></p>
<p>题目等价于: 长度大于等于3, 且子串中两种字符中的一种, 数量小于等于1,
求这些子串的数目. 示例: <code>GHGHG</code> 输出 <code>3</code>, 其中
<code>GHG</code>, <code>HGH</code>, <code>GHG</code> 就是题目要求的.</p>
<p>暴力枚举会超时. 自己思考这个问题,
你会发现这道题实际上是个<strong>排列组合问题</strong>. 高考数学遇到求
<code>GGGGHGGGG</code> 符合题目条件的子串, 你会怎么做? 分类讨论,
然后利用乘法原理:</p>
<ul>
<li><code>H</code> 左边连续的 <code>G</code> 有 4 个, 右边连续的
<code>G</code> 有 4 个.</li>
<li>两边可以任选连续个数的 <code>G</code>, 左边可以不选, 也可以选1个,
一直到4个<code>G</code>; 右边也是同样的道理.
<ul>
<li>如果左右各选一个 <code>G</code>, 最小子串为 <code>GHG</code>,
剩下各边还有 <code>3</code> 个连续的 <code>G</code>, 可以不选,
或者选1个, 一直到3个, 依乘法原理有 <code>4 * 4 = 16</code>.</li>
<li>如果 <code>H</code> 作为子串的右端点, 最短子串为 <code>GGH</code>,
剩下可以不选, 或者选1个或2个. 那么有 <code>4 - 1 = 3</code> 种情况.</li>
<li>如果 <code>H</code> 作为子串的左端点, 本例中有
<code>4 - 1 = 3</code> 种情况.</li>
</ul></li>
<li>一共有 <code>16 + 3 + 3 = 22</code> 种情况.</li>
</ul>
<p>推广: <code>ans = l * r + l - 1 + r - 1</code>, 其中 <code>l</code>
表示"孤独"字符左边连续的另一字符的数量, <code>r</code> 同理. 一个问题是,
对于"孤独"字符处于端点的情况, <code>l - 1</code>
必须大于等于<code>2</code>, 否则构成不了最短子串. 因此可以做一个小操作:
<code>max(l - 1, 0)</code>. 然后依次遍历整个数组.</p>
<p>通过数学做法, 计算每一个字符和左右满足的子串,
时间复杂度压到了<code>O(1)</code>.</p>
<p>接下来是获取每一个字符对应的 <code>l</code> 和 <code>r</code>. 用
<code>g</code> 表示连续遇到的 <code>G</code>, <code>h</code>
表示连续遇到的 <code>H</code>.</p>
<ul>
<li>如果下一个字符不同, 假设当前字符为 <code>G</code>, 下一个字符为
<code>H</code>, 那么将 <code>g</code> 储存在 <code>l[i]</code> 或者
<code>r[i]</code>, 然后 <code>g</code> 归零, 因为不再连续.</li>
<li>如果下一个字符相同, 那么 <code>g</code> 或者 <code>h</code> 自增,
然后将 <code>g</code>(或者 <code>h</code>) 存储在 <code>l</code> 或者
<code>r</code> 中.</li>
</ul>
<p>本题也需要注意卡 <code>int</code>.</p>
<h2 id="上课睡觉">上课睡觉</h2>
<p>导航: <a
href="http://www.usaco.org/index.php?page=viewproblem2&amp;cpid=1203&amp;lang=zh">USACO
2022 February Contest, Bronze, Problem 2 Sleep in Class</a></p>
<p>本地化导航: <a
href="https://www.acwing.com/problem/content/description/4369/">AcWing
4366. 上课睡觉</a></p>
<p>题目要求: 合并, 石子堆集合中的每堆石子的数量都相同</p>
<p>假设总数 <code>sum</code> 的石子堆可以被平分成 <code>i</code> 堆,
每堆石子的个数为 <code>cnt</code>, 且易知
<code>cnt = sum / i</code>.</p>
<p>因为每次合并操作会使得石子堆的个数减一, 那么平分成 <code>i</code>
堆需要的操作数为 <code>n - i</code>, 所以最终输出的答案为
<code>n - i</code>. 我们只需要<strong>枚举找到这个最大的
<code>i</code></strong> 即可.</p>
<p>判断石子堆能否合并, 题目给出了一个良好的性质:
<strong>仅可以</strong>合并两个<strong>相邻</strong>的元素, 也就是说,
合并的部分是一段连续的区间, 我们就可以用一个变量 <code>s</code>
来累加石子堆, 从 <code>a[0]</code> 开始累加, 并判断如果
<code>s == cnt</code>, 那么重置 <code>s = 0</code>; 如果大于
<code>0</code>, 说明我们假设的 <code>cnt</code> 不成立. 如果能够遍历完
<code>a</code>, 则说明可以平分成 <code>i</code> 份.</p>
<p>本题一定有解, 因为 <code>i = 1</code> 一定成立.</p>
<h2 id="奶牛大学">奶牛大学</h2>
<p>导航: <a
href="http://www.usaco.org/index.php?page=viewproblem2&amp;cpid=1251">USACO
2022 December Contest, Bronze Problem 1. Cow College</a></p>
<p>我们会首先会对输入进行排序, 使得 <span class="math inline">\(c_0
\leqslant c_1 \leqslant c_2 \cdots \leqslant c_n\)</span>,
方便我们进一步讨论.</p>
<p>首先可以证明, 选取的学费 <span class="math inline">\(x \in \{c_0,
c_1, \cdots, c_n \}\)</span>. 可以反证. 假设 <span
class="math inline">\(c_{i}&lt;x&lt;c_{i+1}\)</span>, 那么收取的总费用
<span class="math inline">\(y = x\cdot (n - i) &lt; c_{i}\cdot(n -
i)\)</span>, 需要比较的仅是 <span class="math inline">\(c_{i}\)</span>
和 <span class="math inline">\(c_{i+1}\)</span> 情况下的收取总费用. 对
<span class="math inline">\(c\)</span> 从 0 到 n 枚举即可.</p>
<p>这题会卡<code>int</code>,
算收取总费用的时候要转换成<code>long long</code>.</p>
<h2 id="选数异或">选数异或</h2>
<p>导航: <a
href="https://www.dotcpp.com/oj/problem2665.html">第十三届蓝桥杯省赛C++A/C/研究生组
Problem D</a></p>
<p>目标: 在数组 <span class="math inline">\(a\)</span> 中找到满足 <span
class="math inline">\(p_i\oplus q_i = x\)</span> 的最小区间 <span
class="math inline">\([p_i,q_i]\)</span>, 判断每次询问的 <span
class="math inline">\([l,r]\)</span> 是否使得 <span
class="math inline">\([a_l\dots a_r]\)</span> 包含任一 <span
class="math inline">\([p_i,q_i]\)</span>.</p>
<p><strong>性质 1</strong> 如果 <code>p</code> 符合条件, 那么
<code>p ^ x</code> 一定存在于数组.</p>
<p><strong>证明</strong> 利用异或运算的性质</p>
<p><span class="math display">\[ p\oplus q = x \iff q = p \oplus
x\]</span></p>
<p>而 <code>q</code> 在数组里, 那么 <code>p ^ x</code> 存在. 换过来说,
如果 <code>q ^ x</code> 存在, 则能判定 <code>p</code> 存在. 利用这一点,
枚举 <code>i</code>, 然后找到距离 <span
class="math inline">\(q_i\)</span> 最近的一个 <span
class="math inline">\(p_i\)</span> 的位置, 我们记函数 <span
class="math inline">\(f(i)\)</span>, 它代表 <span
class="math inline">\(a_i\)</span> 左侧与 <span
class="math inline">\(a_i\)</span> 最近的一个配对数, 并约定,
如果左侧不存在配对, 那么 <span class="math inline">\(f(i) =
0\)</span>.</p>
<p>模拟样例:</p>
<figure>
<img src="/images/pic4.png" alt="模拟" />
<figcaption aria-hidden="true">模拟</figcaption>
</figure>
<p><strong>性质 2</strong> 原问题等价于: 判断 <span
class="math inline">\(f(r) \geqslant l\)</span>.</p>
<p><strong>证明</strong> <span class="math inline">\(f(r)\)</span> 表示
<span class="math inline">\(a_r\)</span> 左侧最近的一个匹配数下标,
若存在, 那么一定存在 <span class="math inline">\(q \leqslant r\)</span>,
且 <span class="math inline">\(f(r)\)</span> 大小为 <span
class="math inline">\([1,r]\)</span> 中最大的 <span
class="math inline">\(p\)</span> 下标. 记 <span
class="math inline">\(i(x)\)</span> 为元素 <span
class="math inline">\(x\)</span> 在数组中的下标位置. 即能找到一个 <span
class="math inline">\(p\)</span> 满足 <span class="math inline">\(i(p)
\geqslant l\)</span>, 使得 <span class="math inline">\(l \leqslant i(p)
&lt; i(q) \leqslant r \iff \{p\dots q\}\subseteq a[l\dots
r]\)</span>.</p>
<p>下一步就是求出 <span class="math inline">\(f(i)\)</span>
的递推表达式. 如果在 <span class="math inline">\([1,r]\)</span>
找到了新的匹配数 <span class="math inline">\(p&#39;\)</span>, 那么就更新
<span class="math inline">\(f(i) = i(p&#39;)\)</span>, 否则 <span
class="math inline">\(f(i) = f(i-1)\)</span>.</p>
<p>利用性质1, 可以利用一个哈希表. 如果哈希表内不存在
<code>a[i] ^ x</code> 的值, 那么会返回 <code>0</code>. 因为返回的是数值,
我们可以取 <code>f(i - 1)</code> 和 <code>hash(a[i] ^ x)</code>
的最大值作为 <code>f(i)</code>.</p>
<p>下面的代码在处理输入时做了一些静态优化:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1</span> &gt;&gt; <span class="number">20</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, x;</span><br><span class="line"><span class="type">int</span> a[M], dp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>], a[t ^ x]);</span><br><span class="line">        a[t] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        cout &lt;&lt; (dp[r] &gt;= l ? <span class="string">&quot;yes&quot;</span> : <span class="string">&quot;no&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数位排序">数位排序</h2>
<p>导航: <a
href="https://www.dotcpp.com/oj/problem2684.html">第十三届蓝桥杯省赛C++C组
数位排序</a></p>
<p>本题自定义实现一个比较函数, 然后STL sort即可.</p>
<p>但求数位和不能放在 <code>cmp</code> 里, 会TLE.
原因是<code>sort</code>的实现会进行 <code>n</code> 次 <code>cmp</code>
操作, 而 <code>cmp</code> 有 <code>c = 10^1</code> 级别的操作数,
<code>sort</code> 时间复杂度为 <code>O(n logn)</code>, 最大数据量
<code>n = 10^6</code>, 那么操作数约有
<code>10 * 10 * 10^6 = 10^8</code>, 就会卡时间.</p>
<p>在本地测试<code>0.98s</code>, 非常惊险, 但放oj平台TLE了.</p>
<p>所以我们需要<strong>预处理</strong>求 <code>1~n</code> 的数位和,
并保存到另一个数组里. 更优解是写一个结构体, 储存这个值和它的数位和,
然后对结构体数组排序.</p>
<p>使用排序预处理可以降低求解问题所需要的时间复杂度.
本质上这属于以空间换时间的一个平衡.</p>
<p>这样能少乘一个常数. 最大负载实际运行时间约为 <code>0.23s</code>.</p>
<h2 id="重新排序">重新排序</h2>
<p>导航: <a
href="https://www.dotcpp.com/oj/problem2690.html">第十三届蓝桥杯省赛C++C组
H: 重新排序</a></p>
<p>本题类似于<a href="https://vijos.org/p/1779">NOIP 2012 国王游戏</a>
以及 <a href="https://www.luogu.com.cn/problem/P2123">P2123
皇后游戏</a>. 题解可以参考: <a
href="https://ouuan.github.io/post/%E6%B5%85%E8%B0%88%E9%82%BB%E9%A1%B9%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F%E7%9A%84%E5%BA%94%E7%94%A8%E4%BB%A5%E5%8F%8A%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98/">浅谈邻项交换排序的应用以及需要注意的问题</a></p>
<p>贪心可以知道, 求和次数最多的位置, 重排后, 应当对应最大值.
这个可以通过邻项交换法证明.</p>
<p>一个想法是构造一个结构体, 包含值和这个位置被求和的次数,
然后对其排序.</p>
<p>但我们也可以构造两个数组, 对两个数组进行排序, 最后只用计算
<code>a[i] * b[i]</code> 的和就可以了, 甚至不用计算 <code>[1,n]</code>
上的前缀和, 因为如果一段区间如果没有被求和, <code>b[i] = 0</code>, 那么
<code>sum += 0</code>.</p>
<p>求 <code>b[i]</code>, 利用每一组的 <code>l, r</code>
可以求得数组中各个元素被求和了多少次. 让 <code>[l,r]</code>
中的数据加上一个相同的数, 快速做法是<strong>差分</strong>.</p>
<h2 id="技能升级">技能升级</h2>
<p>导航: <a
href="https://www.dotcpp.com/oj/problem2688.html">第十三届蓝桥杯省赛C++C组
倒数第二题</a></p>
<p>类似问题: <a
href="https://www.acwing.com/problem/content/description/1264/">鱼塘钓鱼</a></p>
<p>钓鱼数量只和在某一鱼塘待的时间相关(因为不会折返).
我们要做的是以下几件事:</p>
<ul>
<li>枚举最远钓到哪个鱼塘(确定路上花费的时间)</li>
<li>总钓鱼时间 <code>n</code> = <code>T</code> - 走的时间</li>
<li>已知总钓鱼时间 <code>n</code>, 分配各个鱼塘, 求最大和,
即三个数组排序, 求前<code>n</code>元素的和. 用多路归并排序</li>
</ul>
<p>这道题用的相同的思路: 求出堆前 <code>m</code>
个最大的元素的和<code>s</code>, 可以证明 <code>s</code> 就是最优解.
然而爆TLE, 原因是堆优化复杂度为<code>O(m log n)</code>, 而
<code>m</code> 可以取到 <code>2e9</code>. 如果要解决本题,
那算法复杂度必须要 <code>log m</code> 或者和 <code>m</code> 无关.</p>
<p>换一种思路, 如果能找到归并后的数组中第 <code>m</code> 个数
<code>x</code>, 以及每个技能升级的次数<code>t</code>, 我们可以用
<code>O(n)</code> 的时间(多次利用等差数列的求和)计算前 <code>m</code>
项数的和:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">res += <span class="built_in">sum</span>(a[i], b[i], t);</span><br></pre></td></tr></table></figure>
<p>数组按从大到小排序, 我们可以发现 <span
class="math inline">\(\geqslant x\)</span> 的数的个数 <span
class="math inline">\(\geqslant m\)</span>, 也就表示 $x + 1 $ 的数 <span
class="math inline">\(&lt; m\)</span> 个, 答案具有二段性,
于是我们可以用二分快速找出 <code>x</code>, 并且它的复杂度为
<code>O(log n)</code>.</p>
<p>二分检查的性质可以用一种更快速的方法判断, 我们假设 <code>t</code>
为当前技能升级的次数, 那么</p>
<p><span class="math display">\[a_i - (t-1)b_i \geqslant x \iff t =
\lfloor\dfrac{a_i-x}{b_i}\rfloor + 1\]</span></p>
<p>只用判断 <span class="math inline">\(\sum t \geqslant m\)</span>
即可.</p>
<h2 id="如此编码">如此编码</h2>
<p>导航: <a href="https://www.cspro.org/">27th CCF CSP认证 官网</a></p>
<p>考察对编码系统的理解, 我觉得还挺有意思的.</p>
<p>我们知道, 十进制数可以表示为</p>
<p><span class="math display">\[m = \sum^{n}_{i=1}10^{i-1}\cdot
b_{i}\]</span></p>
<p>利用</p>
<p><span class="math display">\[ m \bmod{10^{j}} =
\sum^{j}_{i=1}10^{i-1}\cdot b_{i} = m \bmod{10^{j - 1}} + 10^{j - 1}
\cdot b^{j}\]</span></p>
<p>记 <span class="math inline">\(p_i = m \bmod{10^{i}}\)</span>,
那么</p>
<p><span class="math display">\[b_j = \frac{p_j -
p_{j-1}}{10^{j-1}}\]</span></p>
<p>模拟样例: 假设 <span class="math inline">\(m = 177\)</span>, <span
class="math inline">\(j = 2\)</span>, 那么 <span
class="math inline">\(b_1 = \dfrac{7 - 0}{1} = 7\)</span>, <span
class="math inline">\(b_{2} = \dfrac{77 - 7}{10} = 7\)</span>, <span
class="math inline">\(b_3 = \dfrac{177 - 77}{100} = 1\)</span>.</p>
<p>这个算法的关键在于下面的数学表达式:</p>
<p><span class="math display">\[m \bmod c_{j}=\sum_{i=1}^{j} c_{i-1}
\times b_{i}\]</span></p>
<p>读取各数位的算法可以写成:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    p[i] = m % c[i];    <span class="comment">// c[i] = 10^i</span></span><br><span class="line">    b[i] = (p[i] - p[i - <span class="number">1</span>]) / c[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相比于原本求数位的方法要麻烦许多. 但这个算法的好处在于对一个变化的
<code>c</code>, 只要存在 <code>c</code> 和 <code>i</code>
的一个映射关系, 就一定能求出 <code>b[i]</code>.</p>
<p>按照本题的意思, 可以先计算 <code>a[i]</code> 的前缀乘积
<code>c[i]</code>, 然后利用上面的公式即可. 实际操作可以做一些静态处理,
例如 <code>p[i]</code> 在计算前缀乘积时就可以预处理了.</p>
<p>这种做法并不关注本题 <code>c[i]</code> 为 <code>a[i]</code>
的累乘这一性质. 另外一个常用的公式:</p>
<p><span
class="math display">\[m=c_{i}\left\lfloor\frac{m}{c_{i}}\right\rfloor+m
\bmod c_{i}\]</span></p>
<p>如果你能发现</p>
<p><span class="math display">\[m = \sum_{i=1}^{n}\left(b_{i} \times
\prod_{j=1}^{i-1} a_{j}\right) = a_{1}\left[a_{2}\left(a_{3} \times
\cdots+b_{3}\right)+b_{2}\right]+b_{1}\]</span></p>
<p>再利用 <span
class="math inline">\(m=a_{i}\left\lfloor\frac{m}{a_{i}}\right\rfloor+m
\bmod a_{i}\)</span> 的性质, 发现 <span class="math inline">\(b_i = m
\bmod a_i\)</span>. 之后只需要更新一下 <span
class="math inline">\(m&#39; = \dfrac{m - b_i}{a_i}\)</span> 就可以计算
<span class="math inline">\(b_{i+1}\)</span> 的值了.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, m, x, i;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        cout &lt;&lt; m % x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        m /= x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="出行计划">出行计划</h2>
<p>原题出处: 25th CCF CSP 认证</p>
<p>朴素解法: 判断 <span class="math inline">\(t_i - (q+k) \leqslant c_i
- 1\)</span>, 同时要保证 <span class="math inline">\(t_i \geqslant q +
k\)</span>.</p>
<p>这样做的复杂度为 <code>O(mn)</code>, 数量级为 <code>10^10</code>,
明显TLE. 尝试空间换时间:</p>
<p>假设 <span class="math inline">\(p_i\)</span> 表示第 <span
class="math inline">\(i\)</span> 时刻出行, <strong>且此时刻核酸结果对
<span class="math inline">\(c_i\)</span> 有效</strong>,
可行的方案个数.</p>
<p>这样做的好处是面对多例查询, 可以用 <code>a[q + k]</code>
快速得出结果. 这样算法复杂度就降低成 <code>O(n + m)</code>,
变为可计算的问题了. 下面的问题在于怎么用 <code>O(n)</code>
的复杂度求出这个 <code>a</code> 数组.</p>
<p>在我们的假设中, <code>i</code> 时刻核酸结果对 <code>c[i]</code> 有效,
首先可以知道 <code>t[i]</code> 时刻的可行的方案数需要加一, 考虑
<code>t[i]</code> 恰好是<strong>核酸有效的最后一个时刻</strong>.
往前倒推 <code>c[i]</code> 个时刻, 从 <code>t[i] - c[i] + 1</code> 开始,
这一段区间上的方案数也需要加一, 考虑 <code>t[i] - c[i] + 1</code>
恰好是<strong>核酸结果刚出的时刻</strong>.</p>
<p>一个问题是如果 <code>t[i] &lt; c[i]</code>, 此时下标会得到一个负数.
我们只需要默认最远回退到下标 <code>1</code> 即可.</p>
<p>一组 <code>t, c</code> 得到一段区间 <code>[l, r]</code>, 让
<code>a[l...r]</code> 的元素自增1,
这个操作可以通过<strong>差分</strong>实现.</p>
<h2 id="左孩子右兄弟">左孩子右兄弟</h2>
<p>导航: 第十二届蓝桥杯省赛第一场 C++ A/C 组, 第十二届蓝桥杯省赛第一场
JAVA A/C 组</p>
<p>这道题难点在于看懂题意. 对于一个根节点 <code>u</code>,
它的子节点必然大于父节点 <code>u</code>, 子树处于左侧,
子树的第一个节点即为第一个儿子, 儿子的右兄弟则为 <code>u</code>
的第二个儿子, 以此类推, 直到 <code>p[i] &lt;= u</code>.</p>
<figure>
<img src="/images/pic5.png" alt="模拟样例" />
<figcaption aria-hidden="true">模拟样例</figcaption>
</figure>
<p>例如, 在上面的例子中, 4, 3, 2 都大于 1, 因此它们都是 1 的儿子; 3, 2
小于 4, 作为 4 的右兄弟; 而 5 因为大于 2, 因此是 2 的儿子.</p>
<p>关注一个性质: 4, 3, 2 之间的<strong>顺序是可以互换</strong>的.
我们并不强求右兄弟的值小于当前节点, 因为仍然满足都小于 1
的条件(即便切换顺序以后, 可以多出新的分支)</p>
<p>我们考虑 <code>h</code> 为当前节点子树的高度, 假设 <code>u</code>
的儿子为 <code>a, b</code>, 那么 <code>h(a)</code> 表示 <code>a</code>
节点子树的高度. 例如在上面的例子中, 考虑 <code>a = 2</code>,
<code>h(a) = 1</code>. 我们计算的答案为 <code>h(2) + 3 = 4</code>.</p>
<p>我们要求的是 <span class="math inline">\(f(u) = \max \{ h(s_i) + c_i
\}\)</span>, 其中 <span class="math inline">\(c_i\)</span>
是当前节点的高度. 那么就可以按照树形dp的方法处理: DFS <code>u</code>
的所有子节点, 求出 <code>f(u)</code>, 答案即为
<code>f(1)</code>(根节点).</p>
<p>如果你乐意, 可以证明 <span class="math inline">\(h(s_i) +
c_i\)</span> 的最大值可以在 <span class="math inline">\(c_i\)</span>
为最大值时取到, 考虑反证法. 并且由于右兄弟之间可以互换的性质, <span
class="math inline">\(c_i\)</span> 取最大值, 即 <code>u</code>
子节点的数量 <code>cnt</code>(即上例中节点 2 位于子树的最高处).</p>
<p>我们只需要求出子节点中的 <span class="math inline">\(h_{max} +
cnt\)</span> 即可.</p>
<h2 id="后记">后记</h2>
<p>这次的寒假每日一题, 总的来说, 还是收获不小的.</p>
<p>以做代练确实是很好的一种做法, 因为当我们上手一道题感到一筹莫展的时候,
你会自主地去挖掘这道题目的背景, 以及需要掌握的预备知识.
对于算法新人来说, 这么做比一味地刷视频打卡, 学习效率要高很多,
最主要是涉及的知识更广: 这里有数论, 有dp, 有贪心, 有数据结构,
也有基础——提前预习, 或者复习某些已经刷过的知识点, 真的获益不少.</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>刷题</tag>
        <tag>数论</tag>
        <tag>枚举</tag>
        <tag>动态规划</tag>
        <tag>贪心</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title>x86-64 汇编介绍</title>
    <url>/2022/12/17/x86-64%E6%B1%87%E7%BC%96%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<blockquote>
<p>程序就是状态机。——jyy, on 2022 NJU OS Lecture 01</p>
</blockquote>
<p>这句话道出了程序的本质. 实际上, 如今的计算机本质上就是通用<a
href="https://plato.stanford.edu/entries/turing-machine/">图灵机</a>,
而我们研究汇编语言就是研究程序在机器层面上的运行.</p>
<p>程序的进行依赖于<code>rip</code>寄存器,
它储存的值是当前运行的指令地址.
程序的进行实际上就是一条指令一条指令的移动(你可以在<code>gdb</code>里随时监控<code>rip</code>).
这和图灵机读写控制的方式本质上是一致的!</p>
<span id="more"></span>
<blockquote>
<p>书中出示的汇编指令是<code>AT&amp;T</code>格式,
为<code>gcc</code>和<code>gdb</code>编译选项默认.
如果不熟悉某一种风格的话,
<code>set disassembly-flavor att</code>或者<code>intel</code>就可以切换成对应的反汇编风格啦.
大部分情况下两种格式是互通的. 唯一值得注意的是读取顺序,
两者<strong>源操作数</strong>和<strong>目的操作数</strong>的顺序是<strong>反的</strong>.
例如下面的语句表示栈指针减8:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">subq     $8,%rsp             # ATT flavor</span><br><span class="line">sub      rsp,8               # Intel flavor</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="访问值和访问地址">访问值和访问地址</h2>
<p><code>%rsp</code> 表示 <code>rsp</code> 寄存器储存的值,
通常来说栈指针保存的是一个地址. 对于更一般的寄存器,
例如<code>rax</code>寄存器, 是可以保存值的, 而且通常是返回值. 我们用
<span class="math inline">\(r_a\)</span> 表示寄存器<code>a</code>
存储的值. 内存本质上是一个很长的数组, <strong>内存引用</strong>表示
<span class="math inline">\(M[r_a]\)</span>, 例如
<code>(%rsp)</code>表示<code>*rsp</code>, 也就是<code>rsp</code>
寄存器储存地址上的值.</p>
<p><code>lea</code>和<code>mov</code>指令间的区别:
前者常用于简单的算术运算, 例如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* i in %rsi */</span><br><span class="line">leal    (%eax,%eax,2), %eax</span><br></pre></td></tr></table></figure>
<p>实际上进行的操作是:
源操作数计算为<code>S = M[%eax + 2 * %eax] = M[3 * %eax]</code>,
然后求出 <code>&amp;S</code>(<code>S</code>的有效地址),
然后将这个值复制给 <code>D</code>. 如果对<code>%rax</code>解引用,
例如<code>gdb</code>指令 <code>p *(int*) $rax</code>,
可以得到<code>3i</code>.</p>
<p><code>mov</code>指令可以干两件事: 把内存地址复制给另一个寄存器,
或者将一个值复制给寄存器.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = a[i];</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* x in %eax, a in %rdx, i in %rcx */</span><br><span class="line">movl    (%rdx,%rcx,4),%eax</span><br></pre></td></tr></table></figure>
<p>源操作数<code>S = M[a + 4*i]</code>,
<code>a</code>是<code>int</code>数组的起始地址.
将内存地址<code>S</code>上的值赋值给寄存器<code>rax</code>. 此时
<code>p $rax</code> 就是<code>a[i]</code>.</p>
<blockquote>
<p>数组和结构本质上就是人为规定的一段内存.
上面的例子显示了数组<code>int a[N]</code>可以用<code>*(a+i)</code>访问<code>a[i]</code>的本质.
对于下面的结构体:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> val;</span><br><span class="line">    node* next; </span><br><span class="line">&#125; node;</span><br></pre></td></tr></table></figure>
<p>假设<code>node</code>类型<code>node1</code>的指针为<code>ptr</code>,
那么<code>*ptr</code>是什么? <code>*(ptr+8)</code>代表什么?
<code>**(ptr+8)</code> 又是什么? <code>mov    0x8(%rdx),%rdx</code>
假设<code>rdx</code>是<code>ptr</code>, 这句指令代表什么?</p>
</blockquote>
<p>区别下面的指令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov    0x20(%rsp),%rbx </span><br><span class="line">lea    0x28(%rsp),%rax </span><br></pre></td></tr></table></figure>
<p>其中<code>rbx</code>的值是内存地址<code>$rsp+32</code>上储存的值,
<code>rax</code>现在是一个指针, 它的值是<code>$rsp+40</code>,
也就是一个内存地址.</p>
<h2 id="控制语句">控制语句</h2>
<p>跳转命令<code>jmp</code>等价于C中的<code>goto</code>.
<code>if</code>语句对应条件跳转指令.
循环控制语句都可以通过<code>if</code>和<code>goto</code>所模拟.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">absdiff_se</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y)</span> &#123;</span><br><span class="line">    <span class="type">long</span> res;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; y) &#123;</span><br><span class="line">        res = y - x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        res = x - y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* x in %rdi, y in %rsi */</span><br><span class="line">absdiff_se:</span><br><span class="line">   cmpq %rsi, %rdi              ; x - y              </span><br><span class="line">   jge .L6                      ; if &gt;= goto .L6</span><br><span class="line">   movq %rsi, %rax              ; res = y</span><br><span class="line">   subq %rdi, %rax              ; res -= x</span><br><span class="line">   ret                          ; return</span><br><span class="line">.L6:                         </span><br><span class="line">   movq %rdi, %rax              ; res = x</span><br><span class="line">   subq %rsi, %rax              ; res -= y</span><br><span class="line">   ret                          ; return</span><br></pre></td></tr></table></figure>
<p>判断条件(<code>if</code>括号内的语句)基于一组条件码寄存器,
通过<code>test</code>或<code>cmp</code>指令设置.</p>
<blockquote>
<p><strong>Q:</strong> 这里发生了什么? <strong>A:</strong>
<code>cmq</code>等同为不修改源操作数的<code>sub</code>指令(<code>a-b</code>),
<code>test</code>类似<code>and</code>指令(<code>a&amp;b</code>),
程序根据结果设置<code>OF</code>和<code>SF</code>以及其他的条件码寄存器(默认为0).</p>
<p>假设结果小于<code>0</code>,
那么<code>SF</code>会被设置为<code>1</code>;
还会判断是否发生数据类型的溢出, 假设溢出,
<code>OF</code>会被设置为<code>1</code>.</p>
<p><code>jge</code>会先对条件码进行位运算, 这里:<code>~(SF ^ OF)</code>,
如果结果为<code>1</code>, 那么跳转, 否则程序继续执行下去.</p>
</blockquote>
<p>在实际阅读汇编代码的过程中, 可以忽略这部分细节,
明白程序按照条件跳转即可.</p>
<p><code>-O1</code>级别以上的优化还会出现条件移动指令,
针对的是CPU条件预测的优化.
通常来说条件移动(<code>CMOV</code>类)指令可以用下面的C代码抽象:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// v = test_expr ? then_expr : else_expr;</span></span><br><span class="line">v = then-expr;</span><br><span class="line">ve = <span class="keyword">else</span>-expr;</span><br><span class="line">t = test-expr;</span><br><span class="line"><span class="keyword">if</span> (!t) v = ve;</span><br></pre></td></tr></table></figure>
<p>下面我们来讨论循环语句: <code>do while</code> 作为最不常用的循环,
模拟方式却是最简单的. 它的流程就和它本身一致.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">loop:</span><br><span class="line">    body</span><br><span class="line">    t = test_expr;</span><br><span class="line">    <span class="keyword">if</span>(t)</span><br><span class="line">        <span class="keyword">goto</span> loop;</span><br></pre></td></tr></table></figure>
<p>和<code>while</code>语句的区别是,
<code>while</code>语句在进入之前会进行一次条件判断.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">goto</span> test;</span><br><span class="line">loop:</span><br><span class="line">    body</span><br><span class="line">test:</span><br><span class="line">    t = test_expr;</span><br><span class="line">    <span class="keyword">if</span>(t)</span><br><span class="line">        <span class="keyword">goto</span> loop;</span><br></pre></td></tr></table></figure>
<p>至于最常用的<code>for</code>语句, 它有等价的<code>while</code>表述,
此处从略.</p>
<p>做完了要不要试试手? 要不要拆个<a
href="http://csapp.cs.cmu.edu/3e/bomb.tar">二进制炸弹</a>试试手:)
在Linux下输入下面的指令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://csapp.cs.cmu.edu/3e/bomb.tar</span><br><span class="line">tar xvf bomb.tar</span><br><span class="line"><span class="built_in">cd</span> bomb</span><br></pre></td></tr></table></figure>
<p>你需要做的是<code>gdb bomb</code>然后对汇编代码进行分析,
然后给出拆弹必要的字符串! 在<code>bomb.c</code>给出了程序流,
你至少知道该在哪里打断点. 而函数具体如何实现,
这就得看你汇编的能力了!</p>
<h2 id="函数调用的过程">函数调用的过程</h2>
<p>函数调用的过程满足<strong>栈</strong>的前进后出(First in, Last
out)原则.</p>
<blockquote>
<p><strong>Q:</strong> 怎么画函数栈帧的示意图? 是栈顶放最上面,
还是内存高位的一端放在最上面? <strong>A:</strong> 看个人习惯. <a
href="http://www.stackgrowsup.com/">UP?</a> 还是 <a
href="http://www.stackgrowsdown.com/">DOWN?</a>
只要你看别人的示意图不会被绕晕就可以. 通常来说,
栈朝着<strong>低地址</strong>增长, 从这个意义上来说,
往下画是更多人的选择.</p>
</blockquote>
<p>当过程P执行过程Q时, 会把返回地址,
也就是<code>call</code>指令的下一句(记作A)压入栈中(PC++),
Q返回时就会从A开始继续执行. 我们认为A是P栈帧的一部分. 对应的
<code>ret</code> 会将A从栈中弹出, 然后将<code>rip</code>设置为A.</p>
<p>调用函数的时候怎么传入参数? 一般来说, 如果还有空闲的寄存器,
程序在调用过程Q之前, 在过程P, 会先将参数移动到对应的寄存器,
例如第一个参数会移动到指定寄存器<code>rdi</code>上(<code>rsi</code>和<code>rdx</code>以此类推),
然后在过程Q中调用这几个寄存器, "共享"过程中,
实际上就实现了参数的传递.</p>
<p>在函数调用的一开始, 会为过程Q分配栈空间.
因为程序运行地址是往低址增长,
所以扩大栈需要减小栈指针<code>rsp</code>(指向栈顶元素).
将栈指针减小一个适当的值可以为没有初始值的数据在栈上分配空间.</p>
<p>通常来说<code>push</code>指令(将参数压入栈)就可以满足需要.
压栈实际上就是复制一个参数. 某些情况下,
还需要通过主动利用<code>sub</code>指令来分配栈帧. 在结束调用时,
对应的需要增加栈指针, 对应指令<code>pop</code>,
本质上是<code>add</code>一个特定的值.</p>
<blockquote>
<p><strong>Q1:</strong> <code>push</code>指令到底是什么意思?
<strong>A:</strong>
<code>push</code>指令实际上可以通过更简单的指令模拟出来:
<code>pushq %rbp</code> 等价于 <code>subq $8,%rsp</code>然后
<code>movq %rbp,(%rsp)</code>.
区别在于<code>pushq</code>指令占的字节数更少.
同理可以知道<code>pop</code>的含义.</p>
<p><strong>Q2:</strong> 还有什么时候需要用到栈帧? <strong>A:</strong>
上面提到了, 如果寄存器不足够放置所有的本地数据, 就需要用栈去储存. 此外,
对一个临时变量取地址<code>&amp;</code>, 局部变量是数组或结构,
同样需要分配栈帧. 栈帧的具体分配可以查阅书.</p>
</blockquote>
<p>理解了函数调用的过程, 实际上你就可以实现将任何递归程序<a
href="https://zhuanlan.zhihu.com/p/467871987">改写</a>成非递归! 比方说,
写一个非递归版的汉诺塔程序.</p>
<p>此外, 关于栈帧有一个有趣的话题: 内存越界和缓冲区溢出.
主要是这样一个库函数<code>gets()</code>,
它可以无视字符串长度向字符数组写入, 引起内存越界, 小则修改栈上的值,
大则修改返回地址, 使得函数调用到奇怪的地方!</p>
<p>有关这部分, CSAPP提供了<a
href="http://csapp.cs.cmu.edu/3e/target1.tar">attack lab</a>,
让你模拟为一名hacker去攻击程序! 很有意思.</p>
<p>在这里, 我们给出缓冲区溢出的一个例子:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">win</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(arg == <span class="number">0x15213</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;You win 1 cookie! Great start!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(arg == <span class="number">0x18213</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;You win 2 cookies! Woohoo!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(arg == <span class="number">0x18613</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;You win 3 cookies! That&#x27;s right!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">solve</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> before = <span class="number">0xb4</span>;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> after = <span class="number">0xaf</span>;</span><br><span class="line"></span><br><span class="line">    gets(buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(before == <span class="number">0x3331323531</span>)</span><br><span class="line">        win(<span class="number">0x15213</span>);</span><br><span class="line">    <span class="keyword">if</span>(after == <span class="number">0x3331323831</span>)</span><br><span class="line">        win(<span class="number">0x18213</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改<code>after</code>的值, 这个其实不难做到.
按照临时变量在栈上的顺序, 首先<code>before</code>先压栈,
然后是<code>buf</code>, 最后是<code>after</code>.
又因为栈是朝内存低的方向生长的,
知<code>buf</code>超出的部分会影响到<code>before</code>的值.
具体在内存中是怎么分配的呢? 可以尝试反汇编调试一下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Dump of assembler code for function solve:</span><br><span class="line">   0x00000000004006b5 &lt;+0&gt;:     sub    $0x38,%rsp</span><br><span class="line">   0x00000000004006b9 &lt;+4&gt;:     movq   $0xb4,0x28(%rsp)</span><br><span class="line">   0x00000000004006c2 &lt;+13&gt;:    movq   $0xaf,0x8(%rsp)</span><br><span class="line">   0x00000000004006cb &lt;+22&gt;:    lea    0x10(%rsp),%rdi</span><br><span class="line">   0x00000000004006d0 &lt;+27&gt;:    call   0x40073f &lt;Gets&gt;</span><br><span class="line">   0x00000000004006d5 &lt;+32&gt;:    mov    0x28(%rsp),%rdx</span><br><span class="line">   0x00000000004006da &lt;+37&gt;:    movabs $0x3331323531,%rax</span><br></pre></td></tr></table></figure>
<p><code>buf</code> 在 <code>rsp+0x10</code> 的位置,
<code>buf[16]</code> 在 <code>0x20</code>, 而 <code>0xb4</code> 在
<code>rsp+0x28</code> 的位置,
也就是要覆盖<code>before</code>的值还必须填充8个字节. 于是,
可以构造攻击字符串<code>00001111222233334444555515213</code>,
就可以获得1个cookie啦!</p>
<p>想一想, 你可以怎么做, 来完成剩余的关卡? 例如,
修改<code>after</code>的值, 或者直接修改传递的<code>arg</code>参数值?
而这一切都可以通过缓冲区的溢出来实现! 如果你感兴趣,
可以下载CMU官网提供的rec:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://www.cs.cmu.edu/~213/activities/rec5.tar</span><br><span class="line">tar xvf rec5.tar</span><br><span class="line"><span class="built_in">cd</span> rec5</span><br></pre></td></tr></table></figure>
<p>补充一些细节: 传递参数存在保护机制.
方才我们提到参数传入靠的是<code>push</code>和<code>pop</code>,
实际是参数的复制. 在此之外, 我们还有一组特殊的寄存器: <code>rbx</code>,
<code>rbp</code>和
<code>r12 ~ r15</code>寄存器被称为<strong>被调用者保存</strong>寄存器.
在P调用Q的过程中, Q必须保护这些寄存器的值,
使得当Q返回P的时候与调用Q时是一样的.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">P</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> u = Q(y);</span><br><span class="line">    <span class="type">long</span> v = Q(x);</span><br><span class="line">    <span class="keyword">return</span> u + v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第四行<code>sub $8,%rsp</code>是为了内存对齐.
第五行把<code>x</code>储存到了<code>rbp</code>寄存器上,
这样就不需要担心<code>rdi</code>寄存器后来被修改导致<code>x</code>丢失.
同样<code>rbx</code>储存了<code>Q(y)</code>的值,
这样就不用担心<code>rax</code>寄存器修改导致<code>Q(y)</code>的丢失.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P:</span><br><span class="line">   pushq %rbp                Save %rbp</span><br><span class="line">   pushq %rbx                Save %rbx</span><br><span class="line">   subq $8, %rsp             Align stack frame</span><br><span class="line">   movq %rdi, %rbp           Save x</span><br><span class="line">   movq %rsi, %rdi           Move y to first argument</span><br><span class="line">   call Q                    Call Q(y)</span><br><span class="line">   movq %rax, %rbx           Save result</span><br><span class="line">   movq %rbp, %rdi           Move x to first argument</span><br><span class="line">   call Q                    Call Q(x)</span><br><span class="line">   addq %rbx, %rax           Add saved Q(y) to Q(x)</span><br><span class="line">   addq $8, %rsp             Deallocate last part of stack</span><br><span class="line">   popq %rbx                 Restore %rbx</span><br><span class="line">   popq %rbp                 Restore %rbp</span><br><span class="line">   ret</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>汇编</tag>
        <tag>CSAPP</tag>
        <tag>计算机系统</tag>
      </tags>
  </entry>
  <entry>
    <title>简单的排序算法</title>
    <url>/2023/01/05/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>我们介绍两个基于分治且 <code>O(nlogn)</code> 的排序算法:
快速排序和归并排序. 理解排序算法的最好方法是模拟, 手动模拟指针的移动,
感受数据是怎么逐渐变得有序的. 配合动图食用更佳.
两个算法困难的点在于边界分析. 不过记模板就可以了(</p>
<span id="more"></span>
<h2 id="快速排序">快速排序</h2>
<h3 id="原理">原理</h3>
<p>快速排序的核心要义:
任取一个数<code>x</code>作为<strong>基准值</strong>,
<strong>调整<code>x</code>的左右区间</strong>,
使得左区间的值小于<code>x</code>, 右区间的值都大于<code>x</code>,
然后对这两个子区间<strong>递归调用</strong>.</p>
<p>怎么调整区间:</p>
<ul>
<li><del>扫描并比较整个数组, 大于 <code>x</code> 的放在数组
<code>a</code>, 小于的放在 <code>b</code>,
最后再复制回去.</del>(空间开销大)</li>
<li>双指针. <code>i</code> 从 <code>l</code> 开始移动, 确保
<code>q[l...i-1]</code> 比 <code>x</code> 小. 当遇到比 <code>x</code>
大的值, 就让这个值和 <code>j</code> 交换位置, 然后从后移动
<code>j</code> 指针, 确保 <code>q[j...r]</code> 比 <code>x</code> 大.
遇到比 <code>x</code> 小的值, 就再交换回去, 直到 <code>i</code>,
<code>j</code> 相遇.</li>
</ul>
<p>这两个区间的值也可以等于<code>x</code>. 算法的正确性, 用<a
href="https://www.acwing.com/solution/content/16777/">循环不变式</a>证明:
<code>q[l..i] &lt;= x</code> 以及 <code>q[j..r] &gt;= x</code></p>
<h3 id="性质">性质</h3>
<p>朴素的快排是一种不稳定的排序方式.</p>
<p>最优时间复杂度和平均时间复杂度为 <span class="math inline">\(O(n \log
n)\)</span> (基准数是中位数的情况), 最差情况退化成冒泡排序 <span
class="math inline">\(O(n^2)\)</span> (每一次基准数的选取都是最值).</p>
<h3 id="模板">模板</h3>
<p>来源: <a
href="https://www.acwing.com/activity/content/code/content/39784/">AcWing
785. 快速排序</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span>(q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j--; <span class="keyword">while</span>(q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j), <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="归并排序">归并排序</h2>
<p>归并排序是典范的分治思想的例子. 归并排序的核心要义是: 把数组一分为二,
一直分下去直到不能再分, 然后逐层合并两个有序的数组.</p>
<p>用程序语言描述就是下面的代码:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(array)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (basecase) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">merge_sort</span>(left);</span><br><span class="line">  <span class="built_in">merge_sort</span>(right);</span><br><span class="line">  <span class="built_in">merge</span>(left, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>核心是实现子程序 <code>merge</code>: 合并两个排好序的数组.
实现起来很简单, 用到了临时数组, 令
<code>tmp[k] = min(left[i], right[j])</code> 最后复制回原数组就可以了.
整个过程要用到三个指针, 分别指向临时数组, 以及两个排好序的数组.</p>
<h3 id="板子">板子</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">merge_sort</span>(q, l, mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> N = l + r - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> tmp[N];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        tmp[k++] = (q[i] &lt;= q[j]) ? q[i++] : q[j++];</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid)</span><br><span class="line">        tmp[k++] = q[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= r)</span><br><span class="line">        tmp[k++] = q[j++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= r; i++, j++)</span><br><span class="line">        q[i] = tmp[j];   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="应用">应用</h3>
<p><a href="https://www.acwing.com/problem/content/790/">AcWing 788.
逆序对的数量</a></p>
<p>用归并排序看待这个问题: 逆序对只存在三种情况, 在左半边, 在右半边,
或者横跨左右区间. 假设 <code>merge_sort</code>
能在排序的同时计算出逆序对的数量, 那么前两种情况等于递归调用
<code>merge_sort</code> 的值. 横跨左右区间的情况稍微比较复杂.
利用的是<code>merge</code>区间的单调性.
我们求的是<code>left</code>中每一个元素对应<code>right</code>中逆序对的数量.
假设我们找到了 <code>left[i] &gt; right[j]</code>, 那么一定有
<code>left[i...mid] &gt; right[j]</code>. 也就是说存在
<code>mid - i + 1</code> 个逆序对.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    LL res = <span class="built_in">merge_sort</span>(q, l, mid) + <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(q[i] &lt;= q[j])</span><br><span class="line">            tmp[k++] = q[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            res += mid - i + <span class="number">1</span>;</span><br><span class="line">            tmp[k++] = q[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid)</span><br><span class="line">        tmp[k++] = q[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= r)</span><br><span class="line">        tmp[k++] = q[j++];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = l, j = <span class="number">0</span>; i &lt;= r; i++, j++)</span><br><span class="line">        q[i] = tmp[j];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="k-way-merge">k-way merge</h3>
<p>如果需要merge的数组不止2个, 该怎么实现呢?</p>
<ul>
<li>建立一个小根堆.</li>
<li>将每一路的第一个元素插入小根堆. 我们可以知道<code>heap[1]</code>
就是最小值.</li>
<li>将堆顶元素弹出, 并将堆顶元素所在数组的下一元素加入堆中.</li>
<li>重复上面两步, 直到每一路都读取结束.</li>
</ul>
<p><a href="https://leetcode.cn/problems/merge-k-sorted-lists/">LeetCode
第 23 号问题: 合并 K 个排序链表</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// struct ListNode</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     int val;                                </span></span><br><span class="line"><span class="comment">//     ListNode *next;                         </span></span><br><span class="line"><span class="comment">//     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">mycomp</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(ListNode *a, ListNode *b)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a-&gt;val &gt; b-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">ListNode *<span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode *&gt; &amp;lists)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        priority_queue&lt;ListNode *, vector&lt;ListNode *&gt;, mycomp&gt; queue;</span><br><span class="line">        <span class="keyword">for</span> (ListNode *head : lists)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (head)</span><br><span class="line">                queue.<span class="built_in">push</span>(head);</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode *temp = dummy;</span><br><span class="line">        <span class="keyword">while</span> (!queue.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *p = queue.<span class="built_in">top</span>();</span><br><span class="line">            queue.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;next)</span><br><span class="line">                queue.<span class="built_in">push</span>(p-&gt;next);</span><br><span class="line">            temp-&gt;next = p;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a
href="https://www.acwing.com/problem/content/description/1264/">鱼塘钓鱼</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> a[N], d[N], s[N];</span><br><span class="line">priority_queue&lt;PII&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">work</span><span class="params">(<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= t; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> p = q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p.first &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        res += p.first;</span><br><span class="line">        p.first -= p.second;</span><br><span class="line">        q.<span class="built_in">push</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, T;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; d[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; s[i];</span><br><span class="line">        s[i] += s[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n &amp;&amp; s[i] &lt;= T; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">            q.<span class="built_in">push</span>(&#123;a[j], d[j]&#125;);</span><br><span class="line"></span><br><span class="line">        ans = <span class="built_in">max</span>(ans, <span class="built_in">work</span>(T - s[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
        <tag>分治</tag>
        <tag>多路归并</tag>
      </tags>
  </entry>
  <entry>
    <title>双指针算法</title>
    <url>/2023/01/13/%E5%8F%8C%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<p>双指针核心要义是将含两层嵌套的朴素算法,
利用某种性质(例如单调性)将其优化成<code>O(n)</code>的过程.
有种并发的感觉——一步能干两个人的事情, 就不要等另一个人干完再去做.</p>
<p>双指针一般会结合其他数据结构或者算法一起使用.</p>
<span id="more"></span>
<h2 id="通用模板">通用模板</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 也可能是 j = n, 那么条件改为 j &gt; i, 以及 j--</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt; i &amp;&amp; <span class="built_in">check</span>(i, j))</span><br><span class="line">        j++;</span><br><span class="line">    <span class="comment">// 每道题目的具体逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="双指针应用">双指针应用</h2>
<h3 id="最长连续不重复子序列">最长连续不重复子序列</h3>
<p><a
href="https://www.acwing.com/problem/content/description/801/">AcWing
799. 最长连续不重复子序列</a></p>
<p>朴素算法:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(v1, j, i))</span><br><span class="line">            res = <span class="built_in">max</span>(res, i - j + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 检查 [l, r] 区间上有无重复元素</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v1, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l + <span class="number">1</span>; i &lt;= r; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = l; j &lt; i; j++)</span><br><span class="line">            <span class="keyword">if</span> (v1[i] == v1[j])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>换用双指针(有点hashmap的感觉):</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    s[a[i]]++;          <span class="comment">// a[i]出现的次数(标记)加一</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt; i &amp;&amp; s[a[i]] &gt; <span class="number">1</span>)</span><br><span class="line">        s[a[j++]]--;    <span class="comment">// 如果存在重复元素 标记减一 j 右移 </span></span><br><span class="line">    res = <span class="built_in">max</span>(res, i - j + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组元素的目标和">数组元素的目标和</h3>
<p><a href="https://www.acwing.com/problem/content/802/">AcWing 800.
数组元素的目标和</a></p>
<p>朴素做法:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i] + B[j] == x)</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>双指针:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = m - <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; A[i] + B[j] &gt; x)</span><br><span class="line">        j--;</span><br><span class="line">    <span class="keyword">if</span>(j &gt;= <span class="number">0</span> &amp;&amp; A[i] + B[j] == x)</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断子序列">判断子序列</h3>
<p><a href="https://www.acwing.com/problem/content/2818/">AcWing 2816.
判断子序列</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i, j;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>, j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; n &amp;&amp; a[i] == b[j])</span><br><span class="line">        i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, (i == n) ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>新冠生存手册</title>
    <url>/2022/12/22/%E6%96%B0%E5%86%A0%E7%94%9F%E5%AD%98%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<p>感染新冠快成每日打卡项目了. 每天都能刷到同学感染的信息,
"今天又发了39度的烧"——然而这并不是值得炫耀的一件事. 二阳化碳, 三阳开泰,
四阳方尊, 五阳电动车, 六阳魁首, 七阳化二锰, 八阳化二硫, 九阳豆浆机
如果能在全员感染的范围内存活下来, 那么你就是大赢.
我不相信染病后没有后遗症, 就算苟我也要撑到群体免疫快结束的时候.
提心吊胆地过着放开后的日子, 保持身处末世一般的警惕,
做好保护自己生命的职责.</p>
<p>更新: 12.28 阳了 估计是舍友交叉感染的 Q:
有个一声不吭的舍友是怎样的一种感受? 被害惨了.</p>
<span id="more"></span>
<p><a href="https://zhuanlan.zhihu.com/p/579970078">知乎回答</a></p>
<p>气溶胶传染主要是通过呼吸道, 病毒接触皮肤表面只要不接触口鼻眼,
之后消毒或清洁就行</p>
<h2 id="防护方式">防护方式</h2>
<p>谨防交叉感染! 自己防护做全了,
也要<strong>确保</strong>家里人/舍友能够执行.</p>
<p>回答来源于<a
href="https://www.zhihu.com/question/570483700/answer/2796072947">知乎</a>:</p>
<p>下水道消毒: 加盖加水防止气溶胶产生</p>
<p>衣服消毒: 衣用消毒剂 紫外线灯 酒精喷雾</p>
<p>室外消毒: 消毒凝胶 酒精喷雾随身携带</p>
<p>口罩: 能不摘就不摘 医用4小时一换 N95/FFP2一天一换+备用 不放在口袋
不要吝啬</p>
<p>吃饭: 明确堂食必G</p>
<p>头发消毒: 洗头洗澡</p>
<p>外出装备: N95戴+备用 塑料面罩(防疫人员戴的) 装有消毒液的小喷壶</p>
<h3 id="戴口罩的误区">戴口罩的误区</h3>
<p><a
href="https://www.zhihu.com/question/573023186/answer/2814221461">知乎:为什么全国人民都佩戴N95口罩后，新冠病毒还能爆发式传播？</a></p>
<h2 id="感染后的感觉">感染后的感觉</h2>
<p>感染前一天晚上: 好热 不太好睡 喉咙好干 半夜爬下去喝水</p>
<p>第一天: 早上高数考试 考完感觉人没啥力气 联想到舍友咳嗽的事情
中午吃完饭就去校医院 测了体温38.3度 抗原检测一开始看不到T线
过了几分钟看到浅浅的一条线 G了 开了退烧药和银黄颗粒
回了一趟寝室叫室友去校医院治治咳嗽 但他好像已经阳康了😅
下午开始就在床上度过了极为痛苦的一天 乏力 体温不均 晚上测了体温39度
吃了退烧药 稍微好些 这一晚非常痛苦 一开始冷的睡不着 套上了几件衣服
半夜又被热醒了</p>
<p>第二天: 依然乏力 体温依然是39度 疯狂喝水 一天去了不知道多少次厕所
吃了退烧药 今天比昨天好很多 但依然很难受 晚上买了饭 结果一口也吃不下去
鸡蛋是苦的 萝卜是苦的 啥都是苦的 10块钱浪费了 这一天解决了论文框架</p>
<p>第三天: 今天退烧了 开始有能力在电脑前产出了 今天把论文写完了
但喉咙巨难受 所谓的口吞刀片 腊八 吃了免费的腊八粥 晚饭吃原汤抄手
事实上这几天只适合吃这些</p>
<p>第四天: 今天也没发烧 但喉咙依然很痛 胃口已经要比前几天好了
生产力基本恢复正常 今天ddl 改完论文提交了 该接着复习考试了</p>
<p>第五天开始: 基本上正常 除了喉咙痛 吃不了辣 基本上啥都能干了</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>随感录</title>
    <url>/2023/01/28/%E9%9A%8F%E6%84%9F%E5%BD%95/</url>
    <content><![CDATA[<p>记录不时的奇思妙想. 奇怪的梦, 无垠的呓语, 似非的感悟.
忙碌后的凝思会带给人宁静, 或许人的创作欲此刻迸发. 胡诌数句,
想想还是删去罢了.</p>
<span id="more"></span>
<h2 id="鬼话">鬼话</h2>
<p>你见到的每个人都随身携带着粪便.</p>
<h2 id="绮梦-一">绮梦 (一)</h2>
<p>留坑.</p>
<h2 id="绮梦-二">绮梦 (二)</h2>
<!-- ## 恋爱, 相亲, 然后是坟墓

小镇做题家不懂恋爱.

[陆蠡《嫁衣》](https://www.uuzuowen.com/kewaitushu/zhongguozuimeisanwen/14488.html) -->
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>保研, 相亲, 找工作——背后的稳定匹配问题</title>
    <url>/2023/02/06/%E7%A8%B3%E5%AE%9A%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98%E5%8F%8AGale-Shapley%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="介绍">介绍</h2>
<p><strong>稳定匹配问题</strong>(Stable Matching Problem)最早出自 D.Gale
和 L.S.Sharpley
1962年发表在美国数学月刊上的一篇关于<em>大学录取和婚姻稳定</em>的文章<a
href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a>. 解决这个问题的算法出奇地简单,
甚至是<strong>自我执行</strong>(self-forcing)的——换言之,
不需要系统的调度, 就能获得令人满意的结果!</p>
<p>本文重点陈述算法的正确性——作为离散数学中<em>逻辑命题与证明</em>的简单应用.</p>
<span id="more"></span>
<h2 id="问题描述">问题描述</h2>
<p>问题描述: 考虑你经营一家雇佣系统, 任务将 <span
class="math inline">\(n\)</span> 个职位和 <span
class="math inline">\(n\)</span> 名候选人匹配起来. 每项工作对 <span
class="math inline">\(n\)</span> 名候选人有一排序的倾向表,
每位候选人也有类似的表.</p>
<p>例如, 考虑 <span class="math inline">\(n=3\)</span>, 为简化,
我们假设候选人为 A, B, C, 岗位为 1, 2, 3. 对于 A, 他的倾向表为 2, 1, 3,
表示最希望分配到2, 1次之, 3最后. 同样的, 岗位1选人的倾向表为 A, C, B,
表示最希望招到 A, C次之, B最后.</p>
<p>我们的目标是: 最大化总满足度, 最大化每个人的第一选择,
以及减少倾向排名的差距</p>
<p>Gale-Shapley 算法 (a.k.a. The Propose-and-Reject Algorithm)</p>
<p>对于每一天:</p>
<ul>
<li>每个职位向它列表上最希望的候选人发offer.</li>
<li>每个候选人都可以拒绝非自己最期望的offer.
已得的offer会置于一个string上.</li>
<li>被拒绝的职位会在表上划去拒绝人的名字.</li>
</ul>
<p>当每个人都拿到offer的时候, 程序停止.</p>
<figure>
<img src="/images/anim1.gif" alt="例子" />
<figcaption aria-hidden="true">例子</figcaption>
</figure>
<h2 id="before-符号定义">Before: 符号定义</h2>
<p><strong>定义 1</strong> 包含 <span class="math inline">\(n\)</span>
对 pair 的不交集, 称为<strong>匹配</strong> <span
class="math inline">\(S\)</span>.</p>
<p>例如: <span class="math inline">\(S = \{(1, A), (2, B), (3,
C)\}\)</span> 就是一个包含 <span class="math inline">\(3\)</span> 对
pair 的匹配.</p>
<p><strong>定义 2</strong> 如果 <span class="math inline">\(b\)</span>
比起 <span class="math inline">\(g\)</span> 更喜欢 <span
class="math inline">\(g^{*}\)</span>, 记 <span
class="math inline">\(g^{*} &gt; g\)</span>. 特别地, 如果 <span
class="math inline">\(b\)</span> 认为 <span
class="math inline">\(g^{*}\)</span> 至少和 <span
class="math inline">\(g\)</span> 一样好, 记 <span
class="math inline">\(g^{*} \geqslant g\)</span>, 当且仅当 <span
class="math inline">\(g^{*} = g\)</span> 取等.</p>
<p><strong>定义 3</strong> 对于匹配 <span
class="math inline">\(S\)</span> 中的元素 <span class="math inline">\(b,
g^{*}\)</span>: 如果 <span class="math inline">\(b, g^{*}\)</span>
是比当前 partner 更优的一对, 则称 <span class="math inline">\(b,
g^{*}\)</span> 为一对<strong>rouge couple</strong>.</p>
<p>例如: 假设对 <span class="math inline">\(1\)</span> 有 <span
class="math inline">\(C&gt;B\)</span>, <span
class="math inline">\(C\)</span> 认为 <span
class="math inline">\(1&gt;2\)</span>, 那么匹配 <span
class="math inline">\(S = \{(1, B), (2, C)\}\)</span> 中存在 rouge
couple <span class="math inline">\(1, C\)</span>.</p>
<p><strong>定义 4</strong> 不存在 rouge couple 的匹配 <span
class="math inline">\(S\)</span> 称为<strong>稳定匹配</strong>.
否则则为不稳定匹配.</p>
<p>在上面的例子中: 因为 <span class="math inline">\(1\)</span> 可以追求
<span class="math inline">\(C\)</span>, 同时 <span
class="math inline">\(C\)</span> 也会欣然接受 <span
class="math inline">\(1\)</span>, <span
class="math inline">\((1,B)\)</span> 及 <span
class="math inline">\((2,C)\)</span> 都有决裂的可能, 因此 <span
class="math inline">\(S\)</span> 是一个不稳定匹配.</p>
<h2 id="证明">证明</h2>
<h3 id="总能停下">总能停下</h3>
<p><strong>引理 1</strong> 算法总能停下.</p>
<p><strong>证明</strong> 算法尚未停止时,
每一天结束至少有一家公司将应聘者的人名从列表上划去. 因为列表有 <span
class="math inline">\(n\)</span> 份, 每份上有 <span
class="math inline">\(n\)</span> 个元素, 因此算法至多在 <span
class="math inline">\(n^2\)</span> 的迭代(天)下终止.</p>
<h3 id="进步引理">进步引理</h3>
<p><strong>引理 2</strong> 对于第 <span class="math inline">\(t\)</span>
天, 候选人 <span class="math inline">\(g\)</span> 手上有职位 <span
class="math inline">\(b\)</span>, 那么第 <span
class="math inline">\(t&#39;\)</span> 天结束, 他手上的 <span
class="math inline">\(\forall b&#39;\)</span> 至少和 <span
class="math inline">\(b\)</span> 一样好, 其中 <span
class="math inline">\(t&#39; &gt; t\)</span>.</p>
<p><strong>证明</strong> 我们对天数 <span
class="math inline">\(i\geqslant k\)</span> 归纳.</p>
<p>当 <span class="math inline">\(i = k\)</span>, <span
class="math inline">\(C\)</span> <em>可以</em>收到至少一份offer(来自
<span class="math inline">\(J\)</span>). 在第 <span
class="math inline">\(k\)</span> 天结束, <span
class="math inline">\(C\)</span> 手上至少会有 <span
class="math inline">\(J\)</span> 或者比 <span
class="math inline">\(J\)</span> 更好的offer(他可以自行选择).</p>
<p>对于 <span class="math inline">\(\forall i \geqslant k\)</span>
的情况, 假设命题成立, 只需归纳证明对 <span
class="math inline">\(i+1\)</span> 命题同样成立.</p>
<p>根据我们的假设, 第 <span class="math inline">\(i\)</span> 天 <span
class="math inline">\(C\)</span> 获得了 <span
class="math inline">\(J&#39;\geqslant J\)</span>, 根据算法, <span
class="math inline">\(J&#39;\)</span> 在第 <span
class="math inline">\(i+1\)</span> 天依然会向 <span
class="math inline">\(C\)</span> 给出offer(因为 <span
class="math inline">\(C\)</span> 在第 <span
class="math inline">\(i\)</span> 天没理由拒绝或者 <span
class="math inline">\(J&#39;\)</span> 凭空消失). 因此当第 <span
class="math inline">\(i+1\)</span> 天结束, <span
class="math inline">\(C\)</span> 手上要么是 <span
class="math inline">\(J&#39;\)</span>, 要么是比 <span
class="math inline">\(J&#39;\)</span> 更好的offer; 两种情况都 <span
class="math inline">\(\geqslant J\)</span>, 因此结论对第 <span
class="math inline">\(i+1\)</span> 天成立.</p>
<h3 id="正确性">正确性</h3>
<p><strong>引理 3</strong> Gale-Sharpley算法得出的匹配不存在rouge
couple.</p>
<p><strong>证明</strong> 反证法. 假设存在 <span
class="math inline">\((b,g^{*})\)</span>, 且当前匹配为 <span
class="math inline">\((b,g),(b^{*},g^{*})\)</span>. <span
class="math inline">\(b\)</span> 比起 <span
class="math inline">\(g\)</span> 更喜欢 <span
class="math inline">\(g*\)</span>, 在给 <span
class="math inline">\(g\)</span> 发出offer之前先给 <span
class="math inline">\(g^{*}\)</span> 发出了offer, 而 <span
class="math inline">\(g^{*}\)</span> 拒绝了 <span
class="math inline">\(b\)</span>, 由引理 2, 知 <span
class="math inline">\(g^{*}\)</span> 比起 <span
class="math inline">\(b^{*}\)</span> 更喜欢 <span
class="math inline">\(b\)</span>, 与条件矛盾.</p>
<p><strong>定理 1</strong> Gale-Sharpley 算法是一种稳定的匹配算法.</p>
<p><strong>证明</strong> 由引理 1 和引理 3 可知其正确.</p>
<h3 id="最优性-对谁更有利">最优性: 对谁更有利?</h3>
<p><strong>定义 5</strong> 如果 <span class="math inline">\(x\)</span>
的 partner 在任何稳定匹配下皆为它的最佳 partner, 称匹配为 <span
class="math inline">\(x\)</span> 最优的.</p>
<p>同样可以给出 <span class="math inline">\(x\)</span> 最劣的定义.</p>
<p><strong>定义 6</strong> 如果对全部工作/候选人 <span
class="math inline">\(x\)</span> 都是 <span
class="math inline">\(x\)</span> 最优的, 称匹配为工作/候选人最优.</p>
<p>例子: A:1,2 B:2,1 1:A,B 2:A,B</p>
<p>S: (A,1) (B,2) T: (A,2) (B,1)</p>
<p>S, T 都是稳定的. 但 S 是对 A,B 最优, T 对 1,2 最优.</p>
<p><strong>定理 2</strong> Gale-Sharpley算法是工作最优匹配.</p>
<p><strong>证明</strong> 假设匹配对工作不是最优的: 存在 <span
class="math inline">\(b\)</span> 得不到最优候选人 <span
class="math inline">\(g\)</span>. 存在稳定匹配 <span
class="math inline">\(S\)</span> 存在 <span
class="math inline">\((b,g)\)</span> 匹配. 令 <span
class="math inline">\(t\)</span> 为 <span
class="math inline">\(b\)</span> 被 <span
class="math inline">\(g\)</span> 拒绝的第一天, 那么在第 <span
class="math inline">\(t\)</span> 日有 <span
class="math inline">\(b^{*}\)</span> 与 <span
class="math inline">\(g\)</span> 匹配, 也就意味着 <span
class="math inline">\(g\)</span> 比起 <span
class="math inline">\(b\)</span> 更喜欢 <span
class="math inline">\(b^{*}\)</span>. <span
class="math inline">\(b^{*}\)</span> 至少也会将 <span
class="math inline">\(g\)</span> 作为它的最优候选人看待, 也就推出了"
<span class="math inline">\(b^{*}\)</span> 比起他在 <span
class="math inline">\(S\)</span> 中的 partner <span
class="math inline">\(g^{*}\)</span> 更喜欢 <span
class="math inline">\(g\)</span> "的结论, 而 <span
class="math inline">\(b,g^{*}\)</span> 是一对rogue couple, 也即 <span
class="math inline">\(S\)</span> 是不稳定的, 也就发生了矛盾.</p>
<h2 id="拓展阅读">拓展阅读</h2>
<p><a href="https://www.eecs70.org/assets/pdf/notes/n4.pdf">UCB CS70
Note 4: Stable Matching Problem</a></p>
<p>D. Gale and L.S. Shapley, “College Admissions and the Stability of
Marriage,” <em>American Mathematical Monthly</em> <strong>69</strong>
(1962), pp. 9–14.</p>
<p>D. Gusfield and R.W. Irving, <em>The Stable Marriage Problem:
Structure and Algorithms</em>, MIT Press, 1989.</p>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>Matching领域的开山文章, 算法分析的伟大成就之一, 顺带一提
Sharpley 也是<a
href="https://news.yahoo.com/2-americans-win-nobel-economics-prize-111239568--finance.html">2012年诺贝尔经济学奖</a>的得主.
题外话: 在文章的最后, 作者提到希望借此文章改变大众对数学/数学家的认知:
我们真的不是只懂"一堆公式", 不说人话的家伙;
还希望数学老师也能启发启发学生 :)<a href="#fnref1" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>离散数学</tag>
      </tags>
  </entry>
</search>
